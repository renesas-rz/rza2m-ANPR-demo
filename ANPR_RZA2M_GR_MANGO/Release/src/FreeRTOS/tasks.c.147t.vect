
;; Function prvIdleTask (prvIdleTask, funcdef_no=40, decl_uid=7841, cgraph_uid=40, symbol_order=64) (executed once)

../src/FreeRTOS/tasks.c:3295:8: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:3295:8: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:3295:8: note: not vectorized: multiple nested loops.
../src/FreeRTOS/tasks.c:3295:8: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/tasks.c:3335
../src/FreeRTOS/tasks.c:3335:6: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:3335:6: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:3335:6: note: not vectorized: control flow in loop.
../src/FreeRTOS/tasks.c:3335:6: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/tasks.c:3550
../src/FreeRTOS/tasks.c:3550:8: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:3550:8: note: === vect_analyze_loop_form ===
split exit edge.
../src/FreeRTOS/tasks.c:3550:8: note: === get_loop_niters ===
../src/FreeRTOS/tasks.c:3550:8: note: not vectorized: number of iterations cannot be computed.
../src/FreeRTOS/tasks.c:3550:8: note: bad loop form.
../src/FreeRTOS/tasks.c:3295:8: note: vectorized 0 loops in function.
prvIdleTask (void * pvParameters)
{
  struct TCB_t * pxTCB;
  long unsigned int _4;
  struct xLIST_ITEM * _7;
  struct ListItem_t * _9;
  long unsigned int uxCurrentNumberOfTasks.57_10;
  long unsigned int _11;
  long unsigned int uxDeletedTasksWaitingCleanUp.58_12;
  long unsigned int _13;
  StackType_t * _14;
  long unsigned int uxDeletedTasksWaitingCleanUp.59_15;
  long unsigned int uxDeletedTasksWaitingCleanUp.59_24;

  <bb 2>:

  <bb 3>:

  <bb 4>:
  uxDeletedTasksWaitingCleanUp.59_24 ={v} uxDeletedTasksWaitingCleanUp;
  if (uxDeletedTasksWaitingCleanUp.59_24 != 0)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  _4 ={v} pxReadyTasksLists[0].uxNumberOfItems;
  if (_4 > 1)
    goto <bb 10>;
  else
    goto <bb 9>;

  <bb 6>:

  <bb 7>:
  vPortEnterCritical ();
  _7 = xTasksWaitingTermination.xListEnd.pxNext;
  pxTCB_8 = _7->pvOwner;
  _9 = &pxTCB_8->xStateListItem;
  uxListRemove (_9);
  uxCurrentNumberOfTasks.57_10 ={v} uxCurrentNumberOfTasks;
  _11 = uxCurrentNumberOfTasks.57_10 + 4294967295;
  uxCurrentNumberOfTasks ={v} _11;
  uxDeletedTasksWaitingCleanUp.58_12 ={v} uxDeletedTasksWaitingCleanUp;
  _13 = uxDeletedTasksWaitingCleanUp.58_12 + 4294967295;
  uxDeletedTasksWaitingCleanUp ={v} _13;
  vPortExitCritical ();
  _14 = pxTCB_8->pxStack;
  vPortFree (_14);
  vPortFree (pxTCB_8);
  uxDeletedTasksWaitingCleanUp.59_15 ={v} uxDeletedTasksWaitingCleanUp;
  if (uxDeletedTasksWaitingCleanUp.59_15 != 0)
    goto <bb 8>;
  else
    goto <bb 11>;

  <bb 11>:
  goto <bb 5>;

  <bb 8>:
  goto <bb 7>;

  <bb 9>:
  goto <bb 4>;

  <bb 10>:
  __asm__ __volatile__("SWI 0" :  :  : "memory");
  goto <bb 3>;

}



;; Function vTaskSwitchContext.part.4 (vTaskSwitchContext.part.4, funcdef_no=72, decl_uid=9594, cgraph_uid=49, symbol_order=127)


Analyzing loop at ../src/FreeRTOS/tasks.c:2960
../src/FreeRTOS/tasks.c:2960:3: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:2960:3: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:2960:3: note: not vectorized: control flow in loop.
../src/FreeRTOS/tasks.c:2960:3: note: bad loop form.
../src/FreeRTOS/tasks.c:2908:6: note: vectorized 0 loops in function.
vTaskSwitchContext.part.4 ()
{
  const uint32_t * const pulStack;
  const uint32_t ulCheckValue;
  UBaseType_t uxTopPriority;
  struct List_t * const pxConstList;
  long unsigned int _1;
  long unsigned int ulTaskSwitchedInTime.90_2;
  struct TCB_t * pxCurrentTCB.91_3;
  long unsigned int _4;
  sizetype _5;
  long unsigned int _6;
  struct TCB_t * pxCurrentTCB.92_7;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  struct TCB_t * pxCurrentTCB.93_13;
  struct TCB_t * pxCurrentTCB.94_14;
  char[24] * _15;
  sizetype _17;
  long unsigned int _19;
  struct ListItem_t * _20;
  struct xLIST_ITEM * _21;
  struct MiniListItem_t * _22;
  struct xLIST_ITEM * _23;
  void * _25;
  long unsigned int _29;
  long unsigned int _48;
  struct ListItem_t * prephitmp_64;

  <bb 2>:
  xYieldPending ={v} 0;
  _1 = ulGetRunTimeCounterValue ();
  ulTaskSwitchedInTime.90_2 = ulTaskSwitchedInTime;
  if (_1 > ulTaskSwitchedInTime.90_2)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  pxCurrentTCB.91_3 ={v} pxCurrentTCB;
  _4 = pxCurrentTCB.91_3->ulRunTimeCounter;
  _29 = _4 - ulTaskSwitchedInTime.90_2;
  _6 = _1 + _29;
  pxCurrentTCB.91_3->ulRunTimeCounter = _6;

  <bb 4>:
  ulTaskSwitchedInTime = _1;
  pxCurrentTCB.92_7 ={v} pxCurrentTCB;
  pulStack_8 = pxCurrentTCB.92_7->pxStack;
  _9 = *pulStack_8;
  if (_9 != 2779096485)
    goto <bb 8>;
  else
    goto <bb 5>;

  <bb 5>:
  _10 = MEM[(const uint32_t *)pulStack_8 + 4B];
  if (_10 != 2779096485)
    goto <bb 8>;
  else
    goto <bb 6>;

  <bb 6>:
  _11 = MEM[(const uint32_t *)pulStack_8 + 8B];
  if (_11 != 2779096485)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  _12 = MEM[(const uint32_t *)pulStack_8 + 12B];
  if (_12 != 2779096485)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  pxCurrentTCB.93_13 ={v} pxCurrentTCB;
  pxCurrentTCB.94_14 ={v} pxCurrentTCB;
  _15 = &pxCurrentTCB.94_14->pcTaskName;
  vApplicationStackOverflowHook (pxCurrentTCB.93_13, _15);

  <bb 9>:
  uxTopPriority_16 ={v} uxTopReadyPriority;
  _48 ={v} pxReadyTasksLists[uxTopPriority_16].uxNumberOfItems;
  if (_48 == 0)
    goto <bb 10>;
  else
    goto <bb 16>;

  <bb 10>:

  <bb 11>:
  # uxTopPriority_49 = PHI <uxTopPriority_16(10), uxTopPriority_18(15)>
  if (uxTopPriority_49 == 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  R_OS_AssertCalled ("../src/FreeRTOS/tasks.c", 2960);

  <bb 13>:
  uxTopPriority_18 = uxTopPriority_49 + 4294967295;
  _19 ={v} pxReadyTasksLists[uxTopPriority_18].uxNumberOfItems;
  if (_19 == 0)
    goto <bb 15>;
  else
    goto <bb 14>;

  <bb 14>:
  # uxTopPriority_61 = PHI <uxTopPriority_18(13)>
  goto <bb 16>;

  <bb 15>:
  goto <bb 11>;

  <bb 16>:
  # uxTopPriority_47 = PHI <uxTopPriority_61(14), uxTopPriority_16(9)>
  _20 = MEM[(struct List_t *)&pxReadyTasksLists][uxTopPriority_47].pxIndex;
  _21 = _20->pxNext;
  MEM[(struct List_t *)&pxReadyTasksLists][uxTopPriority_47].pxIndex = _21;
  _17 = uxTopPriority_47 * 20;
  _5 = _17 + 8;
  _22 = &pxReadyTasksLists + _5;
  if (_21 == _22)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  _23 = MEM[(struct ListItem_t *)_21].pxNext;
  MEM[(struct List_t *)&pxReadyTasksLists][uxTopPriority_47].pxIndex = _23;

  <bb 18>:
  # prephitmp_64 = PHI <_21(16), _23(17)>
  _25 = prephitmp_64->pvOwner;
  pxCurrentTCB ={v} _25;
  uxTopReadyPriority ={v} uxTopPriority_47;
  return;

}



;; Function xTaskCreate (xTaskCreate, funcdef_no=1, decl_uid=6806, cgraph_uid=1, symbol_order=25)


Analyzing loop at ../src/FreeRTOS/tasks.c:3511
../src/FreeRTOS/tasks.c:3511:2: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:3511:2: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:3511:2: note: === get_loop_niters ===
Analyzing # of iterations of loop 3
  exit condition [19, + , 4294967295] != 0
  bounds on difference of bases: -19 ... -19
  result:
    # of iterations 19, bounded by 19
../src/FreeRTOS/tasks.c:3511:2: note: not vectorized: loop contains function calls or data references that cannot be analyzed

Analyzing loop at ../src/FreeRTOS/tasks.c:904
../src/FreeRTOS/tasks.c:904:37: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:904:37: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:904:37: note: not vectorized: control flow in loop.
../src/FreeRTOS/tasks.c:904:37: note: bad loop form.
../src/FreeRTOS/tasks.c:743:13: note: vectorized 0 loops in function.
xTaskCreate (void (*TaskFunction_t) (void *) pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, void * * const pxCreatedTask)
{
  UBaseType_t uxPriority;
  UBaseType_t x;
  StackType_t * pxTopOfStack;
  UBaseType_t uxPriority;
  StackType_t * pxStack;
  BaseType_t xReturn;
  struct TCB_t * pxNewTCB;
  unsigned int _6;
  unsigned int _7;
  long unsigned int pretmp_21;
  long unsigned int uxCurrentNumberOfTasks.1_22;
  long unsigned int _23;
  struct TCB_t * pxCurrentTCB.2_24;
  long unsigned int uxCurrentNumberOfTasks.3_25;
  long int xSchedulerRunning.4_26;
  struct TCB_t * pxCurrentTCB.5_27;
  long unsigned int _28;
  long unsigned int _29;
  long unsigned int uxTaskNumber.6_30;
  long unsigned int _31;
  long unsigned int uxTopReadyPriority.7_33;
  struct List_t * _34;
  long int xSchedulerRunning.8_36;
  struct TCB_t * pxCurrentTCB.9_37;
  long unsigned int _38;
  long unsigned int _39;
  sizetype _40;
  long unsigned int pretmp_41;
  StackType_t * _42;
  sizetype _43;
  sizetype _44;
  long unsigned int pxTopOfStack.0_46;
  long unsigned int _47;
  const char * _50;
  char _51;
  char _52;
  struct ListItem_t * _55;
  struct ListItem_t * _56;
  long unsigned int _57;
  StackType_t * _60;
  struct List_t * _62;
  long unsigned int prephitmp_64;
  long unsigned int pretmp_65;
  long unsigned int ivtmp_122;
  sizetype _124;
  long unsigned int ivtmp_125;
  long unsigned int ivtmp_126;
  long unsigned int ivtmp_127;

  <bb 2>:
  _6 = (unsigned int) usStackDepth_5(D);
  _7 = _6 * 4;
  pxStack_10 = pvPortMalloc (_7);
  if (pxStack_10 != 0B)
    goto <bb 3>;
  else
    goto <bb 27>;

  <bb 3>:
  pxNewTCB_12 = pvPortMalloc (120);
  if (pxNewTCB_12 != 0B)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  pxNewTCB_12->pxStack = pxStack_10;
  memset (pxStack_10, 165, _7);
  _42 = pxNewTCB_12->pxStack;
  _43 = _6 + 1073741823;
  _44 = _43 * 4;
  pxTopOfStack_45 = _42 + _44;
  pxTopOfStack.0_46 = (long unsigned int) pxTopOfStack_45;
  _47 = pxTopOfStack.0_46 & 4294967288;
  pxTopOfStack_48 = (StackType_t *) _47;
  pxNewTCB_12->pxEndOfStack = pxTopOfStack_48;
  goto <bb 7>;

  <bb 5>:
  vPortFree (pxStack_10);
  goto <bb 27>;

  <bb 6>:

  <bb 7>:
  # x_128 = PHI <x_53(6), 0(4)>
  # ivtmp_125 = PHI <ivtmp_122(6), 24(4)>
  _50 = pcName_16(D) + x_128;
  _51 = *_50;
  pxNewTCB_12->pcTaskName[x_128] = _51;
  _52 = *_50;
  if (_52 == 0)
    goto <bb 9>;
  else
    goto <bb 8>;

  <bb 8>:
  x_53 = x_128 + 1;
  ivtmp_122 = ivtmp_125 - 1;
  if (ivtmp_122 != 0)
    goto <bb 6>;
  else
    goto <bb 9>;

  <bb 9>:
  pxNewTCB_12->pcTaskName[23] = 0;
  uxPriority_123 = MIN_EXPR <uxPriority_18(D), 19>;
  pxNewTCB_12->uxPriority = uxPriority_123;
  pxNewTCB_12->uxBasePriority = uxPriority_123;
  pxNewTCB_12->uxMutexesHeld = 0;
  _55 = &pxNewTCB_12->xStateListItem;
  vListInitialiseItem (_55);
  _56 = &pxNewTCB_12->xEventListItem;
  vListInitialiseItem (_56);
  pxNewTCB_12->xStateListItem.pvOwner = pxNewTCB_12;
  _57 = 20 - uxPriority_123;
  pxNewTCB_12->xEventListItem.xItemValue = _57;
  pxNewTCB_12->xEventListItem.pvOwner = pxNewTCB_12;
  pxNewTCB_12->ulRunTimeCounter = 0;
  pxNewTCB_12->pvThreadLocalStoragePointers[0] = 0B;
  pxNewTCB_12->pvThreadLocalStoragePointers[1] = 0B;
  pxNewTCB_12->pvThreadLocalStoragePointers[2] = 0B;
  pxNewTCB_12->ulNotifiedValue ={v} 0;
  pxNewTCB_12->ucNotifyState ={v} 0;
  pxNewTCB_12->ucDelayAborted = 0;
  _60 = pxPortInitialiseStack (pxTopOfStack_48, pxTaskCode_15(D), pvParameters_17(D));
  pxNewTCB_12->pxTopOfStack = _60;
  if (pxCreatedTask_19(D) != 0B)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  *pxCreatedTask_19(D) = pxNewTCB_12;

  <bb 11>:
  vPortEnterCritical ();
  uxCurrentNumberOfTasks.1_22 ={v} uxCurrentNumberOfTasks;
  _23 = uxCurrentNumberOfTasks.1_22 + 1;
  uxCurrentNumberOfTasks ={v} _23;
  pxCurrentTCB.2_24 ={v} pxCurrentTCB;
  if (pxCurrentTCB.2_24 == 0B)
    goto <bb 12>;
  else
    goto <bb 18>;

  <bb 12>:
  pxCurrentTCB ={v} pxNewTCB_12;
  uxCurrentNumberOfTasks.3_25 ={v} uxCurrentNumberOfTasks;
  if (uxCurrentNumberOfTasks.3_25 == 1)
    goto <bb 14>;
  else
    goto <bb 13>;

  <bb 13>:
  pretmp_41 = pxNewTCB_12->uxPriority;
  goto <bb 22>;

  <bb 14>:

  <bb 15>:
  # uxPriority_129 = PHI <0(14), uxPriority_63(16)>
  # ivtmp_126 = PHI <20(14), ivtmp_127(16)>
  _40 = uxPriority_129 * 20;
  _62 = &pxReadyTasksLists + _40;
  vListInitialise (_62);
  uxPriority_63 = uxPriority_129 + 1;
  ivtmp_127 = ivtmp_126 - 1;
  if (ivtmp_127 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  goto <bb 15>;

  <bb 17>:
  vListInitialise (&xDelayedTaskList1);
  vListInitialise (&xDelayedTaskList2);
  vListInitialise (&xPendingReadyList);
  vListInitialise (&xTasksWaitingTermination);
  vListInitialise (&xSuspendedTaskList);
  pxDelayedTaskList ={v} &xDelayedTaskList1;
  pxOverflowDelayedTaskList ={v} &xDelayedTaskList2;
  pretmp_21 = pxNewTCB_12->uxPriority;
  goto <bb 22>;

  <bb 18>:
  xSchedulerRunning.4_26 ={v} xSchedulerRunning;
  if (xSchedulerRunning.4_26 == 0)
    goto <bb 20>;
  else
    goto <bb 19>;

  <bb 19>:
  pretmp_65 = pxNewTCB_12->uxPriority;
  goto <bb 22>;

  <bb 20>:
  pxCurrentTCB.5_27 ={v} pxCurrentTCB;
  _28 = pxCurrentTCB.5_27->uxPriority;
  _29 = pxNewTCB_12->uxPriority;
  if (_28 <= _29)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  pxCurrentTCB ={v} pxNewTCB_12;

  <bb 22>:
  # prephitmp_64 = PHI <pretmp_41(13), pretmp_21(17), pretmp_65(19), _29(20), _29(21)>
  uxTaskNumber.6_30 = uxTaskNumber;
  _31 = uxTaskNumber.6_30 + 1;
  uxTaskNumber = _31;
  pxNewTCB_12->uxTCBNumber = _31;
  uxTopReadyPriority.7_33 ={v} uxTopReadyPriority;
  if (uxTopReadyPriority.7_33 < prephitmp_64)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  uxTopReadyPriority ={v} prephitmp_64;

  <bb 24>:
  _124 = prephitmp_64 * 20;
  _34 = &pxReadyTasksLists + _124;
  vListInsertEnd (_34, _55);
  vPortExitCritical ();
  xSchedulerRunning.8_36 ={v} xSchedulerRunning;
  if (xSchedulerRunning.8_36 != 0)
    goto <bb 25>;
  else
    goto <bb 27>;

  <bb 25>:
  pxCurrentTCB.9_37 ={v} pxCurrentTCB;
  _38 = pxCurrentTCB.9_37->uxPriority;
  _39 = pxNewTCB_12->uxPriority;
  if (_38 < _39)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 26>:
  __asm__ __volatile__("SWI 0" :  :  : "memory");

  <bb 27>:
  # xReturn_2 = PHI <-1(2), -1(5), 1(25), 1(26), 1(24)>
  return xReturn_2;

}



;; Function xTaskIncrementTick (xTaskIncrementTick, funcdef_no=27, decl_uid=6908, cgraph_uid=27, symbol_order=51)


Analyzing loop at ../src/FreeRTOS/tasks.c:2683
../src/FreeRTOS/tasks.c:2683:9: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:2683:9: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:2683:9: note: not vectorized: control flow in loop.
../src/FreeRTOS/tasks.c:2683:9: note: bad loop form.
../src/FreeRTOS/tasks.c:2646:12: note: vectorized 0 loops in function.
xTaskIncrementTick ()
{
  struct TCB_t * pxTCB;
  struct List_t * pxTemp;
  const TickType_t xConstTickCount;
  BaseType_t xSwitchRequired;
  TickType_t xItemValue;
  struct TCB_t * pxTCB;
  long unsigned int uxSchedulerSuspended.74_14;
  long unsigned int xTickCount.75_15;
  struct List_t * pxDelayedTaskList.76_18;
  long unsigned int _19;
  struct List_t * pxOverflowDelayedTaskList.77_22;
  long int xNumOfOverflows.78_25;
  long int _26;
  long unsigned int xNextTaskUnblockTime.79_28;
  struct List_t * pxDelayedTaskList.81_29;
  long unsigned int _30;
  struct List_t * pxDelayedTaskList.82_31;
  struct xLIST_ITEM * _32;
  struct ListItem_t * _35;
  void * _37;
  struct ListItem_t * _38;
  long unsigned int _40;
  long unsigned int uxTopReadyPriority.83_41;
  struct List_t * _44;
  long unsigned int _47;
  struct TCB_t * pxCurrentTCB.84_48;
  long unsigned int _49;
  struct TCB_t * pxCurrentTCB.85_52;
  long unsigned int _53;
  long unsigned int _54;
  long unsigned int uxPendedTicks.86_55;
  long unsigned int _56;
  long int xYieldPending.87_58;
  struct List_t * pxDelayedTaskList.19_59;
  long unsigned int _60;
  sizetype _62;
  struct List_t * pxDelayedTaskList.20_64;
  struct xLIST_ITEM * _65;
  long unsigned int _67;

  <bb 2>:
  uxSchedulerSuspended.74_14 ={v} uxSchedulerSuspended;
  if (uxSchedulerSuspended.74_14 == 0)
    goto <bb 3>;
  else
    goto <bb 22>;

  <bb 3>:
  xTickCount.75_15 ={v} xTickCount;
  xConstTickCount_16 = xTickCount.75_15 + 1;
  xTickCount ={v} xConstTickCount_16;
  if (xConstTickCount_16 == 0)
    goto <bb 4>;
  else
    goto <bb 7>;

  <bb 4>:
  pxDelayedTaskList.76_18 ={v} pxDelayedTaskList;
  _19 ={v} pxDelayedTaskList.76_18->uxNumberOfItems;
  if (_19 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  R_OS_AssertCalled ("../src/FreeRTOS/tasks.c", 2668);

  <bb 6>:
  pxTemp_21 ={v} pxDelayedTaskList;
  pxOverflowDelayedTaskList.77_22 ={v} pxOverflowDelayedTaskList;
  pxDelayedTaskList ={v} pxOverflowDelayedTaskList.77_22;
  pxOverflowDelayedTaskList ={v} pxTemp_21;
  xNumOfOverflows.78_25 ={v} xNumOfOverflows;
  _26 = xNumOfOverflows.78_25 + 1;
  xNumOfOverflows ={v} _26;
  pxDelayedTaskList.19_59 ={v} pxDelayedTaskList;
  _60 ={v} pxDelayedTaskList.19_59->uxNumberOfItems;
  if (_60 == 0)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 7>:
  xNextTaskUnblockTime.79_28 ={v} xNextTaskUnblockTime;
  if (xConstTickCount_16 >= xNextTaskUnblockTime.79_28)
    goto <bb 8>;
  else
    goto <bb 20>;

  <bb 8>:
  goto <bb 11>;

  <bb 9>:

  <bb 10>:
  # xSwitchRequired_82 = PHI <xSwitchRequired_1(9), 1(19)>

  <bb 11>:
  # xSwitchRequired_1 = PHI <0(8), xSwitchRequired_82(10)>
  pxDelayedTaskList.81_29 ={v} pxDelayedTaskList;
  _30 ={v} pxDelayedTaskList.81_29->uxNumberOfItems;
  if (_30 == 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  # xSwitchRequired_83 = PHI <xSwitchRequired_1(11)>
  xNextTaskUnblockTime ={v} 4294967295;
  goto <bb 20>;

  <bb 13>:
  pxDelayedTaskList.82_31 ={v} pxDelayedTaskList;
  _32 = pxDelayedTaskList.82_31->xListEnd.pxNext;
  pxTCB_33 = _32->pvOwner;
  xItemValue_34 = pxTCB_33->xStateListItem.xItemValue;
  if (xConstTickCount_16 < xItemValue_34)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  # xSwitchRequired_81 = PHI <xSwitchRequired_1(13)>
  # xItemValue_72 = PHI <xItemValue_34(13)>
  xNextTaskUnblockTime ={v} xItemValue_72;
  goto <bb 20>;

  <bb 15>:
  _35 = &pxTCB_33->xStateListItem;
  uxListRemove (_35);
  _37 = pxTCB_33->xEventListItem.pvContainer;
  if (_37 != 0B)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  _38 = &pxTCB_33->xEventListItem;
  uxListRemove (_38);

  <bb 17>:
  _40 = pxTCB_33->uxPriority;
  uxTopReadyPriority.83_41 ={v} uxTopReadyPriority;
  if (_40 > uxTopReadyPriority.83_41)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  uxTopReadyPriority ={v} _40;

  <bb 19>:
  _62 = _40 * 20;
  _44 = &pxReadyTasksLists + _62;
  vListInsertEnd (_44, _35);
  _47 = pxTCB_33->uxPriority;
  pxCurrentTCB.84_48 ={v} pxCurrentTCB;
  _49 = pxCurrentTCB.84_48->uxPriority;
  if (_47 >= _49)
    goto <bb 10>;
  else
    goto <bb 9>;

  <bb 20>:
  # xSwitchRequired_2 = PHI <0(7), xSwitchRequired_83(12), xSwitchRequired_81(14)>
  pxCurrentTCB.85_52 ={v} pxCurrentTCB;
  _53 = pxCurrentTCB.85_52->uxPriority;
  _54 ={v} pxReadyTasksLists[_53].uxNumberOfItems;
  if (_54 > 1)
    goto <bb 23>;
  else
    goto <bb 21>;

  <bb 21>:
  goto <bb 23>;

  <bb 22>:
  uxPendedTicks.86_55 ={v} uxPendedTicks;
  _56 = uxPendedTicks.86_55 + 1;
  uxPendedTicks ={v} _56;

  <bb 23>:
  # xSwitchRequired_3 = PHI <1(20), 0(22), xSwitchRequired_2(21)>
  xYieldPending.87_58 ={v} xYieldPending;
  if (xYieldPending.87_58 != 0)
    goto <bb 25>;
  else
    goto <bb 24>;

  <bb 24>:

  <bb 25>:
  # xSwitchRequired_4 = PHI <xSwitchRequired_3(24), 1(23)>
  return xSwitchRequired_4;

  <bb 26>:
  xNextTaskUnblockTime ={v} 4294967295;
  goto <bb 7>;

  <bb 27>:
  pxDelayedTaskList.20_64 ={v} pxDelayedTaskList;
  _65 = pxDelayedTaskList.20_64->xListEnd.pxNext;
  pxTCB_66 = _65->pvOwner;
  _67 = pxTCB_66->xStateListItem.xItemValue;
  xNextTaskUnblockTime ={v} _67;
  goto <bb 7>;

}



;; Function xTaskResumeAll (xTaskResumeAll, funcdef_no=18, decl_uid=6846, cgraph_uid=18, symbol_order=42)


Analyzing loop at ../src/FreeRTOS/tasks.c:2190
../src/FreeRTOS/tasks.c:2190:7: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:2190:7: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:2190:7: note: not vectorized: control flow in loop.
../src/FreeRTOS/tasks.c:2190:7: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/tasks.c:2140
../src/FreeRTOS/tasks.c:2140:10: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:2140:10: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:2140:10: note: not vectorized: control flow in loop.
../src/FreeRTOS/tasks.c:2140:10: note: bad loop form.
../src/FreeRTOS/tasks.c:2116:12: note: vectorized 0 loops in function.
xTaskResumeAll ()
{
  struct TCB_t * pxTCB;
  UBaseType_t uxPendedCounts;
  BaseType_t xAlreadyYielded;
  struct TCB_t * pxTCB;
  long unsigned int uxSchedulerSuspended.61_14;
  long unsigned int uxSchedulerSuspended.62_17;
  long unsigned int _18;
  long unsigned int uxSchedulerSuspended.63_20;
  long unsigned int uxCurrentNumberOfTasks.64_21;
  long unsigned int _22;
  struct xLIST_ITEM * _23;
  struct ListItem_t * _25;
  struct ListItem_t * _27;
  long unsigned int _29;
  long unsigned int uxTopReadyPriority.65_30;
  struct List_t * _34;
  long unsigned int _37;
  struct TCB_t * pxCurrentTCB.66_38;
  long unsigned int _39;
  long int _43;
  long int xYieldPending.67_47;
  struct List_t * pxDelayedTaskList.19_50;
  long unsigned int _51;
  struct List_t * pxDelayedTaskList.20_55;
  struct xLIST_ITEM * _56;
  long unsigned int _58;
  sizetype _67;

  <bb 2>:
  uxSchedulerSuspended.61_14 ={v} uxSchedulerSuspended;
  if (uxSchedulerSuspended.61_14 == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  R_OS_AssertCalled ("../src/FreeRTOS/tasks.c", 2123);

  <bb 4>:
  vPortEnterCritical ();
  uxSchedulerSuspended.62_17 ={v} uxSchedulerSuspended;
  _18 = uxSchedulerSuspended.62_17 + 4294967295;
  uxSchedulerSuspended ={v} _18;
  uxSchedulerSuspended.63_20 ={v} uxSchedulerSuspended;
  if (uxSchedulerSuspended.63_20 == 0)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  goto <bb 25>;

  <bb 6>:
  uxCurrentNumberOfTasks.64_21 ={v} uxCurrentNumberOfTasks;
  if (uxCurrentNumberOfTasks.64_21 != 0)
    goto <bb 7>;
  else
    goto <bb 5>;

  <bb 7>:
  goto <bb 13>;

  <bb 8>:
  _23 = xPendingReadyList.xListEnd.pxNext;
  pxTCB_24 = _23->pvOwner;
  _25 = &pxTCB_24->xEventListItem;
  uxListRemove (_25);
  _27 = &pxTCB_24->xStateListItem;
  uxListRemove (_27);
  _29 = pxTCB_24->uxPriority;
  uxTopReadyPriority.65_30 ={v} uxTopReadyPriority;
  if (_29 > uxTopReadyPriority.65_30)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  uxTopReadyPriority ={v} _29;

  <bb 10>:
  _67 = _29 * 20;
  _34 = &pxReadyTasksLists + _67;
  vListInsertEnd (_34, _27);
  _37 = pxTCB_24->uxPriority;
  pxCurrentTCB.66_38 ={v} pxCurrentTCB;
  _39 = pxCurrentTCB.66_38->uxPriority;
  if (_37 >= _39)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  xYieldPending ={v} 1;

  <bb 12>:

  <bb 13>:
  # pxTCB_1 = PHI <0B(7), pxTCB_24(12)>
  _22 ={v} xPendingReadyList.uxNumberOfItems;
  if (_22 != 0)
    goto <bb 8>;
  else
    goto <bb 14>;

  <bb 14>:
  # pxTCB_68 = PHI <pxTCB_1(13)>
  if (pxTCB_68 != 0B)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  pxDelayedTaskList.19_50 ={v} pxDelayedTaskList;
  _51 ={v} pxDelayedTaskList.19_50->uxNumberOfItems;
  if (_51 == 0)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 16>:
  uxPendedCounts_41 ={v} uxPendedTicks;
  if (uxPendedCounts_41 != 0)
    goto <bb 17>;
  else
    goto <bb 23>;

  <bb 17>:

  <bb 18>:
  # uxPendedCounts_3 = PHI <uxPendedCounts_41(17), uxPendedCounts_45(21)>
  _43 = xTaskIncrementTick ();
  if (_43 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  xYieldPending ={v} 1;

  <bb 20>:
  uxPendedCounts_45 = uxPendedCounts_3 + 4294967295;
  if (uxPendedCounts_45 != 0)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  goto <bb 18>;

  <bb 22>:
  uxPendedTicks ={v} 0;

  <bb 23>:
  xYieldPending.67_47 ={v} xYieldPending;
  if (xYieldPending.67_47 != 0)
    goto <bb 24>;
  else
    goto <bb 5>;

  <bb 24>:
  __asm__ __volatile__("SWI 0" :  :  : "memory");

  <bb 25>:
  # xAlreadyYielded_2 = PHI <0(5), 1(24)>
  vPortExitCritical ();
  return xAlreadyYielded_2;

  <bb 26>:
  xNextTaskUnblockTime ={v} 4294967295;
  goto <bb 16>;

  <bb 27>:
  pxDelayedTaskList.20_55 ={v} pxDelayedTaskList;
  _56 = pxDelayedTaskList.20_55->xListEnd.pxNext;
  pxTCB_57 = _56->pvOwner;
  _58 = pxTCB_57->xStateListItem.xItemValue;
  xNextTaskUnblockTime ={v} _58;
  goto <bb 16>;

}



;; Function uxTaskGetSystemState (uxTaskGetSystemState, funcdef_no=25, decl_uid=6878, cgraph_uid=25, symbol_order=49)


Analyzing loop at ../src/FreeRTOS/tasks.c:3684
../src/FreeRTOS/tasks.c:3684:4: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:3684:4: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:3684:4: note: not vectorized: control flow in loop.
../src/FreeRTOS/tasks.c:3684:4: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/tasks.c:3703
../src/FreeRTOS/tasks.c:3703:8: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:3703:8: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:3703:8: note: === get_loop_niters ===
../src/FreeRTOS/tasks.c:3703:8: note: not vectorized: number of iterations cannot be computed.
../src/FreeRTOS/tasks.c:3703:8: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/tasks.c:3684
../src/FreeRTOS/tasks.c:3684:4: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:3684:4: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:3684:4: note: not vectorized: control flow in loop.
../src/FreeRTOS/tasks.c:3684:4: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/tasks.c:3703
../src/FreeRTOS/tasks.c:3703:8: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:3703:8: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:3703:8: note: === get_loop_niters ===
../src/FreeRTOS/tasks.c:3703:8: note: not vectorized: number of iterations cannot be computed.
../src/FreeRTOS/tasks.c:3703:8: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/tasks.c:3684
../src/FreeRTOS/tasks.c:3684:4: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:3684:4: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:3684:4: note: not vectorized: control flow in loop.
../src/FreeRTOS/tasks.c:3684:4: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/tasks.c:3703
../src/FreeRTOS/tasks.c:3703:8: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:3703:8: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:3703:8: note: === get_loop_niters ===
../src/FreeRTOS/tasks.c:3703:8: note: not vectorized: number of iterations cannot be computed.
../src/FreeRTOS/tasks.c:3703:8: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/tasks.c:3684
../src/FreeRTOS/tasks.c:3684:4: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:3684:4: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:3684:4: note: not vectorized: control flow in loop.
../src/FreeRTOS/tasks.c:3684:4: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/tasks.c:3703
../src/FreeRTOS/tasks.c:3703:8: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:3703:8: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:3703:8: note: === get_loop_niters ===
../src/FreeRTOS/tasks.c:3703:8: note: not vectorized: number of iterations cannot be computed.
../src/FreeRTOS/tasks.c:3703:8: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/tasks.c:2482
../src/FreeRTOS/tasks.c:2482:5: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:2482:5: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:2482:5: note: not vectorized: multiple nested loops.
../src/FreeRTOS/tasks.c:2482:5: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/tasks.c:3684
../src/FreeRTOS/tasks.c:3684:4: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:3684:4: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:3684:4: note: not vectorized: control flow in loop.
../src/FreeRTOS/tasks.c:3684:4: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/tasks.c:3703
../src/FreeRTOS/tasks.c:3703:8: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:3703:8: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:3703:8: note: === get_loop_niters ===
../src/FreeRTOS/tasks.c:3703:8: note: not vectorized: number of iterations cannot be computed.
../src/FreeRTOS/tasks.c:3703:8: note: bad loop form.
../src/FreeRTOS/tasks.c:2466:14: note: vectorized 0 loops in function.
uxTaskGetSystemState (struct TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime)
{
  uint32_t ulCount;
  const uint8_t * pucStackByte;
  UBaseType_t uxTask;
  struct TCB_t * pxFirstTCB;
  struct TCB_t * pxNextTCB;
  UBaseType_t D.9920;
  uint32_t ulCount;
  const uint8_t * pucStackByte;
  UBaseType_t uxTask;
  struct TCB_t * pxFirstTCB;
  struct TCB_t * pxNextTCB;
  UBaseType_t D.9901;
  uint32_t ulCount;
  const uint8_t * pucStackByte;
  UBaseType_t uxTask;
  struct TCB_t * pxFirstTCB;
  struct TCB_t * pxNextTCB;
  UBaseType_t D.9882;
  uint32_t ulCount;
  const uint8_t * pucStackByte;
  UBaseType_t uxTask;
  struct TCB_t * pxFirstTCB;
  struct TCB_t * pxNextTCB;
  UBaseType_t D.9863;
  uint32_t ulCount;
  const uint8_t * pucStackByte;
  struct TCB_t * pxNextTCB;
  struct TCB_t * pxFirstTCB;
  UBaseType_t uxTask;
  UBaseType_t D.9847;
  UBaseType_t uxTask;
  UBaseType_t uxTask;
  UBaseType_t uxTask;
  UBaseType_t uxTask;
  UBaseType_t uxTask;
  UBaseType_t uxQueue;
  UBaseType_t uxTask;
  <unnamed type> _7;
  long unsigned int uxCurrentNumberOfTasks.69_9;
  long unsigned int _12;
  <unnamed type> cstore_14;
  <unnamed type> cstore_15;
  long unsigned int _17;
  <unnamed type> cstore_18;
  struct List_t * pxDelayedTaskList.70_19;
  long unsigned int _21;
  struct List_t * pxOverflowDelayedTaskList.71_23;
  long unsigned int _25;
  long unsigned int _28;
  long unsigned int _33;
  long unsigned int uxSchedulerSuspended.60_36;
  long unsigned int _37;
  long unsigned int _38;
  long unsigned int _39;
  long unsigned int _41;
  long unsigned int _44;
  long unsigned int _47;
  long unsigned int _50;
  long unsigned int _51;
  struct ListItem_t * _64;
  struct xLIST_ITEM * _65;
  struct MiniListItem_t * _66;
  struct xLIST_ITEM * _67;
  struct xLIST_ITEM * _71;
  struct xLIST_ITEM * _72;
  long unsigned int _76;
  struct TaskStatus_t * _77;
  _Bool _79;
  struct TCB_t * iftmp.115_80;
  struct TCB_t * iftmp.115_81;
  char * _82;
  long unsigned int _83;
  StackType_t * _84;
  long unsigned int _85;
  long unsigned int _86;
  long unsigned int _87;
  struct TCB_t * pxCurrentTCB.116_88;
  unsigned char _91;
  unsigned char _98;
  struct ListItem_t * _102;
  struct xLIST_ITEM * _103;
  struct MiniListItem_t * _104;
  struct xLIST_ITEM * _105;
  struct xLIST_ITEM * _109;
  struct xLIST_ITEM * _110;
  long unsigned int _114;
  struct TaskStatus_t * _115;
  long unsigned int _117;
  struct TCB_t * iftmp.115_118;
  struct TCB_t * iftmp.115_119;
  char * _120;
  long unsigned int _121;
  StackType_t * _122;
  long unsigned int _123;
  long unsigned int _124;
  long unsigned int _125;
  struct TCB_t * pxCurrentTCB.116_126;
  long unsigned int ivtmp_127;
  unsigned char _136;
  long unsigned int ivtmp_139;
  struct ListItem_t * _145;
  struct xLIST_ITEM * _146;
  struct MiniListItem_t * _147;
  struct xLIST_ITEM * _148;
  struct xLIST_ITEM * _152;
  struct xLIST_ITEM * _153;
  long unsigned int _157;
  struct TaskStatus_t * _158;
  struct TCB_t * iftmp.115_161;
  struct TCB_t * iftmp.115_162;
  char * _163;
  long unsigned int _164;
  StackType_t * _165;
  long unsigned int _166;
  long unsigned int _167;
  long unsigned int _168;
  struct TCB_t * pxCurrentTCB.116_169;
  unsigned char _174;
  sizetype _175;
  sizetype _177;
  unsigned char _179;
  struct ListItem_t * _188;
  struct xLIST_ITEM * _189;
  struct xLIST_ITEM * _191;
  struct xLIST_ITEM * _195;
  struct xLIST_ITEM * _196;
  long unsigned int _200;
  struct TaskStatus_t * _201;
  struct TCB_t * iftmp.115_204;
  struct TCB_t * iftmp.115_205;
  char * _206;
  long unsigned int _207;
  StackType_t * _208;
  long unsigned int _209;
  long unsigned int _210;
  long unsigned int _211;
  struct TCB_t * pxCurrentTCB.116_212;
  unsigned char _222;
  struct ListItem_t * _231;
  struct xLIST_ITEM * _232;
  struct xLIST_ITEM * _234;
  struct xLIST_ITEM * _238;
  struct xLIST_ITEM * _239;
  long unsigned int _243;
  struct TaskStatus_t * _244;
  struct TCB_t * iftmp.115_247;
  struct TCB_t * iftmp.115_248;
  char * _249;
  long unsigned int _250;
  StackType_t * _251;
  long unsigned int _252;
  long unsigned int _253;
  long unsigned int _254;
  struct TCB_t * pxCurrentTCB.116_255;
  long unsigned int uxSchedulerSuspended.60_256;
  long unsigned int _257;
  void * _258;
  unsigned char _265;
  long unsigned int _309;
  unsigned char _321;
  long unsigned int _324;
  unsigned char _337;
  unsigned char _339;
  struct ListItem_t * prephitmp_418;
  struct ListItem_t * pretmp_419;
  struct ListItem_t * prephitmp_420;
  struct ListItem_t * prephitmp_424;
  StackType_t * pretmp_426;
  StackType_t * prephitmp_427;
  long unsigned int _430;
  short unsigned int _432;
  short unsigned int prephitmp_433;
  struct ListItem_t * prephitmp_434;
  struct ListItem_t * prephitmp_435;
  struct ListItem_t * prephitmp_439;
  long unsigned int _443;
  short unsigned int _445;
  short unsigned int prephitmp_446;
  struct ListItem_t * prephitmp_447;
  struct ListItem_t * prephitmp_448;
  struct ListItem_t * prephitmp_452;
  long unsigned int _456;
  short unsigned int _458;
  short unsigned int prephitmp_459;
  struct ListItem_t * prephitmp_460;
  struct ListItem_t * prephitmp_461;
  struct ListItem_t * prephitmp_465;
  long unsigned int _469;
  short unsigned int _471;
  short unsigned int prephitmp_472;
  struct ListItem_t * prephitmp_473;
  struct ListItem_t * prephitmp_474;
  struct ListItem_t * prephitmp_478;
  long unsigned int _483;
  short unsigned int _485;
  short unsigned int prephitmp_486;

  <bb 2>:
  uxSchedulerSuspended.60_36 ={v} uxSchedulerSuspended;
  _37 = uxSchedulerSuspended.60_36 + 1;
  uxSchedulerSuspended ={v} _37;
  uxCurrentNumberOfTasks.69_9 ={v} uxCurrentNumberOfTasks;
  if (uxCurrentNumberOfTasks.69_9 <= uxArraySize_10(D))
    goto <bb 3>;
  else
    goto <bb 99>;

  <bb 3>:

  <bb 4>:
  # uxTask_1 = PHI <0(3), uxTask_16(21)>
  # uxQueue_3 = PHI <20(3), uxQueue_11(21)>
  # ivtmp_127 = PHI <20(3), ivtmp_139(21)>
  uxQueue_11 = uxQueue_3 + 4294967295;
  _38 ={v} MEM[(struct List_t *)&pxReadyTasksLists][uxQueue_11].uxNumberOfItems;
  if (_38 != 0)
    goto <bb 5>;
  else
    goto <bb 20>;

  <bb 5>:
  _64 = MEM[(struct List_t *)&pxReadyTasksLists][uxQueue_11].pxIndex;
  _65 = _64->pxNext;
  MEM[(struct List_t *)&pxReadyTasksLists][uxQueue_11].pxIndex = _65;
  _175 = uxQueue_11 * 20;
  _177 = _175 + 8;
  _66 = &pxReadyTasksLists + _177;
  if (_65 == _66)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _67 = MEM[(struct ListItem_t *)_66].pxNext;
  MEM[(struct List_t *)&pxReadyTasksLists][uxQueue_11].pxIndex = _67;

  <bb 7>:
  # prephitmp_473 = PHI <_65(5), _67(6)>
  pxFirstTCB_69 = prephitmp_473->pvOwner;
  _12 = uxTask_1 * 36;

  <bb 8>:
  # uxTask_75 = PHI <0(7), uxTask_78(19)>
  # prephitmp_474 = PHI <prephitmp_473(7), prephitmp_478(19)>
  _71 = prephitmp_474->pxNext;
  MEM[(struct List_t *)&pxReadyTasksLists][uxQueue_11].pxIndex = _71;
  if (_66 == _71)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _72 = MEM[(struct ListItem_t *)_66].pxNext;
  MEM[(struct List_t *)&pxReadyTasksLists][uxQueue_11].pxIndex = _72;

  <bb 10>:
  # prephitmp_478 = PHI <_71(8), _72(9)>
  pxNextTCB_74 = prephitmp_478->pvOwner;
  _76 = uxTask_75 * 36;
  _309 = _12 + _76;
  _77 = pxTaskStatusArray_13(D) + _309;
  if (pxNextTCB_74 == 0B)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  iftmp.115_80 ={v} pxCurrentTCB;

  <bb 12>:
  # iftmp.115_81 = PHI <pxNextTCB_74(10), iftmp.115_80(11)>
  _77->xHandle = iftmp.115_81;
  _82 = &iftmp.115_81->pcTaskName[0];
  _77->pcTaskName = _82;
  _83 = iftmp.115_81->uxPriority;
  _77->uxCurrentPriority = _83;
  _84 = iftmp.115_81->pxStack;
  _77->pxStackBase = _84;
  _85 = iftmp.115_81->uxTCBNumber;
  _77->xTaskNumber = _85;
  _86 = iftmp.115_81->uxBasePriority;
  _77->uxBasePriority = _86;
  _87 = iftmp.115_81->ulRunTimeCounter;
  _77->ulRunTimeCounter = _87;
  pxCurrentTCB.116_88 ={v} pxCurrentTCB;
  _79 = iftmp.115_81 != pxCurrentTCB.116_88;
  _7 = (<unnamed type>) _79;
  _77->eCurrentState = _7;
  _91 = MEM[(const uint8_t *)_84];
  if (_91 == 165)
    goto <bb 13>;
  else
    goto <bb 17>;

  <bb 13>:

  <bb 14>:
  # pucStackByte_62 = PHI <_84(13), pucStackByte_95(15)>
  # ulCount_63 = PHI <0(13), ulCount_97(15)>
  pucStackByte_95 = pucStackByte_62 + 1;
  ulCount_97 = ulCount_63 + 1;
  _98 = *pucStackByte_95;
  if (_98 == 165)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  goto <bb 14>;

  <bb 16>:
  # ulCount_423 = PHI <ulCount_97(14)>
  _483 = ulCount_423 >> 2;
  _485 = (short unsigned int) _483;

  <bb 17>:
  # prephitmp_486 = PHI <_485(16), 0(12)>
  _77->usStackHighWaterMark = prephitmp_486;
  uxTask_78 = uxTask_75 + 1;
  if (pxFirstTCB_69 != pxNextTCB_74)
    goto <bb 19>;
  else
    goto <bb 18>;

  <bb 18>:
  # uxTask_425 = PHI <uxTask_78(17)>
  goto <bb 20>;

  <bb 19>:
  goto <bb 8>;

  <bb 20>:
  # uxTask_40 = PHI <0(4), uxTask_425(18)>
  uxTask_16 = uxTask_1 + uxTask_40;
  ivtmp_139 = ivtmp_127 - 1;
  if (ivtmp_139 != 0)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  goto <bb 4>;

  <bb 22>:
  # uxTask_429 = PHI <uxTask_16(20)>
  pxDelayedTaskList.70_19 ={v} pxDelayedTaskList;
  _50 ={v} pxDelayedTaskList.70_19->uxNumberOfItems;
  if (_50 != 0)
    goto <bb 23>;
  else
    goto <bb 40>;

  <bb 23>:
  _102 = pxDelayedTaskList.70_19->pxIndex;
  _103 = _102->pxNext;
  pxDelayedTaskList.70_19->pxIndex = _103;
  _104 = &pxDelayedTaskList.70_19->xListEnd;
  if (_103 == _104)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  _105 = MEM[(struct ListItem_t *)pxDelayedTaskList.70_19 + 8B].pxNext;
  pxDelayedTaskList.70_19->pxIndex = _105;

  <bb 25>:
  # prephitmp_460 = PHI <_103(23), _105(24)>
  pxFirstTCB_107 = prephitmp_460->pvOwner;
  _17 = uxTask_429 * 36;

  <bb 26>:
  # uxTask_113 = PHI <0(25), uxTask_116(39)>
  # prephitmp_461 = PHI <prephitmp_460(25), prephitmp_465(39)>
  _109 = prephitmp_461->pxNext;
  pxDelayedTaskList.70_19->pxIndex = _109;
  if (_104 == _109)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  _110 = MEM[(struct ListItem_t *)pxDelayedTaskList.70_19 + 8B].pxNext;
  pxDelayedTaskList.70_19->pxIndex = _110;

  <bb 28>:
  # prephitmp_465 = PHI <_109(26), _110(27)>
  pxNextTCB_112 = prephitmp_465->pvOwner;
  _114 = uxTask_113 * 36;
  _39 = _17 + _114;
  _115 = pxTaskStatusArray_13(D) + _39;
  if (pxNextTCB_112 == 0B)
    goto <bb 29>;
  else
    goto <bb 30>;

  <bb 29>:
  iftmp.115_118 ={v} pxCurrentTCB;

  <bb 30>:
  # iftmp.115_119 = PHI <pxNextTCB_112(28), iftmp.115_118(29)>
  _115->xHandle = iftmp.115_119;
  _120 = &iftmp.115_119->pcTaskName[0];
  _115->pcTaskName = _120;
  _121 = iftmp.115_119->uxPriority;
  _115->uxCurrentPriority = _121;
  _122 = iftmp.115_119->pxStack;
  _115->pxStackBase = _122;
  _123 = iftmp.115_119->uxTCBNumber;
  _115->xTaskNumber = _123;
  _124 = iftmp.115_119->uxBasePriority;
  _115->uxBasePriority = _124;
  _125 = iftmp.115_119->ulRunTimeCounter;
  _115->ulRunTimeCounter = _125;
  pxCurrentTCB.116_126 ={v} pxCurrentTCB;
  if (iftmp.115_119 == pxCurrentTCB.116_126)
    goto <bb 32>;
  else
    goto <bb 31>;

  <bb 31>:

  <bb 32>:
  # cstore_18 = PHI <2(31), 0(30)>
  _115->eCurrentState = cstore_18;
  _337 = MEM[(const uint8_t *)_122];
  if (_337 == 165)
    goto <bb 33>;
  else
    goto <bb 37>;

  <bb 33>:

  <bb 34>:
  # pucStackByte_90 = PHI <_122(33), pucStackByte_133(35)>
  # ulCount_143 = PHI <0(33), ulCount_135(35)>
  pucStackByte_133 = pucStackByte_90 + 1;
  ulCount_135 = ulCount_143 + 1;
  _136 = *pucStackByte_133;
  if (_136 == 165)
    goto <bb 35>;
  else
    goto <bb 36>;

  <bb 35>:
  goto <bb 34>;

  <bb 36>:
  # ulCount_416 = PHI <ulCount_135(34)>
  _469 = ulCount_416 >> 2;
  _471 = (short unsigned int) _469;

  <bb 37>:
  # prephitmp_472 = PHI <_471(36), 0(32)>
  _115->usStackHighWaterMark = prephitmp_472;
  uxTask_116 = uxTask_113 + 1;
  if (pxFirstTCB_107 != pxNextTCB_112)
    goto <bb 39>;
  else
    goto <bb 38>;

  <bb 38>:
  # uxTask_417 = PHI <uxTask_116(37)>
  goto <bb 40>;

  <bb 39>:
  goto <bb 26>;

  <bb 40>:
  # uxTask_52 = PHI <0(22), uxTask_417(38)>
  uxTask_20 = uxTask_429 + uxTask_52;
  pxOverflowDelayedTaskList.71_23 ={v} pxOverflowDelayedTaskList;
  _47 ={v} pxOverflowDelayedTaskList.71_23->uxNumberOfItems;
  if (_47 != 0)
    goto <bb 41>;
  else
    goto <bb 58>;

  <bb 41>:
  _145 = pxOverflowDelayedTaskList.71_23->pxIndex;
  _146 = _145->pxNext;
  pxOverflowDelayedTaskList.71_23->pxIndex = _146;
  _147 = &pxOverflowDelayedTaskList.71_23->xListEnd;
  if (_146 == _147)
    goto <bb 42>;
  else
    goto <bb 43>;

  <bb 42>:
  _148 = MEM[(struct ListItem_t *)pxOverflowDelayedTaskList.71_23 + 8B].pxNext;
  pxOverflowDelayedTaskList.71_23->pxIndex = _148;

  <bb 43>:
  # prephitmp_447 = PHI <_146(41), _148(42)>
  pxFirstTCB_150 = prephitmp_447->pvOwner;
  _21 = uxTask_20 * 36;

  <bb 44>:
  # uxTask_156 = PHI <0(43), uxTask_159(57)>
  # prephitmp_448 = PHI <prephitmp_447(43), prephitmp_452(57)>
  _152 = prephitmp_448->pxNext;
  pxOverflowDelayedTaskList.71_23->pxIndex = _152;
  if (_147 == _152)
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 45>:
  _153 = MEM[(struct ListItem_t *)pxOverflowDelayedTaskList.71_23 + 8B].pxNext;
  pxOverflowDelayedTaskList.71_23->pxIndex = _153;

  <bb 46>:
  # prephitmp_452 = PHI <_152(44), _153(45)>
  pxNextTCB_155 = prephitmp_452->pvOwner;
  _157 = uxTask_156 * 36;
  _117 = _21 + _157;
  _158 = pxTaskStatusArray_13(D) + _117;
  if (pxNextTCB_155 == 0B)
    goto <bb 47>;
  else
    goto <bb 48>;

  <bb 47>:
  iftmp.115_161 ={v} pxCurrentTCB;

  <bb 48>:
  # iftmp.115_162 = PHI <pxNextTCB_155(46), iftmp.115_161(47)>
  _158->xHandle = iftmp.115_162;
  _163 = &iftmp.115_162->pcTaskName[0];
  _158->pcTaskName = _163;
  _164 = iftmp.115_162->uxPriority;
  _158->uxCurrentPriority = _164;
  _165 = iftmp.115_162->pxStack;
  _158->pxStackBase = _165;
  _166 = iftmp.115_162->uxTCBNumber;
  _158->xTaskNumber = _166;
  _167 = iftmp.115_162->uxBasePriority;
  _158->uxBasePriority = _167;
  _168 = iftmp.115_162->ulRunTimeCounter;
  _158->ulRunTimeCounter = _168;
  pxCurrentTCB.116_169 ={v} pxCurrentTCB;
  if (iftmp.115_162 == pxCurrentTCB.116_169)
    goto <bb 50>;
  else
    goto <bb 49>;

  <bb 49>:

  <bb 50>:
  # cstore_15 = PHI <2(49), 0(48)>
  _158->eCurrentState = cstore_15;
  _321 = MEM[(const uint8_t *)_165];
  if (_321 == 165)
    goto <bb 51>;
  else
    goto <bb 55>;

  <bb 51>:

  <bb 52>:
  # pucStackByte_142 = PHI <_165(51), pucStackByte_176(53)>
  # ulCount_141 = PHI <0(51), ulCount_178(53)>
  pucStackByte_176 = pucStackByte_142 + 1;
  ulCount_178 = ulCount_141 + 1;
  _179 = *pucStackByte_176;
  if (_179 == 165)
    goto <bb 53>;
  else
    goto <bb 54>;

  <bb 53>:
  goto <bb 52>;

  <bb 54>:
  # ulCount_414 = PHI <ulCount_178(52)>
  _456 = ulCount_414 >> 2;
  _458 = (short unsigned int) _456;

  <bb 55>:
  # prephitmp_459 = PHI <_458(54), 0(50)>
  _158->usStackHighWaterMark = prephitmp_459;
  uxTask_159 = uxTask_156 + 1;
  if (pxFirstTCB_150 != pxNextTCB_155)
    goto <bb 57>;
  else
    goto <bb 56>;

  <bb 56>:
  # uxTask_415 = PHI <uxTask_159(55)>
  goto <bb 58>;

  <bb 57>:
  goto <bb 44>;

  <bb 58>:
  # uxTask_49 = PHI <0(40), uxTask_415(56)>
  uxTask_24 = uxTask_20 + uxTask_49;
  _44 ={v} xTasksWaitingTermination.uxNumberOfItems;
  if (_44 != 0)
    goto <bb 59>;
  else
    goto <bb 76>;

  <bb 59>:
  _188 = xTasksWaitingTermination.pxIndex;
  _189 = _188->pxNext;
  xTasksWaitingTermination.pxIndex = _189;
  if (_189 == &xTasksWaitingTermination.xListEnd)
    goto <bb 60>;
  else
    goto <bb 61>;

  <bb 60>:
  _191 = MEM[(struct ListItem_t *)&xTasksWaitingTermination + 8B].pxNext;
  xTasksWaitingTermination.pxIndex = _191;

  <bb 61>:
  # prephitmp_434 = PHI <_189(59), _191(60)>
  pxFirstTCB_193 = prephitmp_434->pvOwner;
  _196 = MEM[(struct ListItem_t *)&xTasksWaitingTermination + 8B].pxNext;
  _25 = uxTask_24 * 36;

  <bb 62>:
  # uxTask_199 = PHI <0(61), uxTask_202(75)>
  # prephitmp_435 = PHI <prephitmp_434(61), prephitmp_439(75)>
  _195 = prephitmp_435->pxNext;
  xTasksWaitingTermination.pxIndex = _195;
  if (_195 == &xTasksWaitingTermination.xListEnd)
    goto <bb 63>;
  else
    goto <bb 64>;

  <bb 63>:
  xTasksWaitingTermination.pxIndex = _196;

  <bb 64>:
  # prephitmp_439 = PHI <_195(62), _196(63)>
  pxNextTCB_198 = prephitmp_439->pvOwner;
  _200 = uxTask_199 * 36;
  _324 = _25 + _200;
  _201 = pxTaskStatusArray_13(D) + _324;
  if (pxNextTCB_198 == 0B)
    goto <bb 65>;
  else
    goto <bb 66>;

  <bb 65>:
  iftmp.115_204 ={v} pxCurrentTCB;

  <bb 66>:
  # iftmp.115_205 = PHI <pxNextTCB_198(64), iftmp.115_204(65)>
  _201->xHandle = iftmp.115_205;
  _206 = &iftmp.115_205->pcTaskName[0];
  _201->pcTaskName = _206;
  _207 = iftmp.115_205->uxPriority;
  _201->uxCurrentPriority = _207;
  _208 = iftmp.115_205->pxStack;
  _201->pxStackBase = _208;
  _209 = iftmp.115_205->uxTCBNumber;
  _201->xTaskNumber = _209;
  _210 = iftmp.115_205->uxBasePriority;
  _201->uxBasePriority = _210;
  _211 = iftmp.115_205->ulRunTimeCounter;
  _201->ulRunTimeCounter = _211;
  pxCurrentTCB.116_212 ={v} pxCurrentTCB;
  if (iftmp.115_205 == pxCurrentTCB.116_212)
    goto <bb 68>;
  else
    goto <bb 67>;

  <bb 67>:

  <bb 68>:
  # cstore_14 = PHI <4(67), 0(66)>
  _201->eCurrentState = cstore_14;
  _339 = MEM[(const uint8_t *)_208];
  if (_339 == 165)
    goto <bb 69>;
  else
    goto <bb 73>;

  <bb 69>:

  <bb 70>:
  # pucStackByte_144 = PHI <_208(69), pucStackByte_219(71)>
  # ulCount_130 = PHI <0(69), ulCount_221(71)>
  pucStackByte_219 = pucStackByte_144 + 1;
  ulCount_221 = ulCount_130 + 1;
  _222 = *pucStackByte_219;
  if (_222 == 165)
    goto <bb 71>;
  else
    goto <bb 72>;

  <bb 71>:
  goto <bb 70>;

  <bb 72>:
  # ulCount_412 = PHI <ulCount_221(70)>
  _443 = ulCount_412 >> 2;
  _445 = (short unsigned int) _443;

  <bb 73>:
  # prephitmp_446 = PHI <_445(72), 0(68)>
  _201->usStackHighWaterMark = prephitmp_446;
  uxTask_202 = uxTask_199 + 1;
  if (pxFirstTCB_193 != pxNextTCB_198)
    goto <bb 75>;
  else
    goto <bb 74>;

  <bb 74>:
  # uxTask_413 = PHI <uxTask_202(73)>
  goto <bb 76>;

  <bb 75>:
  goto <bb 62>;

  <bb 76>:
  # uxTask_46 = PHI <0(58), uxTask_413(74)>
  uxTask_27 = uxTask_24 + uxTask_46;
  _41 ={v} xSuspendedTaskList.uxNumberOfItems;
  if (_41 != 0)
    goto <bb 77>;
  else
    goto <bb 97>;

  <bb 77>:
  _231 = xSuspendedTaskList.pxIndex;
  _232 = _231->pxNext;
  xSuspendedTaskList.pxIndex = _232;
  if (_232 == &xSuspendedTaskList.xListEnd)
    goto <bb 78>;
  else
    goto <bb 79>;

  <bb 78>:
  _234 = MEM[(struct ListItem_t *)&xSuspendedTaskList + 8B].pxNext;
  xSuspendedTaskList.pxIndex = _234;

  <bb 79>:
  # prephitmp_418 = PHI <_232(77), _234(78)>
  pxFirstTCB_236 = prephitmp_418->pvOwner;
  _28 = uxTask_27 * 36;

  <bb 80>:
  # uxTask_242 = PHI <0(79), uxTask_245(96)>
  # prephitmp_420 = PHI <prephitmp_418(79), pretmp_419(96)>
  _238 = prephitmp_420->pxNext;
  xSuspendedTaskList.pxIndex = _238;
  if (_238 == &xSuspendedTaskList.xListEnd)
    goto <bb 81>;
  else
    goto <bb 82>;

  <bb 81>:
  _239 = MEM[(struct ListItem_t *)&xSuspendedTaskList + 8B].pxNext;
  xSuspendedTaskList.pxIndex = _239;

  <bb 82>:
  # prephitmp_424 = PHI <_238(80), _239(81)>
  pxNextTCB_241 = prephitmp_424->pvOwner;
  _243 = uxTask_242 * 36;
  _51 = _28 + _243;
  _244 = pxTaskStatusArray_13(D) + _51;
  if (pxNextTCB_241 == 0B)
    goto <bb 83>;
  else
    goto <bb 84>;

  <bb 83>:
  iftmp.115_247 ={v} pxCurrentTCB;

  <bb 84>:
  # iftmp.115_248 = PHI <pxNextTCB_241(82), iftmp.115_247(83)>
  _244->xHandle = iftmp.115_248;
  _249 = &iftmp.115_248->pcTaskName[0];
  _244->pcTaskName = _249;
  _250 = iftmp.115_248->uxPriority;
  _244->uxCurrentPriority = _250;
  _251 = iftmp.115_248->pxStack;
  _244->pxStackBase = _251;
  _252 = iftmp.115_248->uxTCBNumber;
  _244->xTaskNumber = _252;
  _253 = iftmp.115_248->uxBasePriority;
  _244->uxBasePriority = _253;
  _254 = iftmp.115_248->ulRunTimeCounter;
  _244->ulRunTimeCounter = _254;
  pxCurrentTCB.116_255 ={v} pxCurrentTCB;
  if (iftmp.115_248 == pxCurrentTCB.116_255)
    goto <bb 85>;
  else
    goto <bb 86>;

  <bb 85>:
  _244->eCurrentState = 0;
  goto <bb 89>;

  <bb 86>:
  _244->eCurrentState = 3;
  uxSchedulerSuspended.60_256 ={v} uxSchedulerSuspended;
  _257 = uxSchedulerSuspended.60_256 + 1;
  uxSchedulerSuspended ={v} _257;
  _258 = iftmp.115_248->xEventListItem.pvContainer;
  if (_258 != 0B)
    goto <bb 87>;
  else
    goto <bb 88>;

  <bb 87>:
  _244->eCurrentState = 2;

  <bb 88>:
  xTaskResumeAll ();
  pretmp_426 = iftmp.115_248->pxStack;

  <bb 89>:
  # prephitmp_427 = PHI <pretmp_426(88), _251(85)>
  _174 = MEM[(const uint8_t *)prephitmp_427];
  if (_174 == 165)
    goto <bb 90>;
  else
    goto <bb 94>;

  <bb 90>:

  <bb 91>:
  # pucStackByte_128 = PHI <prephitmp_427(90), pucStackByte_262(92)>
  # ulCount_129 = PHI <0(90), ulCount_264(92)>
  pucStackByte_262 = pucStackByte_128 + 1;
  ulCount_264 = ulCount_129 + 1;
  _265 = *pucStackByte_262;
  if (_265 == 165)
    goto <bb 92>;
  else
    goto <bb 93>;

  <bb 92>:
  goto <bb 91>;

  <bb 93>:
  # ulCount_410 = PHI <ulCount_264(91)>
  _430 = ulCount_410 >> 2;
  _432 = (short unsigned int) _430;

  <bb 94>:
  # prephitmp_433 = PHI <_432(93), 0(89)>
  _244->usStackHighWaterMark = prephitmp_433;
  uxTask_245 = uxTask_242 + 1;
  if (pxFirstTCB_236 != pxNextTCB_241)
    goto <bb 96>;
  else
    goto <bb 95>;

  <bb 95>:
  # uxTask_411 = PHI <uxTask_245(94)>
  goto <bb 97>;

  <bb 96>:
  pretmp_419 = xSuspendedTaskList.pxIndex;
  goto <bb 80>;

  <bb 97>:
  # uxTask_43 = PHI <0(76), uxTask_411(95)>
  uxTask_30 = uxTask_27 + uxTask_43;
  if (pulTotalRunTime_31(D) != 0B)
    goto <bb 98>;
  else
    goto <bb 99>;

  <bb 98>:
  _33 = ulGetRunTimeCounterValue ();
  *pulTotalRunTime_31(D) = _33;

  <bb 99>:
  # uxTask_2 = PHI <0(2), uxTask_30(98), uxTask_30(97)>
  xTaskResumeAll ();
  return uxTask_2;

}



;; Function vTaskSwitchContext (vTaskSwitchContext, funcdef_no=28, decl_uid=6926, cgraph_uid=28, symbol_order=52)

../src/FreeRTOS/tasks.c:2908:6: note: vectorized 0 loops in function.
vTaskSwitchContext ()
{
  long unsigned int uxSchedulerSuspended.88_2;

  <bb 2>:
  uxSchedulerSuspended.88_2 ={v} uxSchedulerSuspended;
  if (uxSchedulerSuspended.88_2 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  xYieldPending ={v} 1;
  goto <bb 5>;

  <bb 4>:
  vTaskSwitchContext.part.4 ();

  <bb 5>:
  return;

}



;; Function vTaskGetInfo (vTaskGetInfo, funcdef_no=45, decl_uid=6829, cgraph_uid=45, symbol_order=69)


Analyzing loop at ../src/FreeRTOS/tasks.c:3703
../src/FreeRTOS/tasks.c:3703:8: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:3703:8: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:3703:8: note: === get_loop_niters ===
../src/FreeRTOS/tasks.c:3703:8: note: not vectorized: number of iterations cannot be computed.
../src/FreeRTOS/tasks.c:3703:8: note: bad loop form.
../src/FreeRTOS/tasks.c:3570:7: note: vectorized 0 loops in function.
vTaskGetInfo (void * xTask, struct TaskStatus_t * pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState)
{
  struct List_t * pxStateList;
  eTaskState eReturn;
  eTaskState D.10046;
  uint32_t ulCount;
  const uint8_t * pucStackByte;
  struct TCB_t * iftmp.115_1;
  struct TCB_t * iftmp.115_7;
  char * _10;
  long unsigned int _12;
  StackType_t * _14;
  long unsigned int _16;
  long unsigned int _18;
  long unsigned int _20;
  struct TCB_t * pxCurrentTCB.116_23;
  void * _25;
  short unsigned int _29;
  StackType_t * _33;
  long unsigned int uxSchedulerSuspended.60_34;
  long unsigned int _37;
  unsigned char _42;
  struct TCB_t * pxCurrentTCB.32_46;
  struct List_t * pxDelayedTaskList.33_48;
  struct List_t * pxOverflowDelayedTaskList.34_49;
  void * _50;
  _Bool _52;
  _Bool _54;
  _Bool _57;
  long unsigned int _67;
  short unsigned int prephitmp_69;
  unsigned char _71;

  <bb 2>:
  if (xTask_5(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.115_7 ={v} pxCurrentTCB;

  <bb 4>:
  # iftmp.115_1 = PHI <iftmp.115_7(3), xTask_5(D)(2)>
  pxTaskStatus_8(D)->xHandle = iftmp.115_1;
  _10 = &iftmp.115_1->pcTaskName[0];
  pxTaskStatus_8(D)->pcTaskName = _10;
  _12 = iftmp.115_1->uxPriority;
  pxTaskStatus_8(D)->uxCurrentPriority = _12;
  _14 = iftmp.115_1->pxStack;
  pxTaskStatus_8(D)->pxStackBase = _14;
  _16 = iftmp.115_1->uxTCBNumber;
  pxTaskStatus_8(D)->xTaskNumber = _16;
  _18 = iftmp.115_1->uxBasePriority;
  pxTaskStatus_8(D)->uxBasePriority = _18;
  _20 = iftmp.115_1->ulRunTimeCounter;
  pxTaskStatus_8(D)->ulRunTimeCounter = _20;
  if (eState_22(D) != 5)
    goto <bb 5>;
  else
    goto <bb 11>;

  <bb 5>:
  pxCurrentTCB.116_23 ={v} pxCurrentTCB;
  if (iftmp.115_1 == pxCurrentTCB.116_23)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  pxTaskStatus_8(D)->eCurrentState = 0;
  goto <bb 20>;

  <bb 7>:
  pxTaskStatus_8(D)->eCurrentState = eState_22(D);
  if (eState_22(D) == 3)
    goto <bb 8>;
  else
    goto <bb 20>;

  <bb 8>:
  uxSchedulerSuspended.60_34 ={v} uxSchedulerSuspended;
  _37 = uxSchedulerSuspended.60_34 + 1;
  uxSchedulerSuspended ={v} _37;
  _25 = iftmp.115_1->xEventListItem.pvContainer;
  if (_25 != 0B)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  pxTaskStatus_8(D)->eCurrentState = 2;

  <bb 10>:
  xTaskResumeAll ();
  goto <bb 20>;

  <bb 11>:
  pxCurrentTCB.32_46 ={v} pxCurrentTCB;
  if (iftmp.115_1 == pxCurrentTCB.32_46)
    goto <bb 19>;
  else
    goto <bb 12>;

  <bb 12>:
  vPortEnterCritical ();
  pxStateList_47 = MEM[(const struct TCB_t *)iftmp.115_1].xStateListItem.pvContainer;
  vPortExitCritical ();
  pxDelayedTaskList.33_48 ={v} pxDelayedTaskList;
  if (pxStateList_47 == pxDelayedTaskList.33_48)
    goto <bb 19>;
  else
    goto <bb 13>;

  <bb 13>:
  pxOverflowDelayedTaskList.34_49 ={v} pxOverflowDelayedTaskList;
  if (pxStateList_47 == pxOverflowDelayedTaskList.34_49)
    goto <bb 19>;
  else
    goto <bb 14>;

  <bb 14>:
  if (pxStateList_47 == &xSuspendedTaskList)
    goto <bb 15>;
  else
    goto <bb 17>;

  <bb 15>:
  _50 = MEM[(const struct TCB_t *)iftmp.115_1].xEventListItem.pvContainer;
  if (_50 == 0B)
    goto <bb 19>;
  else
    goto <bb 16>;

  <bb 16>:
  goto <bb 19>;

  <bb 17>:
  _57 = pxStateList_47 == 0B;
  _52 = pxStateList_47 == &xTasksWaitingTermination;
  _54 = _52 | _57;
  if (_54 != 0)
    goto <bb 19>;
  else
    goto <bb 18>;

  <bb 18>:

  <bb 19>:
  # eReturn_51 = PHI <0(11), 4(17), 1(18), 3(15), 2(12), 2(16), 2(13)>
  pxTaskStatus_8(D)->eCurrentState = eReturn_51;

  <bb 20>:
  if (xGetFreeStackSpace_32(D) != 0)
    goto <bb 21>;
  else
    goto <bb 27>;

  <bb 21>:
  _33 = iftmp.115_1->pxStack;
  _71 = MEM[(const uint8_t *)_33];
  if (_71 == 165)
    goto <bb 22>;
  else
    goto <bb 26>;

  <bb 22>:

  <bb 23>:
  # pucStackByte_72 = PHI <_33(22), pucStackByte_39(24)>
  # ulCount_73 = PHI <0(22), ulCount_41(24)>
  pucStackByte_39 = pucStackByte_72 + 1;
  ulCount_41 = ulCount_73 + 1;
  _42 = *pucStackByte_39;
  if (_42 == 165)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  goto <bb 23>;

  <bb 25>:
  # ulCount_63 = PHI <ulCount_41(23)>
  _67 = ulCount_63 >> 2;
  _29 = (short unsigned int) _67;

  <bb 26>:
  # prephitmp_69 = PHI <_29(25), 0(21)>
  pxTaskStatus_8(D)->usStackHighWaterMark = prephitmp_69;
  goto <bb 28>;

  <bb 27>:
  pxTaskStatus_8(D)->usStackHighWaterMark = 0;

  <bb 28>:
  return;

}



;; Function uxTaskGetStackHighWaterMark (uxTaskGetStackHighWaterMark, funcdef_no=48, decl_uid=6862, cgraph_uid=48, symbol_order=72)


Analyzing loop at ../src/FreeRTOS/tasks.c:3703
../src/FreeRTOS/tasks.c:3703:8: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:3703:8: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:3703:8: note: === get_loop_niters ===
../src/FreeRTOS/tasks.c:3703:8: note: not vectorized: number of iterations cannot be computed.
../src/FreeRTOS/tasks.c:3703:8: note: bad loop form.
../src/FreeRTOS/tasks.c:3719:14: note: vectorized 0 loops in function.
uxTaskGetStackHighWaterMark (void * xTask)
{
  uint32_t ulCount;
  const uint8_t * pucStackByte;
  uint8_t * pucEndOfStack;
  struct TCB_t * iftmp.117_1;
  struct TCB_t * iftmp.117_4;
  unsigned char _11;
  unsigned char _14;
  long unsigned int _22;
  long unsigned int _23;
  long unsigned int prephitmp_24;

  <bb 2>:
  if (xTask_2(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.117_4 ={v} pxCurrentTCB;

  <bb 4>:
  # iftmp.117_1 = PHI <iftmp.117_4(3), xTask_2(D)(2)>
  pucEndOfStack_6 = iftmp.117_1->pxStack;
  _14 = MEM[(const uint8_t *)pucEndOfStack_6];
  if (_14 == 165)
    goto <bb 5>;
  else
    goto <bb 9>;

  <bb 5>:

  <bb 6>:
  # pucStackByte_15 = PHI <pucEndOfStack_6(5), pucStackByte_8(7)>
  # ulCount_17 = PHI <0(5), ulCount_10(7)>
  pucStackByte_8 = pucStackByte_15 + 1;
  ulCount_10 = ulCount_17 + 1;
  _11 = *pucStackByte_8;
  if (_11 == 165)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  goto <bb 6>;

  <bb 8>:
  # ulCount_16 = PHI <ulCount_10(6)>
  _22 = ulCount_16 >> 2;
  _23 = _22 & 65535;

  <bb 9>:
  # prephitmp_24 = PHI <_23(8), 0(4)>
  return prephitmp_24;

}



;; Function vTaskList (vTaskList, funcdef_no=57, decl_uid=6880, cgraph_uid=57, symbol_order=81)


Analyzing loop at ../src/FreeRTOS/tasks.c:4279
../src/FreeRTOS/tasks.c:4279:4: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:4279:4: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:4279:4: note: not vectorized: control flow in loop.
../src/FreeRTOS/tasks.c:4279:4: note: bad loop form.
../src/FreeRTOS/tasks.c:4230:7: note: vectorized 0 loops in function.
vTaskList (char * pcWriteBuffer)
{
  size_t x;
  char * D.10076;
  char cStatus;
  volatile UBaseType_t x;
  volatile UBaseType_t uxArraySize;
  struct TaskStatus_t * pxTaskStatusArray;
  int _1;
  int prephitmp_3;
  long unsigned int uxCurrentNumberOfTasks.132_8;
  long unsigned int uxCurrentNumberOfTasks.133_10;
  long unsigned int _11;
  long unsigned int uxArraySize.134_14;
  long unsigned int uxArraySize.135_16;
  long unsigned int x.143_19;
  long unsigned int uxArraySize.144_20;
  long unsigned int x.136_21;
  long unsigned int _22;
  struct TaskStatus_t * _23;
  <unnamed type> _24;
  long unsigned int x.137_28;
  long unsigned int _29;
  struct TaskStatus_t * _30;
  const char * _31;
  char * _32;
  sizetype _34;
  long unsigned int x.138_35;
  long unsigned int _36;
  struct TaskStatus_t * _37;
  long unsigned int _38;
  long unsigned int x.139_39;
  long unsigned int _40;
  struct TaskStatus_t * _41;
  short unsigned int _42;
  unsigned int _43;
  long unsigned int x.140_44;
  long unsigned int _45;
  struct TaskStatus_t * _46;
  long unsigned int _47;
  unsigned int _49;
  long unsigned int x.141_51;
  long unsigned int x.142_52;
  char * _59;
  long unsigned int uxArraySize.144_65;
  long unsigned int x.143_66;

  <bb 2>:
  *pcWriteBuffer_6(D) = 0;
  uxCurrentNumberOfTasks.132_8 ={v} uxCurrentNumberOfTasks;
  uxArraySize ={v} uxCurrentNumberOfTasks.132_8;
  uxCurrentNumberOfTasks.133_10 ={v} uxCurrentNumberOfTasks;
  _11 = uxCurrentNumberOfTasks.133_10 * 36;
  pxTaskStatusArray_13 = pvPortMalloc (_11);
  if (pxTaskStatusArray_13 != 0B)
    goto <bb 3>;
  else
    goto <bb 14>;

  <bb 3>:
  uxArraySize.134_14 ={v} uxArraySize;
  uxArraySize.135_16 = uxTaskGetSystemState (pxTaskStatusArray_13, uxArraySize.134_14, 0B);
  uxArraySize ={v} uxArraySize.135_16;
  x ={v} 0;
  x.143_66 ={v} x;
  uxArraySize.144_65 ={v} uxArraySize;
  if (uxArraySize.144_65 > x.143_66)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  vPortFree (pxTaskStatusArray_13);
  goto <bb 14>;

  <bb 5>:

  <bb 6>:
  # pcWriteBuffer_33 = PHI <pcWriteBuffer_6(D)(5), pcWriteBuffer_50(13)>
  x.136_21 ={v} x;
  _22 = x.136_21 * 36;
  _23 = pxTaskStatusArray_13 + _22;
  _24 = _23->eCurrentState;
  if (_24 <= 4)
    goto <bb 7> (<L15>);
  else
    goto <bb 8> (<L16>);

<L15>:
  cStatus_26 = CSWTCH.244[_24];
  _1 = (int) cStatus_26;

  # prephitmp_3 = PHI <_1(7), 0(6)>
<L16>:
<L13>:
  x.137_28 ={v} x;
  _29 = x.137_28 * 36;
  _30 = pxTaskStatusArray_13 + _29;
  _31 = _30->pcTaskName;
  strcpy (pcWriteBuffer_33, _31);
  x_55 = strlen (pcWriteBuffer_33);
  if (x_55 <= 22)
    goto <bb 9>;
  else
    goto <bb 12>;

  <bb 9>:
  _34 = 23 - x_55;
  _32 = pcWriteBuffer_33 + x_55;
  __builtin_memset (_32, 32, _34);

  <bb 12>:
  # x_70 = PHI <23(9), x_55(8)>
  _59 = pcWriteBuffer_33 + x_70;
  *_59 = 0;
  x.138_35 ={v} x;
  _36 = x.138_35 * 36;
  _37 = pxTaskStatusArray_13 + _36;
  _38 = _37->uxCurrentPriority;
  x.139_39 ={v} x;
  _40 = x.139_39 * 36;
  _41 = pxTaskStatusArray_13 + _40;
  _42 = _41->usStackHighWaterMark;
  _43 = (unsigned int) _42;
  x.140_44 ={v} x;
  _45 = x.140_44 * 36;
  _46 = pxTaskStatusArray_13 + _45;
  _47 = _46->xTaskNumber;
  sprintf (_59, "\t%c\t%u\t%u\t%u\r\n", prephitmp_3, _38, _43, _47);
  _49 = strlen (_59);
  pcWriteBuffer_50 = _59 + _49;
  x.141_51 ={v} x;
  x.142_52 = x.141_51 + 1;
  x ={v} x.142_52;
  x.143_19 ={v} x;
  uxArraySize.144_20 ={v} uxArraySize;
  if (x.143_19 < uxArraySize.144_20)
    goto <bb 13>;
  else
    goto <bb 4>;

  <bb 13>:
  goto <bb 6>;

  <bb 14>:
  return;

}



;; Function vTaskGetRunTimeStats (vTaskGetRunTimeStats, funcdef_no=58, decl_uid=6882, cgraph_uid=58, symbol_order=82)


Analyzing loop at ../src/FreeRTOS/tasks.c:4389
../src/FreeRTOS/tasks.c:4389:5: note: ===== analyze_loop_nest =====
../src/FreeRTOS/tasks.c:4389:5: note: === vect_analyze_loop_form ===
../src/FreeRTOS/tasks.c:4389:5: note: not vectorized: control flow in loop.
../src/FreeRTOS/tasks.c:4389:5: note: bad loop form.
../src/FreeRTOS/tasks.c:4328:7: note: vectorized 0 loops in function.
vTaskGetRunTimeStats (char * pcWriteBuffer)
{
  size_t x;
  char * D.10083;
  uint32_t ulStatsAsPercentage;
  uint32_t ulTotalTime;
  volatile UBaseType_t x;
  volatile UBaseType_t uxArraySize;
  struct TaskStatus_t * pxTaskStatusArray;
  sizetype _1;
  char * _3;
  long unsigned int uxCurrentNumberOfTasks.145_9;
  long unsigned int uxCurrentNumberOfTasks.146_11;
  long unsigned int _12;
  long unsigned int uxArraySize.147_15;
  long unsigned int uxArraySize.148_17;
  long unsigned int ulTotalTime.149_19;
  long unsigned int ulTotalTime.150_20;
  long unsigned int x.157_23;
  long unsigned int uxArraySize.158_24;
  long unsigned int x.151_25;
  long unsigned int _26;
  struct TaskStatus_t * _27;
  long unsigned int _28;
  long unsigned int x.152_31;
  long unsigned int _32;
  struct TaskStatus_t * _33;
  const char * _34;
  long unsigned int pretmp_36;
  long unsigned int x.153_37;
  long unsigned int _38;
  struct TaskStatus_t * _39;
  long unsigned int _40;
  long unsigned int x.154_42;
  long unsigned int _43;
  struct TaskStatus_t * _44;
  long unsigned int _45;
  unsigned int _47;
  long unsigned int x.155_49;
  long unsigned int x.156_50;
  char * _58;
  long unsigned int prephitmp_66;
  long unsigned int uxArraySize.158_67;
  long unsigned int x.157_68;

  <bb 2>:
  *pcWriteBuffer_7(D) = 0;
  uxCurrentNumberOfTasks.145_9 ={v} uxCurrentNumberOfTasks;
  uxArraySize ={v} uxCurrentNumberOfTasks.145_9;
  uxCurrentNumberOfTasks.146_11 ={v} uxCurrentNumberOfTasks;
  _12 = uxCurrentNumberOfTasks.146_11 * 36;
  pxTaskStatusArray_14 = pvPortMalloc (_12);
  if (pxTaskStatusArray_14 != 0B)
    goto <bb 3>;
  else
    goto <bb 16>;

  <bb 3>:
  uxArraySize.147_15 ={v} uxArraySize;
  uxArraySize.148_17 = uxTaskGetSystemState (pxTaskStatusArray_14, uxArraySize.147_15, &ulTotalTime);
  uxArraySize ={v} uxArraySize.148_17;
  ulTotalTime.149_19 = ulTotalTime;
  ulTotalTime.150_20 = ulTotalTime.149_19 / 100;
  ulTotalTime = ulTotalTime.150_20;
  if (ulTotalTime.150_20 != 0)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  vPortFree (pxTaskStatusArray_14);
  goto <bb 16>;

  <bb 5>:
  x ={v} 0;
  x.157_68 ={v} x;
  uxArraySize.158_67 ={v} uxArraySize;
  if (uxArraySize.158_67 > x.157_68)
    goto <bb 6>;
  else
    goto <bb 4>;

  <bb 6>:

  <bb 7>:
  # pcWriteBuffer_64 = PHI <pcWriteBuffer_7(D)(6), pcWriteBuffer_48(15)>
  # prephitmp_66 = PHI <ulTotalTime.150_20(6), pretmp_36(15)>
  x.151_25 ={v} x;
  _26 = x.151_25 * 36;
  _27 = pxTaskStatusArray_14 + _26;
  _28 = _27->ulRunTimeCounter;
  ulStatsAsPercentage_30 = _28 / prephitmp_66;
  x.152_31 ={v} x;
  _32 = x.152_31 * 36;
  _33 = pxTaskStatusArray_14 + _32;
  _34 = _33->pcTaskName;
  strcpy (pcWriteBuffer_64, _34);
  x_54 = strlen (pcWriteBuffer_64);
  if (x_54 <= 22)
    goto <bb 8>;
  else
    goto <bb 11>;

  <bb 8>:
  _1 = 23 - x_54;
  _3 = pcWriteBuffer_64 + x_54;
  __builtin_memset (_3, 32, _1);

  <bb 11>:
  # x_70 = PHI <23(8), x_54(7)>
  _58 = pcWriteBuffer_64 + x_70;
  *_58 = 0;
  if (ulStatsAsPercentage_30 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  x.153_37 ={v} x;
  _38 = x.153_37 * 36;
  _39 = pxTaskStatusArray_14 + _38;
  _40 = _39->ulRunTimeCounter;
  sprintf (_58, "\t%u\t\t%u%%\r\n", _40, ulStatsAsPercentage_30);
  goto <bb 14>;

  <bb 13>:
  x.154_42 ={v} x;
  _43 = x.154_42 * 36;
  _44 = pxTaskStatusArray_14 + _43;
  _45 = _44->ulRunTimeCounter;
  sprintf (_58, "\t%u\t\t<1%%\r\n", _45);

  <bb 14>:
  _47 = strlen (_58);
  pcWriteBuffer_48 = _58 + _47;
  x.155_49 ={v} x;
  x.156_50 = x.155_49 + 1;
  x ={v} x.156_50;
  x.157_23 ={v} x;
  uxArraySize.158_24 ={v} uxArraySize;
  if (x.157_23 < uxArraySize.158_24)
    goto <bb 15>;
  else
    goto <bb 4>;

  <bb 15>:
  pretmp_36 = ulTotalTime;
  goto <bb 7>;

  <bb 16>:
  ulTotalTime ={v} {CLOBBER};
  return;

}


