
;; Function xQueueGenericSend (xQueueGenericSend, funcdef_no=10, decl_uid=6967, cgraph_uid=10, symbol_order=11)


Analyzing loop at ../src/FreeRTOS/queue.c:2234
../src/FreeRTOS/queue.c:2234:9: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2234:9: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2234:9: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2234:9: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2200
../src/FreeRTOS/queue.c:2200:10: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2200:10: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2200:10: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2200:10: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:746
../src/FreeRTOS/queue.c:746:3: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:746:3: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:746:3: note: not vectorized: multiple nested loops.
../src/FreeRTOS/queue.c:746:3: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2234
../src/FreeRTOS/queue.c:2234:9: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2234:9: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2234:9: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2234:9: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2200
../src/FreeRTOS/queue.c:2200:10: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2200:10: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2200:10: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2200:10: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2234
../src/FreeRTOS/queue.c:2234:9: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2234:9: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2234:9: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2234:9: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2200
../src/FreeRTOS/queue.c:2200:10: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2200:10: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2200:10: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2200:10: note: bad loop form.
../src/FreeRTOS/queue.c:725:12: note: vectorized 0 loops in function.
xQueueGenericSend (void * xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition)
{
  int8_t cTxLock;
  int8_t cRxLock;
  int8_t cTxLock;
  int8_t cRxLock;
  int8_t cTxLock;
  int8_t cRxLock;
  BaseType_t xReturn;
  UBaseType_t uxMessagesWaiting;
  BaseType_t D.8142;
  BaseType_t xReturn;
  struct TimeOut_t xTimeOut;
  BaseType_t xYieldRequired;
  BaseType_t xEntryTimeSet;
  long unsigned int _3;
  BaseType_t _6;
  long unsigned int _18;
  long unsigned int _22;
  long unsigned int _25;
  long int _28;
  long unsigned int xTicksToWait.3_29;
  long unsigned int _32;
  long unsigned int _33;
  long unsigned int xTicksToWait.3_34;
  signed char _39;
  signed char _41;
  long int _45;
  struct List_t * _47;
  long unsigned int xTicksToWait.3_48;
  long int _52;
  struct List_t * pretmp_56;
  struct List_t * pretmp_60;
  long unsigned int _61;
  struct List_t * _62;
  long int _64;
  long unsigned int _69;
  long unsigned int _70;
  long unsigned int _71;
  long unsigned int _76;
  int8_t * _77;
  int8_t * _78;
  int8_t * _80;
  int8_t * _81;
  long unsigned int _82;
  int8_t * _83;
  int8_t * _84;
  int8_t * _85;
  int8_t * _86;
  int8_t * _87;
  long unsigned int _88;
  sizetype _89;
  int8_t * _90;
  int8_t * _91;
  int8_t * _92;
  int8_t * _93;
  long unsigned int _96;
  _Bool _97;
  long unsigned int _99;
  long int _101;
  struct List_t * pretmp_102;
  unsigned char cTxLock.4_103;
  unsigned char _104;
  long unsigned int _107;
  long int _109;
  unsigned char cRxLock.5_111;
  unsigned char _112;
  long unsigned int _115;
  long int _117;
  unsigned char cTxLock.4_119;
  unsigned char _120;
  long unsigned int _123;
  long int _125;
  unsigned char cRxLock.5_127;
  unsigned char _128;
  long unsigned int _131;
  long int _133;
  unsigned char cTxLock.4_135;
  unsigned char _136;
  long unsigned int _139;
  long int _141;
  unsigned char cRxLock.5_143;
  unsigned char _144;
  _Bool _149;
  struct List_t * pretmp_208;
  long unsigned int _209;
  long unsigned int _210;
  long unsigned int _211;
  struct List_t * pretmp_216;
  long unsigned int _224;
  long unsigned int _226;
  long unsigned int _229;
  long unsigned int _237;
  _Bool _240;
  long unsigned int _243;
  long unsigned int _244;
  long unsigned int prephitmp_245;

  <bb 2>:
  if (xQueue_17(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  R_OS_AssertCalled ("../src/FreeRTOS/queue.c", 731);

  <bb 4>:
  if (pvItemToQueue_21(D) != 0B)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  _22 = MEM[(struct Queue_t *)xQueue_17(D)].uxItemSize;
  if (_22 == 0)
    goto <bb 6>;
  else
    goto <bb 88>;

  <bb 6>:
  if (xCopyPosition_24(D) != 2)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  _25 = MEM[(struct Queue_t *)xQueue_17(D)].uxLength;
  if (_25 == 1)
    goto <bb 8>;
  else
    goto <bb 89>;

  <bb 8>:
  _28 = xTaskGetSchedulerState ();
  if (_28 != 0)
    goto <bb 91>;
  else
    goto <bb 9>;

  <bb 9>:
  xTicksToWait.3_29 = xTicksToWait;
  if (xTicksToWait.3_29 == 0)
    goto <bb 91>;
  else
    goto <bb 90>;

  <bb 10>:

  <bb 11>:
  # xEntryTimeSet_1 = PHI <0(91), 1(10)>
  vPortEnterCritical ();
  _32 ={v} MEM[(struct Queue_t *)xQueue_17(D)].uxMessagesWaiting;
  _33 = MEM[(struct Queue_t *)xQueue_17(D)].uxLength;
  _97 = _32 < _33;
  _240 = _97 | _149;
  if (_240 != 0)
    goto <bb 12>;
  else
    goto <bb 31>;

  <bb 12>:
  uxMessagesWaiting_75 ={v} MEM[(struct Queue_t *)xQueue_17(D)].uxMessagesWaiting;
  _76 = MEM[(struct Queue_t *)xQueue_17(D)].uxItemSize;
  if (_76 == 0)
    goto <bb 13>;
  else
    goto <bb 15>;

  <bb 13>:
  _77 = MEM[(struct Queue_t *)xQueue_17(D)].pcHead;
  if (_77 == 0B)
    goto <bb 14>;
  else
    goto <bb 92>;

  <bb 14>:
  _78 = MEM[(struct Queue_t *)xQueue_17(D)].pcTail;
  xReturn_79 = xTaskPriorityDisinherit (_78);
  MEM[(struct Queue_t *)xQueue_17(D)].pcTail = 0B;
  _96 = uxMessagesWaiting_75 + 1;
  MEM[(struct Queue_t *)xQueue_17(D)].uxMessagesWaiting ={v} _96;
  _61 ={v} MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_61 != 0)
    goto <bb 25>;
  else
    goto <bb 28>;

  <bb 15>:
  if (xCopyPosition_24(D) == 0)
    goto <bb 16>;
  else
    goto <bb 19>;

  <bb 16>:
  _80 = MEM[(struct Queue_t *)xQueue_17(D)].pcWriteTo;
  memcpy (_80, pvItemToQueue_21(D), _76);
  _81 = MEM[(struct Queue_t *)xQueue_17(D)].pcWriteTo;
  _82 = MEM[(struct Queue_t *)xQueue_17(D)].uxItemSize;
  _83 = _81 + _82;
  MEM[(struct Queue_t *)xQueue_17(D)].pcWriteTo = _83;
  _84 = MEM[(struct Queue_t *)xQueue_17(D)].pcTail;
  if (_83 >= _84)
    goto <bb 18>;
  else
    goto <bb 17>;

  <bb 17>:
  _243 = uxMessagesWaiting_75 + 1;
  goto <bb 93>;

  <bb 18>:
  _85 = MEM[(struct Queue_t *)xQueue_17(D)].pcHead;
  MEM[(struct Queue_t *)xQueue_17(D)].pcWriteTo = _85;
  _210 = uxMessagesWaiting_75 + 1;
  goto <bb 93>;

  <bb 19>:
  _86 = MEM[(struct Queue_t *)xQueue_17(D)].u.pcReadFrom;
  memcpy (_86, pvItemToQueue_21(D), _76);
  _87 = MEM[(struct Queue_t *)xQueue_17(D)].u.pcReadFrom;
  _88 = MEM[(struct Queue_t *)xQueue_17(D)].uxItemSize;
  _89 = -_88;
  _90 = _87 + _89;
  MEM[(struct Queue_t *)xQueue_17(D)].u.pcReadFrom = _90;
  _91 = MEM[(struct Queue_t *)xQueue_17(D)].pcHead;
  if (_90 < _91)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  _92 = MEM[(struct Queue_t *)xQueue_17(D)].pcTail;
  _93 = _92 + _89;
  MEM[(struct Queue_t *)xQueue_17(D)].u.pcReadFrom = _93;

  <bb 21>:
  if (xCopyPosition_24(D) == 2)
    goto <bb 23>;
  else
    goto <bb 22>;

  <bb 22>:
  _209 = uxMessagesWaiting_75 + 1;
  goto <bb 93>;

  <bb 23>:
  if (uxMessagesWaiting_75 != 0)
    goto <bb 24>;
  else
    goto <bb 93>;

  <bb 24>:
  uxMessagesWaiting_94 = uxMessagesWaiting_75 + 4294967295;
  _211 = uxMessagesWaiting_94 + 1;
  goto <bb 93>;

  <bb 25>:
  _62 = &MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToReceive;
  _64 = xTaskRemoveFromEventList (_62);
  if (_64 != 0)
    goto <bb 27>;
  else
    goto <bb 26>;

  <bb 26>:
  goto <bb 30>;

  <bb 27>:
  __asm__ __volatile__("SWI 0" :  :  : "memory");
  goto <bb 30>;

  <bb 28>:
  if (xReturn_79 != 0)
    goto <bb 29>;
  else
    goto <bb 26>;

  <bb 29>:
  __asm__ __volatile__("SWI 0" :  :  : "memory");

  <bb 30>:
  vPortExitCritical ();
  goto <bb 87>;

  <bb 31>:
  xTicksToWait.3_34 = xTicksToWait;
  if (xTicksToWait.3_34 == 0)
    goto <bb 32>;
  else
    goto <bb 33>;

  <bb 32>:
  vPortExitCritical ();
  goto <bb 87>;

  <bb 33>:
  if (xEntryTimeSet_1 == 0)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 34>:
  vTaskInternalSetTimeOutState (&xTimeOut);

  <bb 35>:
  vPortExitCritical ();
  vTaskSuspendAll ();
  vPortEnterCritical ();
  _39 ={v} MEM[(struct Queue_t *)xQueue_17(D)].cRxLock;
  if (_39 == -1)
    goto <bb 36>;
  else
    goto <bb 37>;

  <bb 36>:
  MEM[(struct Queue_t *)xQueue_17(D)].cRxLock ={v} 0;

  <bb 37>:
  _41 ={v} MEM[(struct Queue_t *)xQueue_17(D)].cTxLock;
  if (_41 == -1)
    goto <bb 38>;
  else
    goto <bb 39>;

  <bb 38>:
  MEM[(struct Queue_t *)xQueue_17(D)].cTxLock ={v} 0;

  <bb 39>:
  vPortExitCritical ();
  _45 = xTaskCheckForTimeOut (&xTimeOut, &xTicksToWait);
  if (_45 == 0)
    goto <bb 40>;
  else
    goto <bb 70>;

  <bb 40>:
  vPortEnterCritical ();
  _69 ={v} MEM[(const struct Queue_t *)xQueue_17(D)].uxMessagesWaiting;
  _70 = MEM[(const struct Queue_t *)xQueue_17(D)].uxLength;
  if (_69 == _70)
    goto <bb 94>;
  else
    goto <bb 97>;

  <bb 41>:
  _99 ={v} MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_99 != 0)
    goto <bb 43>;
  else
    goto <bb 42>;

  <bb 42>:
  MEM[(struct Queue_t *)xQueue_17(D)].cTxLock ={v} -1;
  vPortExitCritical ();
  vPortEnterCritical ();
  cRxLock_106 ={v} MEM[(struct Queue_t *)xQueue_17(D)].cRxLock;
  if (cRxLock_106 > 0)
    goto <bb 48>;
  else
    goto <bb 47>;

  <bb 43>:

  <bb 44>:
  # cTxLock_203 = PHI <cTxLock_98(96), cTxLock_105(43)>
  _101 = xTaskRemoveFromEventList (pretmp_208);
  if (_101 != 0)
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 45>:
  vTaskMissedYield ();

  <bb 46>:
  cTxLock.4_103 = (unsigned char) cTxLock_203;
  _104 = cTxLock.4_103 + 255;
  cTxLock_105 = (int8_t) _104;
  if (cTxLock_105 > 0)
    goto <bb 41>;
  else
    goto <bb 42>;

  <bb 47>:
  MEM[(struct Queue_t *)xQueue_17(D)].cRxLock ={v} -1;
  vPortExitCritical ();
  _52 = xTaskResumeAll ();
  if (_52 == 0)
    goto <bb 55>;
  else
    goto <bb 10>;

  <bb 48>:
  _18 ={v} MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_18 != 0)
    goto <bb 51>;
  else
    goto <bb 47>;

  <bb 49>:
  _107 ={v} MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_107 != 0)
    goto <bb 50>;
  else
    goto <bb 47>;

  <bb 50>:
  goto <bb 52>;

  <bb 51>:

  <bb 52>:
  # cRxLock_223 = PHI <cRxLock_106(51), cRxLock_113(50)>
  _109 = xTaskRemoveFromEventList (_47);
  if (_109 != 0)
    goto <bb 53>;
  else
    goto <bb 54>;

  <bb 53>:
  vTaskMissedYield ();

  <bb 54>:
  cRxLock.5_111 = (unsigned char) cRxLock_223;
  _112 = cRxLock.5_111 + 255;
  cRxLock_113 = (int8_t) _112;
  if (cRxLock_113 > 0)
    goto <bb 49>;
  else
    goto <bb 47>;

  <bb 55>:
  __asm__ __volatile__("SWI 0" :  :  : "memory");
  goto <bb 10>;

  <bb 56>:
  _115 ={v} MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_115 != 0)
    goto <bb 58>;
  else
    goto <bb 57>;

  <bb 57>:
  MEM[(struct Queue_t *)xQueue_17(D)].cTxLock ={v} -1;
  vPortExitCritical ();
  vPortEnterCritical ();
  cRxLock_122 ={v} MEM[(struct Queue_t *)xQueue_17(D)].cRxLock;
  if (cRxLock_122 > 0)
    goto <bb 63>;
  else
    goto <bb 62>;

  <bb 58>:

  <bb 59>:
  # cTxLock_202 = PHI <cTxLock_114(99), cTxLock_121(58)>
  _117 = xTaskRemoveFromEventList (pretmp_60);
  if (_117 != 0)
    goto <bb 60>;
  else
    goto <bb 61>;

  <bb 60>:
  vTaskMissedYield ();

  <bb 61>:
  cTxLock.4_119 = (unsigned char) cTxLock_202;
  _120 = cTxLock.4_119 + 255;
  cTxLock_121 = (int8_t) _120;
  if (cTxLock_121 > 0)
    goto <bb 56>;
  else
    goto <bb 57>;

  <bb 62>:
  MEM[(struct Queue_t *)xQueue_17(D)].cRxLock ={v} -1;
  vPortExitCritical ();
  xTaskResumeAll ();
  goto <bb 10>;

  <bb 63>:
  _3 ={v} MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_3 != 0)
    goto <bb 64>;
  else
    goto <bb 62>;

  <bb 64>:
  pretmp_216 = &MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToSend;
  goto <bb 67>;

  <bb 65>:
  _123 ={v} MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_123 != 0)
    goto <bb 66>;
  else
    goto <bb 62>;

  <bb 66>:

  <bb 67>:
  # cRxLock_222 = PHI <cRxLock_122(64), cRxLock_129(66)>
  _125 = xTaskRemoveFromEventList (pretmp_216);
  if (_125 != 0)
    goto <bb 68>;
  else
    goto <bb 69>;

  <bb 68>:
  vTaskMissedYield ();

  <bb 69>:
  cRxLock.5_127 = (unsigned char) cRxLock_222;
  _128 = cRxLock.5_127 + 255;
  cRxLock_129 = (int8_t) _128;
  if (cRxLock_129 > 0)
    goto <bb 65>;
  else
    goto <bb 62>;

  <bb 70>:
  vPortEnterCritical ();
  cTxLock_130 ={v} MEM[(struct Queue_t *)xQueue_17(D)].cTxLock;
  if (cTxLock_130 > 0)
    goto <bb 72>;
  else
    goto <bb 71>;

  <bb 71>:
  MEM[(struct Queue_t *)xQueue_17(D)].cTxLock ={v} -1;
  vPortExitCritical ();
  vPortEnterCritical ();
  cRxLock_138 ={v} MEM[(struct Queue_t *)xQueue_17(D)].cRxLock;
  if (cRxLock_138 > 0)
    goto <bb 80>;
  else
    goto <bb 79>;

  <bb 72>:
  _226 ={v} MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_226 != 0)
    goto <bb 73>;
  else
    goto <bb 71>;

  <bb 73>:
  pretmp_56 = &MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToReceive;
  goto <bb 76>;

  <bb 74>:
  _131 ={v} MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_131 != 0)
    goto <bb 75>;
  else
    goto <bb 71>;

  <bb 75>:

  <bb 76>:
  # cTxLock_201 = PHI <cTxLock_130(73), cTxLock_137(75)>
  _133 = xTaskRemoveFromEventList (pretmp_56);
  if (_133 != 0)
    goto <bb 77>;
  else
    goto <bb 78>;

  <bb 77>:
  vTaskMissedYield ();

  <bb 78>:
  cTxLock.4_135 = (unsigned char) cTxLock_201;
  _136 = cTxLock.4_135 + 255;
  cTxLock_137 = (int8_t) _136;
  if (cTxLock_137 > 0)
    goto <bb 74>;
  else
    goto <bb 71>;

  <bb 79>:
  MEM[(struct Queue_t *)xQueue_17(D)].cRxLock ={v} -1;
  vPortExitCritical ();
  xTaskResumeAll ();
  goto <bb 87>;

  <bb 80>:
  _229 ={v} MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_229 != 0)
    goto <bb 81>;
  else
    goto <bb 79>;

  <bb 81>:
  pretmp_102 = &MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToSend;
  goto <bb 84>;

  <bb 82>:
  _139 ={v} MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_139 != 0)
    goto <bb 83>;
  else
    goto <bb 79>;

  <bb 83>:

  <bb 84>:
  # cRxLock_221 = PHI <cRxLock_138(81), cRxLock_145(83)>
  _141 = xTaskRemoveFromEventList (pretmp_102);
  if (_141 != 0)
    goto <bb 85>;
  else
    goto <bb 86>;

  <bb 85>:
  vTaskMissedYield ();

  <bb 86>:
  cRxLock.5_143 = (unsigned char) cRxLock_221;
  _144 = cRxLock.5_143 + 255;
  cRxLock_145 = (int8_t) _144;
  if (cRxLock_145 > 0)
    goto <bb 82>;
  else
    goto <bb 79>;

  <bb 87>:
  # _6 = PHI <1(30), 0(32), 0(79)>
  xTimeOut ={v} {CLOBBER};
  return _6;

  <bb 88>:
  R_OS_AssertCalled ("../src/FreeRTOS/queue.c", 732);
  goto <bb 6>;

  <bb 89>:
  R_OS_AssertCalled ("../src/FreeRTOS/queue.c", 733);
  goto <bb 8>;

  <bb 90>:
  R_OS_AssertCalled ("../src/FreeRTOS/queue.c", 736);

  <bb 91>:
  _149 = xCopyPosition_24(D) == 2;
  goto <bb 11>;

  <bb 92>:
  _244 = uxMessagesWaiting_75 + 1;

  <bb 93>:
  # prephitmp_245 = PHI <_211(24), 1(23), _209(22), _210(18), _243(17), _244(92)>
  MEM[(struct Queue_t *)xQueue_17(D)].uxMessagesWaiting ={v} prephitmp_245;
  _237 ={v} MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_237 != 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 94>:
  vPortExitCritical ();
  _47 = &MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToSend;
  xTicksToWait.3_48 = xTicksToWait;
  vTaskPlaceOnEventList (_47, xTicksToWait.3_48);
  vPortEnterCritical ();
  cTxLock_98 ={v} MEM[(struct Queue_t *)xQueue_17(D)].cTxLock;
  if (cTxLock_98 > 0)
    goto <bb 95>;
  else
    goto <bb 42>;

  <bb 95>:
  _71 ={v} MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_71 != 0)
    goto <bb 96>;
  else
    goto <bb 42>;

  <bb 96>:
  pretmp_208 = &MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToReceive;
  goto <bb 44>;

  <bb 97>:
  vPortExitCritical ();
  vPortEnterCritical ();
  cTxLock_114 ={v} MEM[(struct Queue_t *)xQueue_17(D)].cTxLock;
  if (cTxLock_114 > 0)
    goto <bb 98>;
  else
    goto <bb 57>;

  <bb 98>:
  _224 ={v} MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_224 != 0)
    goto <bb 99>;
  else
    goto <bb 57>;

  <bb 99>:
  pretmp_60 = &MEM[(struct Queue_t *)xQueue_17(D)].xTasksWaitingToReceive;
  goto <bb 59>;

}



;; Function xQueueReceive (xQueueReceive, funcdef_no=13, decl_uid=6978, cgraph_uid=13, symbol_order=14)


Analyzing loop at ../src/FreeRTOS/queue.c:1266
../src/FreeRTOS/queue.c:1266:3: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:1266:3: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:1266:3: note: not vectorized: multiple nested loops.
../src/FreeRTOS/queue.c:1266:3: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2234
../src/FreeRTOS/queue.c:2234:9: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2234:9: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2234:9: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2234:9: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2200
../src/FreeRTOS/queue.c:2200:10: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2200:10: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2200:10: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2200:10: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2234
../src/FreeRTOS/queue.c:2234:9: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2234:9: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2234:9: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2234:9: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2200
../src/FreeRTOS/queue.c:2200:10: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2200:10: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2200:10: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2200:10: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2234
../src/FreeRTOS/queue.c:2234:9: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2234:9: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2234:9: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2234:9: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2200
../src/FreeRTOS/queue.c:2200:10: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2200:10: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2200:10: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2200:10: note: bad loop form.
../src/FreeRTOS/queue.c:1239:12: note: vectorized 0 loops in function.
xQueueReceive (void * xQueue, void * const pvBuffer, TickType_t xTicksToWait)
{
  int8_t cTxLock;
  int8_t cRxLock;
  int8_t cTxLock;
  int8_t cRxLock;
  int8_t cTxLock;
  int8_t cRxLock;
  BaseType_t xReturn;
  BaseType_t xReturn;
  const UBaseType_t uxMessagesWaiting;
  struct TimeOut_t xTimeOut;
  BaseType_t xEntryTimeSet;
  long unsigned int _4;
  BaseType_t _5;
  long unsigned int _18;
  long int _21;
  long unsigned int xTicksToWait.13_22;
  long unsigned int xTicksToWait.13_26;
  signed char _31;
  signed char _33;
  long int _37;
  long unsigned int _41;
  struct List_t * _44;
  long unsigned int xTicksToWait.13_45;
  long int _49;
  long unsigned int _53;
  long unsigned int _55;
  struct List_t * _56;
  long int _58;
  long unsigned int _62;
  long unsigned int _64;
  long unsigned int _67;
  long unsigned int _72;
  int8_t * _73;
  int8_t * _74;
  int8_t * _75;
  int8_t * _76;
  long unsigned int _79;
  long int _81;
  unsigned char cTxLock.4_83;
  unsigned char _84;
  long unsigned int _87;
  long int _89;
  unsigned char cRxLock.5_91;
  unsigned char _92;
  long unsigned int _95;
  long int _97;
  unsigned char cTxLock.4_99;
  unsigned char _100;
  long unsigned int _103;
  long int _105;
  unsigned char cRxLock.5_107;
  unsigned char _108;
  long unsigned int _111;
  long int _113;
  unsigned char cTxLock.4_115;
  unsigned char _116;
  long unsigned int _119;
  long int _121;
  unsigned char cRxLock.5_123;
  unsigned char _124;
  struct List_t * pretmp_129;
  struct List_t * pretmp_183;
  struct List_t * pretmp_185;
  struct List_t * pretmp_186;
  struct List_t * pretmp_188;
  long unsigned int _195;
  long unsigned int _197;
  long unsigned int _200;
  int8_t * prephitmp_209;

  <bb 2>:
  if (xQueue_14(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  R_OS_AssertCalled ("../src/FreeRTOS/queue.c", 1246);

  <bb 4>:
  if (pvBuffer_17(D) != 0B)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  _18 = MEM[(struct Queue_t *)xQueue_14(D)].uxItemSize;
  if (_18 == 0)
    goto <bb 6>;
  else
    goto <bb 77>;

  <bb 6>:
  _21 = xTaskGetSchedulerState ();
  if (_21 != 0)
    goto <bb 79>;
  else
    goto <bb 7>;

  <bb 7>:
  xTicksToWait.13_22 = xTicksToWait;
  if (xTicksToWait.13_22 == 0)
    goto <bb 79>;
  else
    goto <bb 78>;

  <bb 8>:

  <bb 9>:
  # xEntryTimeSet_1 = PHI <0(79), 1(8)>
  vPortEnterCritical ();
  uxMessagesWaiting_25 ={v} MEM[(struct Queue_t *)xQueue_14(D)].uxMessagesWaiting;
  if (uxMessagesWaiting_25 != 0)
    goto <bb 10>;
  else
    goto <bb 19>;

  <bb 10>:
  # uxMessagesWaiting_38 = PHI <uxMessagesWaiting_25(9)>
  _72 = MEM[(struct Queue_t *)xQueue_14(D)].uxItemSize;
  if (_72 != 0)
    goto <bb 11>;
  else
    goto <bb 14>;

  <bb 11>:
  _73 = MEM[(struct Queue_t *)xQueue_14(D)].u.pcReadFrom;
  _74 = _73 + _72;
  MEM[(struct Queue_t *)xQueue_14(D)].u.pcReadFrom = _74;
  _75 = MEM[(struct Queue_t *)xQueue_14(D)].pcTail;
  if (_74 >= _75)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  _76 = MEM[(struct Queue_t *)xQueue_14(D)].pcHead;
  MEM[(struct Queue_t *)xQueue_14(D)].u.pcReadFrom = _76;

  <bb 13>:
  # prephitmp_209 = PHI <_74(11), _76(12)>
  memcpy (pvBuffer_17(D), prephitmp_209, _72);

  <bb 14>:
  _53 = uxMessagesWaiting_38 + 4294967295;
  MEM[(struct Queue_t *)xQueue_14(D)].uxMessagesWaiting ={v} _53;
  _55 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_55 != 0)
    goto <bb 16>;
  else
    goto <bb 15>;

  <bb 15>:
  goto <bb 18>;

  <bb 16>:
  _56 = &MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend;
  _58 = xTaskRemoveFromEventList (_56);
  if (_58 != 0)
    goto <bb 17>;
  else
    goto <bb 15>;

  <bb 17>:
  __asm__ __volatile__("SWI 0" :  :  : "memory");

  <bb 18>:
  vPortExitCritical ();
  goto <bb 76>;

  <bb 19>:
  xTicksToWait.13_26 = xTicksToWait;
  if (xTicksToWait.13_26 == 0)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  vPortExitCritical ();
  goto <bb 76>;

  <bb 21>:
  if (xEntryTimeSet_1 == 0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  vTaskInternalSetTimeOutState (&xTimeOut);

  <bb 23>:
  vPortExitCritical ();
  vTaskSuspendAll ();
  vPortEnterCritical ();
  _31 ={v} MEM[(struct Queue_t *)xQueue_14(D)].cRxLock;
  if (_31 == -1)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  MEM[(struct Queue_t *)xQueue_14(D)].cRxLock ={v} 0;

  <bb 25>:
  _33 ={v} MEM[(struct Queue_t *)xQueue_14(D)].cTxLock;
  if (_33 == -1)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 26>:
  MEM[(struct Queue_t *)xQueue_14(D)].cTxLock ={v} 0;

  <bb 27>:
  vPortExitCritical ();
  _37 = xTaskCheckForTimeOut (&xTimeOut, &xTicksToWait);
  if (_37 == 0)
    goto <bb 28>;
  else
    goto <bb 59>;

  <bb 28>:
  vPortEnterCritical ();
  _62 ={v} MEM[(const struct Queue_t *)xQueue_14(D)].uxMessagesWaiting;
  if (_62 == 0)
    goto <bb 80>;
  else
    goto <bb 82>;

  <bb 29>:
  _79 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_79 != 0)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  goto <bb 33>;

  <bb 31>:
  MEM[(struct Queue_t *)xQueue_14(D)].cTxLock ={v} -1;
  vPortExitCritical ();
  vPortEnterCritical ();
  cRxLock_86 ={v} MEM[(struct Queue_t *)xQueue_14(D)].cRxLock;
  if (cRxLock_86 > 0)
    goto <bb 37>;
  else
    goto <bb 36>;

  <bb 32>:

  <bb 33>:
  # cTxLock_180 = PHI <cTxLock_78(32), cTxLock_85(30)>
  _81 = xTaskRemoveFromEventList (_44);
  if (_81 != 0)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 34>:
  vTaskMissedYield ();

  <bb 35>:
  cTxLock.4_83 = (unsigned char) cTxLock_180;
  _84 = cTxLock.4_83 + 255;
  cTxLock_85 = (int8_t) _84;
  if (cTxLock_85 > 0)
    goto <bb 29>;
  else
    goto <bb 31>;

  <bb 36>:
  MEM[(struct Queue_t *)xQueue_14(D)].cRxLock ={v} -1;
  vPortExitCritical ();
  _49 = xTaskResumeAll ();
  if (_49 == 0)
    goto <bb 44>;
  else
    goto <bb 8>;

  <bb 37>:
  _200 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_200 != 0)
    goto <bb 38>;
  else
    goto <bb 36>;

  <bb 38>:
  pretmp_185 = &MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend;
  goto <bb 41>;

  <bb 39>:
  _87 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_87 != 0)
    goto <bb 40>;
  else
    goto <bb 36>;

  <bb 40>:

  <bb 41>:
  # cRxLock_194 = PHI <cRxLock_86(38), cRxLock_93(40)>
  _89 = xTaskRemoveFromEventList (pretmp_185);
  if (_89 != 0)
    goto <bb 42>;
  else
    goto <bb 43>;

  <bb 42>:
  vTaskMissedYield ();

  <bb 43>:
  cRxLock.5_91 = (unsigned char) cRxLock_194;
  _92 = cRxLock.5_91 + 255;
  cRxLock_93 = (int8_t) _92;
  if (cRxLock_93 > 0)
    goto <bb 39>;
  else
    goto <bb 36>;

  <bb 44>:
  __asm__ __volatile__("SWI 0" :  :  : "memory");
  goto <bb 8>;

  <bb 45>:
  _95 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_95 != 0)
    goto <bb 47>;
  else
    goto <bb 46>;

  <bb 46>:
  MEM[(struct Queue_t *)xQueue_14(D)].cTxLock ={v} -1;
  vPortExitCritical ();
  vPortEnterCritical ();
  cRxLock_102 ={v} MEM[(struct Queue_t *)xQueue_14(D)].cRxLock;
  if (cRxLock_102 > 0)
    goto <bb 52>;
  else
    goto <bb 51>;

  <bb 47>:

  <bb 48>:
  # cTxLock_178 = PHI <cTxLock_94(84), cTxLock_101(47)>
  _97 = xTaskRemoveFromEventList (pretmp_183);
  if (_97 != 0)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  vTaskMissedYield ();

  <bb 50>:
  cTxLock.4_99 = (unsigned char) cTxLock_178;
  _100 = cTxLock.4_99 + 255;
  cTxLock_101 = (int8_t) _100;
  if (cTxLock_101 > 0)
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 51>:
  MEM[(struct Queue_t *)xQueue_14(D)].cRxLock ={v} -1;
  vPortExitCritical ();
  xTaskResumeAll ();
  goto <bb 8>;

  <bb 52>:
  _41 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_41 != 0)
    goto <bb 53>;
  else
    goto <bb 51>;

  <bb 53>:
  pretmp_186 = &MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend;
  goto <bb 56>;

  <bb 54>:
  _103 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_103 != 0)
    goto <bb 55>;
  else
    goto <bb 51>;

  <bb 55>:

  <bb 56>:
  # cRxLock_193 = PHI <cRxLock_102(53), cRxLock_109(55)>
  _105 = xTaskRemoveFromEventList (pretmp_186);
  if (_105 != 0)
    goto <bb 57>;
  else
    goto <bb 58>;

  <bb 57>:
  vTaskMissedYield ();

  <bb 58>:
  cRxLock.5_107 = (unsigned char) cRxLock_193;
  _108 = cRxLock.5_107 + 255;
  cRxLock_109 = (int8_t) _108;
  if (cRxLock_109 > 0)
    goto <bb 54>;
  else
    goto <bb 51>;

  <bb 59>:
  vPortEnterCritical ();
  cTxLock_110 ={v} MEM[(struct Queue_t *)xQueue_14(D)].cTxLock;
  if (cTxLock_110 > 0)
    goto <bb 61>;
  else
    goto <bb 60>;

  <bb 60>:
  MEM[(struct Queue_t *)xQueue_14(D)].cTxLock ={v} -1;
  vPortExitCritical ();
  vPortEnterCritical ();
  cRxLock_118 ={v} MEM[(struct Queue_t *)xQueue_14(D)].cRxLock;
  if (cRxLock_118 > 0)
    goto <bb 69>;
  else
    goto <bb 68>;

  <bb 61>:
  _195 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_195 != 0)
    goto <bb 62>;
  else
    goto <bb 60>;

  <bb 62>:
  pretmp_188 = &MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive;
  goto <bb 65>;

  <bb 63>:
  _111 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_111 != 0)
    goto <bb 64>;
  else
    goto <bb 60>;

  <bb 64>:

  <bb 65>:
  # cTxLock_177 = PHI <cTxLock_110(62), cTxLock_117(64)>
  _113 = xTaskRemoveFromEventList (pretmp_188);
  if (_113 != 0)
    goto <bb 66>;
  else
    goto <bb 67>;

  <bb 66>:
  vTaskMissedYield ();

  <bb 67>:
  cTxLock.4_115 = (unsigned char) cTxLock_177;
  _116 = cTxLock.4_115 + 255;
  cTxLock_117 = (int8_t) _116;
  if (cTxLock_117 > 0)
    goto <bb 63>;
  else
    goto <bb 60>;

  <bb 68>:
  MEM[(struct Queue_t *)xQueue_14(D)].cRxLock ={v} -1;
  vPortExitCritical ();
  xTaskResumeAll ();
  vPortEnterCritical ();
  _64 ={v} MEM[(const struct Queue_t *)xQueue_14(D)].uxMessagesWaiting;
  if (_64 == 0)
    goto <bb 20>;
  else
    goto <bb 85>;

  <bb 69>:
  _4 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_4 != 0)
    goto <bb 70>;
  else
    goto <bb 68>;

  <bb 70>:
  pretmp_129 = &MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend;
  goto <bb 73>;

  <bb 71>:
  _119 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_119 != 0)
    goto <bb 72>;
  else
    goto <bb 68>;

  <bb 72>:

  <bb 73>:
  # cRxLock_192 = PHI <cRxLock_118(70), cRxLock_125(72)>
  _121 = xTaskRemoveFromEventList (pretmp_129);
  if (_121 != 0)
    goto <bb 74>;
  else
    goto <bb 75>;

  <bb 74>:
  vTaskMissedYield ();

  <bb 75>:
  cRxLock.5_123 = (unsigned char) cRxLock_192;
  _124 = cRxLock.5_123 + 255;
  cRxLock_125 = (int8_t) _124;
  if (cRxLock_125 > 0)
    goto <bb 71>;
  else
    goto <bb 68>;

  <bb 76>:
  # _5 = PHI <1(18), 0(20)>
  xTimeOut ={v} {CLOBBER};
  return _5;

  <bb 77>:
  R_OS_AssertCalled ("../src/FreeRTOS/queue.c", 1250);
  goto <bb 6>;

  <bb 78>:
  R_OS_AssertCalled ("../src/FreeRTOS/queue.c", 1255);

  <bb 79>:
  goto <bb 9>;

  <bb 80>:
  vPortExitCritical ();
  _44 = &MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive;
  xTicksToWait.13_45 = xTicksToWait;
  vTaskPlaceOnEventList (_44, xTicksToWait.13_45);
  vPortEnterCritical ();
  cTxLock_78 ={v} MEM[(struct Queue_t *)xQueue_14(D)].cTxLock;
  if (cTxLock_78 > 0)
    goto <bb 81>;
  else
    goto <bb 31>;

  <bb 81>:
  _197 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_197 != 0)
    goto <bb 32>;
  else
    goto <bb 31>;

  <bb 82>:
  vPortExitCritical ();
  vPortEnterCritical ();
  cTxLock_94 ={v} MEM[(struct Queue_t *)xQueue_14(D)].cTxLock;
  if (cTxLock_94 > 0)
    goto <bb 83>;
  else
    goto <bb 46>;

  <bb 83>:
  _67 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_67 != 0)
    goto <bb 84>;
  else
    goto <bb 46>;

  <bb 84>:
  pretmp_183 = &MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive;
  goto <bb 48>;

  <bb 85>:
  vPortExitCritical ();
  goto <bb 8>;

}



;; Function xQueueSemaphoreTake (xQueueSemaphoreTake, funcdef_no=14, decl_uid=7033, cgraph_uid=14, symbol_order=15)


Analyzing loop at ../src/FreeRTOS/queue.c:1412
../src/FreeRTOS/queue.c:1412:3: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:1412:3: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:1412:3: note: not vectorized: multiple nested loops.
../src/FreeRTOS/queue.c:1412:3: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2234
../src/FreeRTOS/queue.c:2234:9: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2234:9: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2234:9: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2234:9: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2200
../src/FreeRTOS/queue.c:2200:10: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2200:10: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2200:10: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2200:10: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2234
../src/FreeRTOS/queue.c:2234:9: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2234:9: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2234:9: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2234:9: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2200
../src/FreeRTOS/queue.c:2200:10: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2200:10: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2200:10: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2200:10: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2234
../src/FreeRTOS/queue.c:2234:9: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2234:9: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2234:9: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2234:9: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2200
../src/FreeRTOS/queue.c:2200:10: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2200:10: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2200:10: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2200:10: note: bad loop form.
../src/FreeRTOS/queue.c:1381:12: note: vectorized 0 loops in function.
xQueueSemaphoreTake (void * xQueue, TickType_t xTicksToWait)
{
  int8_t cTxLock;
  int8_t cRxLock;
  int8_t cTxLock;
  int8_t cRxLock;
  int8_t cTxLock;
  int8_t cRxLock;
  UBaseType_t uxHighestPriorityOfWaitingTasks;
  BaseType_t xReturn;
  BaseType_t xReturn;
  const UBaseType_t uxSemaphoreCount;
  BaseType_t xInheritanceOccurred;
  struct TimeOut_t xTimeOut;
  BaseType_t xEntryTimeSet;
  long unsigned int _2;
  BaseType_t _6;
  long unsigned int _23;
  long int _26;
  long unsigned int xTicksToWait.15_27;
  long unsigned int xTicksToWait.15_31;
  signed char _36;
  signed char _38;
  long int _42;
  long unsigned int _43;
  int8_t * _47;
  int8_t * _53;
  int8_t * _55;
  struct List_t * _59;
  long unsigned int xTicksToWait.15_60;
  long int _64;
  long unsigned int _68;
  int8_t * _70;
  void * _72;
  long unsigned int _74;
  struct List_t * _75;
  long int _77;
  long unsigned int _81;
  long unsigned int _83;
  long unsigned int _84;
  long unsigned int _85;
  struct xLIST_ITEM * _86;
  long unsigned int _87;
  long unsigned int _97;
  long unsigned int _98;
  long int _99;
  struct List_t * pretmp_100;
  unsigned char cTxLock.4_101;
  unsigned char _102;
  long unsigned int _105;
  long int _107;
  unsigned char cRxLock.5_109;
  unsigned char _110;
  long unsigned int _113;
  long int _115;
  unsigned char cTxLock.4_117;
  unsigned char _118;
  long unsigned int _121;
  long int _123;
  unsigned char cRxLock.5_125;
  unsigned char _126;
  long unsigned int _129;
  long int _131;
  unsigned char cTxLock.4_133;
  unsigned char _134;
  long unsigned int _137;
  long int _139;
  unsigned char cRxLock.5_141;
  unsigned char _142;
  long unsigned int _196;
  struct List_t * pretmp_200;
  struct List_t * pretmp_209;
  long unsigned int _210;
  struct List_t * pretmp_219;
  struct List_t * pretmp_221;

  <bb 2>:
  if (xQueue_20(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  R_OS_AssertCalled ("../src/FreeRTOS/queue.c", 1392);

  <bb 4>:
  _23 = MEM[(struct Queue_t *)xQueue_20(D)].uxItemSize;
  if (_23 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  R_OS_AssertCalled ("../src/FreeRTOS/queue.c", 1396);

  <bb 6>:
  _26 = xTaskGetSchedulerState ();
  if (_26 != 0)
    goto <bb 84>;
  else
    goto <bb 7>;

  <bb 7>:
  xTicksToWait.15_27 = xTicksToWait;
  if (xTicksToWait.15_27 == 0)
    goto <bb 84>;
  else
    goto <bb 83>;

  <bb 8>:
  # xInheritanceOccurred_92 = PHI <xInheritanceOccurred_4(47), xInheritanceOccurred_4(39), xInheritanceOccurred_3(90), xInheritanceOccurred_3(54)>

  <bb 9>:
  # xEntryTimeSet_1 = PHI <0(84), 1(8)>
  # xInheritanceOccurred_3 = PHI <0(84), xInheritanceOccurred_92(8)>
  vPortEnterCritical ();
  uxSemaphoreCount_30 ={v} MEM[(struct Queue_t *)xQueue_20(D)].uxMessagesWaiting;
  if (uxSemaphoreCount_30 != 0)
    goto <bb 10>;
  else
    goto <bb 17>;

  <bb 10>:
  # uxSemaphoreCount_191 = PHI <uxSemaphoreCount_30(9)>
  _68 = uxSemaphoreCount_191 + 4294967295;
  MEM[(struct Queue_t *)xQueue_20(D)].uxMessagesWaiting ={v} _68;
  _70 = MEM[(struct Queue_t *)xQueue_20(D)].pcHead;
  if (_70 == 0B)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _72 = pvTaskIncrementMutexHeldCount ();
  MEM[(struct Queue_t *)xQueue_20(D)].pcTail = _72;

  <bb 12>:
  _74 ={v} MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_74 != 0)
    goto <bb 14>;
  else
    goto <bb 13>;

  <bb 13>:
  goto <bb 16>;

  <bb 14>:
  _75 = &MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToSend;
  _77 = xTaskRemoveFromEventList (_75);
  if (_77 != 0)
    goto <bb 15>;
  else
    goto <bb 13>;

  <bb 15>:
  __asm__ __volatile__("SWI 0" :  :  : "memory");

  <bb 16>:
  vPortExitCritical ();
  goto <bb 82>;

  <bb 17>:
  xTicksToWait.15_31 = xTicksToWait;
  if (xTicksToWait.15_31 == 0)
    goto <bb 18>;
  else
    goto <bb 21>;

  <bb 18>:
  # xInheritanceOccurred_62 = PHI <xInheritanceOccurred_3(17)>
  if (xInheritanceOccurred_62 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  R_OS_AssertCalled ("../src/FreeRTOS/queue.c", 1473);

  <bb 20>:
  vPortExitCritical ();
  goto <bb 82>;

  <bb 21>:
  if (xEntryTimeSet_1 == 0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  vTaskInternalSetTimeOutState (&xTimeOut);

  <bb 23>:
  vPortExitCritical ();
  vTaskSuspendAll ();
  vPortEnterCritical ();
  _36 ={v} MEM[(struct Queue_t *)xQueue_20(D)].cRxLock;
  if (_36 == -1)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  MEM[(struct Queue_t *)xQueue_20(D)].cRxLock ={v} 0;

  <bb 25>:
  _38 ={v} MEM[(struct Queue_t *)xQueue_20(D)].cTxLock;
  if (_38 == -1)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 26>:
  MEM[(struct Queue_t *)xQueue_20(D)].cTxLock ={v} 0;

  <bb 27>:
  vPortExitCritical ();
  _42 = xTaskCheckForTimeOut (&xTimeOut, &xTicksToWait);
  if (_42 == 0)
    goto <bb 28>;
  else
    goto <bb 62>;

  <bb 28>:
  vPortEnterCritical ();
  _81 ={v} MEM[(const struct Queue_t *)xQueue_20(D)].uxMessagesWaiting;
  if (_81 == 0)
    goto <bb 88>;
  else
    goto <bb 85>;

  <bb 29>:
  vPortEnterCritical ();
  _55 = MEM[(struct Queue_t *)xQueue_20(D)].pcTail;
  xInheritanceOccurred_57 = xTaskPriorityInherit (_55);
  vPortExitCritical ();

  <bb 30>:
  # xInheritanceOccurred_4 = PHI <xInheritanceOccurred_3(88), xInheritanceOccurred_57(29)>
  _59 = &MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToReceive;
  xTicksToWait.15_60 = xTicksToWait;
  vTaskPlaceOnEventList (_59, xTicksToWait.15_60);
  vPortEnterCritical ();
  cTxLock_96 ={v} MEM[(struct Queue_t *)xQueue_20(D)].cTxLock;
  if (cTxLock_96 > 0)
    goto <bb 32>;
  else
    goto <bb 31>;

  <bb 31>:
  MEM[(struct Queue_t *)xQueue_20(D)].cTxLock ={v} -1;
  vPortExitCritical ();
  vPortEnterCritical ();
  cRxLock_104 ={v} MEM[(struct Queue_t *)xQueue_20(D)].cRxLock;
  if (cRxLock_104 > 0)
    goto <bb 40>;
  else
    goto <bb 39>;

  <bb 32>:
  _2 ={v} MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_2 != 0)
    goto <bb 35>;
  else
    goto <bb 31>;

  <bb 33>:
  _97 ={v} MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_97 != 0)
    goto <bb 34>;
  else
    goto <bb 31>;

  <bb 34>:
  goto <bb 36>;

  <bb 35>:

  <bb 36>:
  # cTxLock_206 = PHI <cTxLock_96(35), cTxLock_103(34)>
  _99 = xTaskRemoveFromEventList (_59);
  if (_99 != 0)
    goto <bb 37>;
  else
    goto <bb 38>;

  <bb 37>:
  vTaskMissedYield ();

  <bb 38>:
  cTxLock.4_101 = (unsigned char) cTxLock_206;
  _102 = cTxLock.4_101 + 255;
  cTxLock_103 = (int8_t) _102;
  if (cTxLock_103 > 0)
    goto <bb 33>;
  else
    goto <bb 31>;

  <bb 39>:
  MEM[(struct Queue_t *)xQueue_20(D)].cRxLock ={v} -1;
  vPortExitCritical ();
  _64 = xTaskResumeAll ();
  if (_64 == 0)
    goto <bb 47>;
  else
    goto <bb 8>;

  <bb 40>:
  _210 ={v} MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_210 != 0)
    goto <bb 41>;
  else
    goto <bb 39>;

  <bb 41>:
  pretmp_200 = &MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToSend;
  goto <bb 44>;

  <bb 42>:
  _105 ={v} MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_105 != 0)
    goto <bb 43>;
  else
    goto <bb 39>;

  <bb 43>:

  <bb 44>:
  # cRxLock_194 = PHI <cRxLock_104(41), cRxLock_111(43)>
  _107 = xTaskRemoveFromEventList (pretmp_200);
  if (_107 != 0)
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 45>:
  vTaskMissedYield ();

  <bb 46>:
  cRxLock.5_109 = (unsigned char) cRxLock_194;
  _110 = cRxLock.5_109 + 255;
  cRxLock_111 = (int8_t) _110;
  if (cRxLock_111 > 0)
    goto <bb 42>;
  else
    goto <bb 39>;

  <bb 47>:
  __asm__ __volatile__("SWI 0" :  :  : "memory");
  goto <bb 8>;

  <bb 48>:
  _113 ={v} MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_113 != 0)
    goto <bb 50>;
  else
    goto <bb 49>;

  <bb 49>:
  MEM[(struct Queue_t *)xQueue_20(D)].cTxLock ={v} -1;
  vPortExitCritical ();
  vPortEnterCritical ();
  cRxLock_120 ={v} MEM[(struct Queue_t *)xQueue_20(D)].cRxLock;
  if (cRxLock_120 > 0)
    goto <bb 55>;
  else
    goto <bb 54>;

  <bb 50>:

  <bb 51>:
  # cTxLock_205 = PHI <cTxLock_112(87), cTxLock_119(50)>
  _115 = xTaskRemoveFromEventList (pretmp_219);
  if (_115 != 0)
    goto <bb 52>;
  else
    goto <bb 53>;

  <bb 52>:
  vTaskMissedYield ();

  <bb 53>:
  cTxLock.4_117 = (unsigned char) cTxLock_205;
  _118 = cTxLock.4_117 + 255;
  cTxLock_119 = (int8_t) _118;
  if (cTxLock_119 > 0)
    goto <bb 48>;
  else
    goto <bb 49>;

  <bb 54>:
  MEM[(struct Queue_t *)xQueue_20(D)].cRxLock ={v} -1;
  vPortExitCritical ();
  xTaskResumeAll ();
  goto <bb 8>;

  <bb 55>:
  _98 ={v} MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_98 != 0)
    goto <bb 56>;
  else
    goto <bb 54>;

  <bb 56>:
  pretmp_221 = &MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToSend;
  goto <bb 59>;

  <bb 57>:
  _121 ={v} MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_121 != 0)
    goto <bb 58>;
  else
    goto <bb 54>;

  <bb 58>:

  <bb 59>:
  # cRxLock_193 = PHI <cRxLock_120(56), cRxLock_127(58)>
  _123 = xTaskRemoveFromEventList (pretmp_221);
  if (_123 != 0)
    goto <bb 60>;
  else
    goto <bb 61>;

  <bb 60>:
  vTaskMissedYield ();

  <bb 61>:
  cRxLock.5_125 = (unsigned char) cRxLock_193;
  _126 = cRxLock.5_125 + 255;
  cRxLock_127 = (int8_t) _126;
  if (cRxLock_127 > 0)
    goto <bb 57>;
  else
    goto <bb 54>;

  <bb 62>:
  vPortEnterCritical ();
  cTxLock_128 ={v} MEM[(struct Queue_t *)xQueue_20(D)].cTxLock;
  if (cTxLock_128 > 0)
    goto <bb 64>;
  else
    goto <bb 63>;

  <bb 63>:
  MEM[(struct Queue_t *)xQueue_20(D)].cTxLock ={v} -1;
  vPortExitCritical ();
  vPortEnterCritical ();
  cRxLock_136 ={v} MEM[(struct Queue_t *)xQueue_20(D)].cRxLock;
  if (cRxLock_136 > 0)
    goto <bb 72>;
  else
    goto <bb 71>;

  <bb 64>:
  _196 ={v} MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_196 != 0)
    goto <bb 65>;
  else
    goto <bb 63>;

  <bb 65>:
  pretmp_209 = &MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToReceive;
  goto <bb 68>;

  <bb 66>:
  _129 ={v} MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_129 != 0)
    goto <bb 67>;
  else
    goto <bb 63>;

  <bb 67>:

  <bb 68>:
  # cTxLock_204 = PHI <cTxLock_128(65), cTxLock_135(67)>
  _131 = xTaskRemoveFromEventList (pretmp_209);
  if (_131 != 0)
    goto <bb 69>;
  else
    goto <bb 70>;

  <bb 69>:
  vTaskMissedYield ();

  <bb 70>:
  cTxLock.4_133 = (unsigned char) cTxLock_204;
  _134 = cTxLock.4_133 + 255;
  cTxLock_135 = (int8_t) _134;
  if (cTxLock_135 > 0)
    goto <bb 66>;
  else
    goto <bb 63>;

  <bb 71>:
  MEM[(struct Queue_t *)xQueue_20(D)].cRxLock ={v} -1;
  vPortExitCritical ();
  xTaskResumeAll ();
  vPortEnterCritical ();
  _83 ={v} MEM[(const struct Queue_t *)xQueue_20(D)].uxMessagesWaiting;
  if (_83 == 0)
    goto <bb 89>;
  else
    goto <bb 90>;

  <bb 72>:
  _43 ={v} MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_43 != 0)
    goto <bb 73>;
  else
    goto <bb 71>;

  <bb 73>:
  pretmp_100 = &MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToSend;
  goto <bb 76>;

  <bb 74>:
  _137 ={v} MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_137 != 0)
    goto <bb 75>;
  else
    goto <bb 71>;

  <bb 75>:

  <bb 76>:
  # cRxLock_192 = PHI <cRxLock_136(73), cRxLock_143(75)>
  _139 = xTaskRemoveFromEventList (pretmp_100);
  if (_139 != 0)
    goto <bb 77>;
  else
    goto <bb 78>;

  <bb 77>:
  vTaskMissedYield ();

  <bb 78>:
  cRxLock.5_141 = (unsigned char) cRxLock_192;
  _142 = cRxLock.5_141 + 255;
  cRxLock_143 = (int8_t) _142;
  if (cRxLock_143 > 0)
    goto <bb 74>;
  else
    goto <bb 71>;

  <bb 79>:
  vPortEnterCritical ();
  _85 ={v} MEM[(const struct Queue_t *)xQueue_20(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_85 != 0)
    goto <bb 80>;
  else
    goto <bb 81>;

  <bb 80>:
  _86 = MEM[(const struct Queue_t *)xQueue_20(D)].xTasksWaitingToReceive.xListEnd.pxNext;
  _87 = _86->xItemValue;
  uxHighestPriorityOfWaitingTasks_88 = 20 - _87;

  <bb 81>:
  # uxHighestPriorityOfWaitingTasks_89 = PHI <0(79), uxHighestPriorityOfWaitingTasks_88(80)>
  _47 = MEM[(struct Queue_t *)xQueue_20(D)].pcTail;
  vTaskPriorityDisinheritAfterTimeout (_47, uxHighestPriorityOfWaitingTasks_89);
  vPortExitCritical ();

  <bb 82>:
  # _6 = PHI <1(16), 0(20), 0(81), 0(89)>
  xTimeOut ={v} {CLOBBER};
  return _6;

  <bb 83>:
  R_OS_AssertCalled ("../src/FreeRTOS/queue.c", 1401);

  <bb 84>:
  goto <bb 9>;

  <bb 85>:
  vPortExitCritical ();
  vPortEnterCritical ();
  cTxLock_112 ={v} MEM[(struct Queue_t *)xQueue_20(D)].cTxLock;
  if (cTxLock_112 > 0)
    goto <bb 86>;
  else
    goto <bb 49>;

  <bb 86>:
  _84 ={v} MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_84 != 0)
    goto <bb 87>;
  else
    goto <bb 49>;

  <bb 87>:
  pretmp_219 = &MEM[(struct Queue_t *)xQueue_20(D)].xTasksWaitingToReceive;
  goto <bb 51>;

  <bb 88>:
  vPortExitCritical ();
  _53 = MEM[(struct Queue_t *)xQueue_20(D)].pcHead;
  if (_53 == 0B)
    goto <bb 29>;
  else
    goto <bb 30>;

  <bb 89>:
  # xInheritanceOccurred_198 = PHI <xInheritanceOccurred_3(71)>
  vPortExitCritical ();
  if (xInheritanceOccurred_198 != 0)
    goto <bb 79>;
  else
    goto <bb 82>;

  <bb 90>:
  vPortExitCritical ();
  goto <bb 8>;

}



;; Function xQueuePeek (xQueuePeek, funcdef_no=15, decl_uid=6971, cgraph_uid=15, symbol_order=16)


Analyzing loop at ../src/FreeRTOS/queue.c:1628
../src/FreeRTOS/queue.c:1628:3: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:1628:3: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:1628:3: note: not vectorized: multiple nested loops.
../src/FreeRTOS/queue.c:1628:3: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2234
../src/FreeRTOS/queue.c:2234:9: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2234:9: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2234:9: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2234:9: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2200
../src/FreeRTOS/queue.c:2200:10: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2200:10: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2200:10: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2200:10: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2234
../src/FreeRTOS/queue.c:2234:9: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2234:9: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2234:9: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2234:9: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2200
../src/FreeRTOS/queue.c:2200:10: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2200:10: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2200:10: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2200:10: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2234
../src/FreeRTOS/queue.c:2234:9: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2234:9: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2234:9: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2234:9: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2200
../src/FreeRTOS/queue.c:2200:10: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2200:10: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2200:10: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2200:10: note: bad loop form.
../src/FreeRTOS/queue.c:1600:12: note: vectorized 0 loops in function.
xQueuePeek (void * xQueue, void * const pvBuffer, TickType_t xTicksToWait)
{
  int8_t cTxLock;
  int8_t cRxLock;
  int8_t cTxLock;
  int8_t cRxLock;
  int8_t cTxLock;
  int8_t cRxLock;
  BaseType_t xReturn;
  BaseType_t xReturn;
  const UBaseType_t uxMessagesWaiting;
  int8_t * pcOriginalReadPosition;
  struct TimeOut_t xTimeOut;
  BaseType_t xEntryTimeSet;
  long unsigned int _3;
  BaseType_t _5;
  long unsigned int _18;
  long int _21;
  long unsigned int xTicksToWait.18_22;
  long unsigned int xTicksToWait.18_26;
  signed char _31;
  signed char _33;
  long int _37;
  struct List_t * _44;
  long unsigned int xTicksToWait.18_45;
  long int _49;
  long unsigned int _55;
  struct List_t * _56;
  long int _58;
  long unsigned int _62;
  long unsigned int _64;
  long unsigned int _65;
  long unsigned int _72;
  int8_t * _74;
  int8_t * _75;
  int8_t * _76;
  long unsigned int _79;
  long unsigned int _80;
  long int _81;
  unsigned char cTxLock.4_83;
  unsigned char _84;
  long unsigned int _87;
  long int _89;
  unsigned char cRxLock.5_91;
  unsigned char _92;
  long unsigned int _95;
  long int _97;
  unsigned char cTxLock.4_99;
  unsigned char _100;
  long unsigned int _103;
  long int _105;
  unsigned char cRxLock.5_107;
  unsigned char _108;
  long unsigned int _111;
  long int _113;
  unsigned char cTxLock.4_115;
  unsigned char _116;
  long unsigned int _119;
  long int _121;
  unsigned char cRxLock.5_123;
  unsigned char _124;
  struct List_t * pretmp_129;
  long unsigned int _178;
  struct List_t * pretmp_181;
  struct List_t * pretmp_183;
  struct List_t * pretmp_184;
  long unsigned int _193;
  long unsigned int _196;
  struct List_t * pretmp_206;
  int8_t * prephitmp_208;

  <bb 2>:
  if (xQueue_14(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  R_OS_AssertCalled ("../src/FreeRTOS/queue.c", 1608);

  <bb 4>:
  if (pvBuffer_17(D) != 0B)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  _18 = MEM[(struct Queue_t *)xQueue_14(D)].uxItemSize;
  if (_18 == 0)
    goto <bb 6>;
  else
    goto <bb 77>;

  <bb 6>:
  _21 = xTaskGetSchedulerState ();
  if (_21 != 0)
    goto <bb 79>;
  else
    goto <bb 7>;

  <bb 7>:
  xTicksToWait.18_22 = xTicksToWait;
  if (xTicksToWait.18_22 == 0)
    goto <bb 79>;
  else
    goto <bb 78>;

  <bb 8>:

  <bb 9>:
  # xEntryTimeSet_1 = PHI <0(79), 1(8)>
  vPortEnterCritical ();
  uxMessagesWaiting_25 ={v} MEM[(struct Queue_t *)xQueue_14(D)].uxMessagesWaiting;
  if (uxMessagesWaiting_25 != 0)
    goto <bb 10>;
  else
    goto <bb 19>;

  <bb 10>:
  pcOriginalReadPosition_52 = MEM[(struct Queue_t *)xQueue_14(D)].u.pcReadFrom;
  _72 = MEM[(struct Queue_t *)xQueue_14(D)].uxItemSize;
  if (_72 != 0)
    goto <bb 11>;
  else
    goto <bb 14>;

  <bb 11>:
  _74 = pcOriginalReadPosition_52 + _72;
  MEM[(struct Queue_t *)xQueue_14(D)].u.pcReadFrom = _74;
  _75 = MEM[(struct Queue_t *)xQueue_14(D)].pcTail;
  if (_74 >= _75)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  _76 = MEM[(struct Queue_t *)xQueue_14(D)].pcHead;
  MEM[(struct Queue_t *)xQueue_14(D)].u.pcReadFrom = _76;

  <bb 13>:
  # prephitmp_208 = PHI <_74(11), _76(12)>
  memcpy (pvBuffer_17(D), prephitmp_208, _72);

  <bb 14>:
  MEM[(struct Queue_t *)xQueue_14(D)].u.pcReadFrom = pcOriginalReadPosition_52;
  _55 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_55 != 0)
    goto <bb 16>;
  else
    goto <bb 15>;

  <bb 15>:
  goto <bb 18>;

  <bb 16>:
  _56 = &MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive;
  _58 = xTaskRemoveFromEventList (_56);
  if (_58 != 0)
    goto <bb 17>;
  else
    goto <bb 15>;

  <bb 17>:
  __asm__ __volatile__("SWI 0" :  :  : "memory");

  <bb 18>:
  vPortExitCritical ();
  goto <bb 76>;

  <bb 19>:
  xTicksToWait.18_26 = xTicksToWait;
  if (xTicksToWait.18_26 == 0)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  vPortExitCritical ();
  goto <bb 76>;

  <bb 21>:
  if (xEntryTimeSet_1 == 0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  vTaskInternalSetTimeOutState (&xTimeOut);

  <bb 23>:
  vPortExitCritical ();
  vTaskSuspendAll ();
  vPortEnterCritical ();
  _31 ={v} MEM[(struct Queue_t *)xQueue_14(D)].cRxLock;
  if (_31 == -1)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  MEM[(struct Queue_t *)xQueue_14(D)].cRxLock ={v} 0;

  <bb 25>:
  _33 ={v} MEM[(struct Queue_t *)xQueue_14(D)].cTxLock;
  if (_33 == -1)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 26>:
  MEM[(struct Queue_t *)xQueue_14(D)].cTxLock ={v} 0;

  <bb 27>:
  vPortExitCritical ();
  _37 = xTaskCheckForTimeOut (&xTimeOut, &xTicksToWait);
  if (_37 == 0)
    goto <bb 28>;
  else
    goto <bb 59>;

  <bb 28>:
  vPortEnterCritical ();
  _62 ={v} MEM[(const struct Queue_t *)xQueue_14(D)].uxMessagesWaiting;
  if (_62 == 0)
    goto <bb 80>;
  else
    goto <bb 82>;

  <bb 29>:
  _79 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_79 != 0)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  goto <bb 33>;

  <bb 31>:
  MEM[(struct Queue_t *)xQueue_14(D)].cTxLock ={v} -1;
  vPortExitCritical ();
  vPortEnterCritical ();
  cRxLock_86 ={v} MEM[(struct Queue_t *)xQueue_14(D)].cRxLock;
  if (cRxLock_86 > 0)
    goto <bb 37>;
  else
    goto <bb 36>;

  <bb 32>:

  <bb 33>:
  # cTxLock_191 = PHI <cTxLock_78(32), cTxLock_85(30)>
  _81 = xTaskRemoveFromEventList (_44);
  if (_81 != 0)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 34>:
  vTaskMissedYield ();

  <bb 35>:
  cTxLock.4_83 = (unsigned char) cTxLock_191;
  _84 = cTxLock.4_83 + 255;
  cTxLock_85 = (int8_t) _84;
  if (cTxLock_85 > 0)
    goto <bb 29>;
  else
    goto <bb 31>;

  <bb 36>:
  MEM[(struct Queue_t *)xQueue_14(D)].cRxLock ={v} -1;
  vPortExitCritical ();
  _49 = xTaskResumeAll ();
  if (_49 == 0)
    goto <bb 44>;
  else
    goto <bb 8>;

  <bb 37>:
  _196 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_196 != 0)
    goto <bb 38>;
  else
    goto <bb 36>;

  <bb 38>:
  pretmp_206 = &MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend;
  goto <bb 41>;

  <bb 39>:
  _87 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_87 != 0)
    goto <bb 40>;
  else
    goto <bb 36>;

  <bb 40>:

  <bb 41>:
  # cRxLock_176 = PHI <cRxLock_86(38), cRxLock_93(40)>
  _89 = xTaskRemoveFromEventList (pretmp_206);
  if (_89 != 0)
    goto <bb 42>;
  else
    goto <bb 43>;

  <bb 42>:
  vTaskMissedYield ();

  <bb 43>:
  cRxLock.5_91 = (unsigned char) cRxLock_176;
  _92 = cRxLock.5_91 + 255;
  cRxLock_93 = (int8_t) _92;
  if (cRxLock_93 > 0)
    goto <bb 39>;
  else
    goto <bb 36>;

  <bb 44>:
  __asm__ __volatile__("SWI 0" :  :  : "memory");
  goto <bb 8>;

  <bb 45>:
  _95 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_95 != 0)
    goto <bb 47>;
  else
    goto <bb 46>;

  <bb 46>:
  MEM[(struct Queue_t *)xQueue_14(D)].cTxLock ={v} -1;
  vPortExitCritical ();
  vPortEnterCritical ();
  cRxLock_102 ={v} MEM[(struct Queue_t *)xQueue_14(D)].cRxLock;
  if (cRxLock_102 > 0)
    goto <bb 52>;
  else
    goto <bb 51>;

  <bb 47>:

  <bb 48>:
  # cTxLock_190 = PHI <cTxLock_94(84), cTxLock_101(47)>
  _97 = xTaskRemoveFromEventList (pretmp_184);
  if (_97 != 0)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  vTaskMissedYield ();

  <bb 50>:
  cTxLock.4_99 = (unsigned char) cTxLock_190;
  _100 = cTxLock.4_99 + 255;
  cTxLock_101 = (int8_t) _100;
  if (cTxLock_101 > 0)
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 51>:
  MEM[(struct Queue_t *)xQueue_14(D)].cRxLock ={v} -1;
  vPortExitCritical ();
  xTaskResumeAll ();
  goto <bb 8>;

  <bb 52>:
  _80 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_80 != 0)
    goto <bb 53>;
  else
    goto <bb 51>;

  <bb 53>:
  pretmp_183 = &MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend;
  goto <bb 56>;

  <bb 54>:
  _103 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_103 != 0)
    goto <bb 55>;
  else
    goto <bb 51>;

  <bb 55>:

  <bb 56>:
  # cRxLock_175 = PHI <cRxLock_102(53), cRxLock_109(55)>
  _105 = xTaskRemoveFromEventList (pretmp_183);
  if (_105 != 0)
    goto <bb 57>;
  else
    goto <bb 58>;

  <bb 57>:
  vTaskMissedYield ();

  <bb 58>:
  cRxLock.5_107 = (unsigned char) cRxLock_175;
  _108 = cRxLock.5_107 + 255;
  cRxLock_109 = (int8_t) _108;
  if (cRxLock_109 > 0)
    goto <bb 54>;
  else
    goto <bb 51>;

  <bb 59>:
  vPortEnterCritical ();
  cTxLock_110 ={v} MEM[(struct Queue_t *)xQueue_14(D)].cTxLock;
  if (cTxLock_110 > 0)
    goto <bb 61>;
  else
    goto <bb 60>;

  <bb 60>:
  MEM[(struct Queue_t *)xQueue_14(D)].cTxLock ={v} -1;
  vPortExitCritical ();
  vPortEnterCritical ();
  cRxLock_118 ={v} MEM[(struct Queue_t *)xQueue_14(D)].cRxLock;
  if (cRxLock_118 > 0)
    goto <bb 69>;
  else
    goto <bb 68>;

  <bb 61>:
  _178 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_178 != 0)
    goto <bb 62>;
  else
    goto <bb 60>;

  <bb 62>:
  pretmp_181 = &MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive;
  goto <bb 65>;

  <bb 63>:
  _111 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_111 != 0)
    goto <bb 64>;
  else
    goto <bb 60>;

  <bb 64>:

  <bb 65>:
  # cTxLock_189 = PHI <cTxLock_110(62), cTxLock_117(64)>
  _113 = xTaskRemoveFromEventList (pretmp_181);
  if (_113 != 0)
    goto <bb 66>;
  else
    goto <bb 67>;

  <bb 66>:
  vTaskMissedYield ();

  <bb 67>:
  cTxLock.4_115 = (unsigned char) cTxLock_189;
  _116 = cTxLock.4_115 + 255;
  cTxLock_117 = (int8_t) _116;
  if (cTxLock_117 > 0)
    goto <bb 63>;
  else
    goto <bb 60>;

  <bb 68>:
  MEM[(struct Queue_t *)xQueue_14(D)].cRxLock ={v} -1;
  vPortExitCritical ();
  xTaskResumeAll ();
  vPortEnterCritical ();
  _64 ={v} MEM[(const struct Queue_t *)xQueue_14(D)].uxMessagesWaiting;
  if (_64 == 0)
    goto <bb 20>;
  else
    goto <bb 85>;

  <bb 69>:
  _3 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_3 != 0)
    goto <bb 70>;
  else
    goto <bb 68>;

  <bb 70>:
  pretmp_129 = &MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend;
  goto <bb 73>;

  <bb 71>:
  _119 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_119 != 0)
    goto <bb 72>;
  else
    goto <bb 68>;

  <bb 72>:

  <bb 73>:
  # cRxLock_174 = PHI <cRxLock_118(70), cRxLock_125(72)>
  _121 = xTaskRemoveFromEventList (pretmp_129);
  if (_121 != 0)
    goto <bb 74>;
  else
    goto <bb 75>;

  <bb 74>:
  vTaskMissedYield ();

  <bb 75>:
  cRxLock.5_123 = (unsigned char) cRxLock_174;
  _124 = cRxLock.5_123 + 255;
  cRxLock_125 = (int8_t) _124;
  if (cRxLock_125 > 0)
    goto <bb 71>;
  else
    goto <bb 68>;

  <bb 76>:
  # _5 = PHI <1(18), 0(20)>
  xTimeOut ={v} {CLOBBER};
  return _5;

  <bb 77>:
  R_OS_AssertCalled ("../src/FreeRTOS/queue.c", 1612);
  goto <bb 6>;

  <bb 78>:
  R_OS_AssertCalled ("../src/FreeRTOS/queue.c", 1617);

  <bb 79>:
  goto <bb 9>;

  <bb 80>:
  vPortExitCritical ();
  _44 = &MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive;
  xTicksToWait.18_45 = xTicksToWait;
  vTaskPlaceOnEventList (_44, xTicksToWait.18_45);
  vPortEnterCritical ();
  cTxLock_78 ={v} MEM[(struct Queue_t *)xQueue_14(D)].cTxLock;
  if (cTxLock_78 > 0)
    goto <bb 81>;
  else
    goto <bb 31>;

  <bb 81>:
  _193 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_193 != 0)
    goto <bb 32>;
  else
    goto <bb 31>;

  <bb 82>:
  vPortExitCritical ();
  vPortEnterCritical ();
  cTxLock_94 ={v} MEM[(struct Queue_t *)xQueue_14(D)].cTxLock;
  if (cTxLock_94 > 0)
    goto <bb 83>;
  else
    goto <bb 46>;

  <bb 83>:
  _65 ={v} MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_65 != 0)
    goto <bb 84>;
  else
    goto <bb 46>;

  <bb 84>:
  pretmp_184 = &MEM[(struct Queue_t *)xQueue_14(D)].xTasksWaitingToReceive;
  goto <bb 48>;

  <bb 85>:
  vPortExitCritical ();
  goto <bb 8>;

}



;; Function vQueueDelete (vQueueDelete, funcdef_no=21, decl_uid=6984, cgraph_uid=21, symbol_order=22)


Analyzing loop at ../src/FreeRTOS/queue.c:2677
../src/FreeRTOS/queue.c:2677:28: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2677:28: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2677:28: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2677:28: note: bad loop form.
../src/FreeRTOS/queue.c:1941:6: note: vectorized 0 loops in function.
vQueueDelete (void * xQueue)
{
  UBaseType_t ux;
  long unsigned int ivtmp_6;
  void * _7;
  long unsigned int ivtmp_12;

  <bb 2>:
  if (xQueue_2(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  R_OS_AssertCalled ("../src/FreeRTOS/queue.c", 1945);

  <bb 4>:

  <bb 5>:
  # ux_18 = PHI <ux_8(8), 0(4)>
  # ivtmp_6 = PHI <ivtmp_12(8), 8(4)>
  _7 = xQueueRegistry[ux_18].xHandle;
  if (xQueue_2(D) == _7)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  # ux_17 = PHI <ux_18(5)>
  xQueueRegistry[ux_17].pcQueueName = 0B;
  xQueueRegistry[ux_17].xHandle = 0B;
  goto <bb 9>;

  <bb 7>:
  ux_8 = ux_18 + 1;
  ivtmp_12 = ivtmp_6 - 1;
  if (ivtmp_12 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  goto <bb 5>;

  <bb 9>:
  vPortFree (xQueue_2(D));
  return;

}



;; Function vQueueAddToRegistry (vQueueAddToRegistry, funcdef_no=33, decl_uid=7045, cgraph_uid=33, symbol_order=34)


Analyzing loop at ../src/FreeRTOS/queue.c:2620
../src/FreeRTOS/queue.c:2620:28: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2620:28: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2620:28: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2620:28: note: bad loop form.
../src/FreeRTOS/queue.c:2612:7: note: vectorized 0 loops in function.
vQueueAddToRegistry (void * xQueue, const char * pcQueueName)
{
  UBaseType_t ux;
  long unsigned int ivtmp_1;
  const char * _4;
  long unsigned int ivtmp_10;

  <bb 2>:

  <bb 3>:
  # ux_13 = PHI <ux_5(6), 0(2)>
  # ivtmp_1 = PHI <ivtmp_10(6), 8(2)>
  _4 = xQueueRegistry[ux_13].pcQueueName;
  if (_4 == 0B)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  # ux_12 = PHI <ux_13(3)>
  xQueueRegistry[ux_12].pcQueueName = pcQueueName_6(D);
  xQueueRegistry[ux_12].xHandle = xQueue_8(D);
  goto <bb 7>;

  <bb 5>:
  ux_5 = ux_13 + 1;
  ivtmp_10 = ivtmp_1 - 1;
  if (ivtmp_10 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  goto <bb 3>;

  <bb 7>:
  return;

}



;; Function pcQueueGetName (pcQueueGetName, funcdef_no=34, decl_uid=7049, cgraph_uid=34, symbol_order=35)


Analyzing loop at ../src/FreeRTOS/queue.c:2650
../src/FreeRTOS/queue.c:2650:28: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2650:28: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2650:28: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2650:28: note: bad loop form.
../src/FreeRTOS/queue.c:2641:14: note: vectorized 0 loops in function.
pcQueueGetName (void * xQueue)
{
  const char * pcReturn;
  UBaseType_t ux;
  long unsigned int ivtmp_1;
  void * _4;
  long unsigned int ivtmp_8;

  <bb 2>:

  <bb 3>:
  # ux_11 = PHI <ux_6(6), 0(2)>
  # ivtmp_1 = PHI <ivtmp_8(6), 8(2)>
  _4 = xQueueRegistry[ux_11].xHandle;
  if (_4 == xQueue_5(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  # ux_10 = PHI <ux_11(3)>
  pcReturn_7 = xQueueRegistry[ux_10].pcQueueName;
  goto <bb 7>;

  <bb 5>:
  ux_6 = ux_11 + 1;
  ivtmp_8 = ivtmp_1 - 1;
  if (ivtmp_8 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  goto <bb 3>;

  <bb 7>:
  # pcReturn_2 = PHI <pcReturn_7(4), 0B(5)>
  return pcReturn_2;

}



;; Function vQueueUnregisterQueue (vQueueUnregisterQueue, funcdef_no=35, decl_uid=7047, cgraph_uid=35, symbol_order=36)


Analyzing loop at ../src/FreeRTOS/queue.c:2677
../src/FreeRTOS/queue.c:2677:28: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2677:28: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2677:28: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2677:28: note: bad loop form.
../src/FreeRTOS/queue.c:2669:7: note: vectorized 0 loops in function.
vQueueUnregisterQueue (void * xQueue)
{
  UBaseType_t ux;
  long unsigned int ivtmp_1;
  void * _4;
  long unsigned int ivtmp_9;

  <bb 2>:

  <bb 3>:
  # ux_12 = PHI <ux_6(6), 0(2)>
  # ivtmp_1 = PHI <ivtmp_9(6), 8(2)>
  _4 = xQueueRegistry[ux_12].xHandle;
  if (_4 == xQueue_5(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  # ux_11 = PHI <ux_12(3)>
  xQueueRegistry[ux_11].pcQueueName = 0B;
  xQueueRegistry[ux_11].xHandle = 0B;
  goto <bb 7>;

  <bb 5>:
  ux_6 = ux_12 + 1;
  ivtmp_9 = ivtmp_1 - 1;
  if (ivtmp_9 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  goto <bb 3>;

  <bb 7>:
  return;

}



;; Function vQueueWaitForMessageRestricted (vQueueWaitForMessageRestricted, funcdef_no=36, decl_uid=7070, cgraph_uid=36, symbol_order=37)


Analyzing loop at ../src/FreeRTOS/queue.c:2234
../src/FreeRTOS/queue.c:2234:9: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2234:9: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2234:9: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2234:9: note: bad loop form.

Analyzing loop at ../src/FreeRTOS/queue.c:2200
../src/FreeRTOS/queue.c:2200:10: note: ===== analyze_loop_nest =====
../src/FreeRTOS/queue.c:2200:10: note: === vect_analyze_loop_form ===
../src/FreeRTOS/queue.c:2200:10: note: not vectorized: control flow in loop.
../src/FreeRTOS/queue.c:2200:10: note: bad loop form.
../src/FreeRTOS/queue.c:2701:7: note: vectorized 0 loops in function.
vQueueWaitForMessageRestricted (void * xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)
{
  int8_t cTxLock;
  int8_t cRxLock;
  signed char _7;
  signed char _9;
  long unsigned int _12;
  struct List_t * _13;
  long unsigned int _17;
  long unsigned int _19;
  long int _21;
  unsigned char cTxLock.4_23;
  unsigned char _24;
  long unsigned int _27;
  long int _29;
  unsigned char cRxLock.5_31;
  unsigned char _32;
  long unsigned int _51;
  struct List_t * pretmp_59;
  struct List_t * pretmp_61;

  <bb 2>:
  vPortEnterCritical ();
  _7 ={v} MEM[(struct Queue_t *)xQueue_4(D)].cRxLock;
  if (_7 == -1)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  MEM[(struct Queue_t *)xQueue_4(D)].cRxLock ={v} 0;

  <bb 4>:
  _9 ={v} MEM[(struct Queue_t *)xQueue_4(D)].cTxLock;
  if (_9 == -1)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  MEM[(struct Queue_t *)xQueue_4(D)].cTxLock ={v} 0;

  <bb 6>:
  vPortExitCritical ();
  _12 ={v} MEM[(struct Queue_t *)xQueue_4(D)].uxMessagesWaiting;
  if (_12 == 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _13 = &MEM[(struct Queue_t *)xQueue_4(D)].xTasksWaitingToReceive;
  vTaskPlaceOnEventListRestricted (_13, xTicksToWait_14(D), xWaitIndefinitely_15(D));

  <bb 8>:
  vPortEnterCritical ();
  cTxLock_18 ={v} MEM[(struct Queue_t *)xQueue_4(D)].cTxLock;
  if (cTxLock_18 > 0)
    goto <bb 10>;
  else
    goto <bb 9>;

  <bb 9>:
  MEM[(struct Queue_t *)xQueue_4(D)].cTxLock ={v} -1;
  vPortExitCritical ();
  vPortEnterCritical ();
  cRxLock_26 ={v} MEM[(struct Queue_t *)xQueue_4(D)].cRxLock;
  if (cRxLock_26 > 0)
    goto <bb 18>;
  else
    goto <bb 17>;

  <bb 10>:
  _17 ={v} MEM[(struct Queue_t *)xQueue_4(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_17 != 0)
    goto <bb 11>;
  else
    goto <bb 9>;

  <bb 11>:
  pretmp_61 = &MEM[(struct Queue_t *)xQueue_4(D)].xTasksWaitingToReceive;
  goto <bb 14>;

  <bb 12>:
  _19 ={v} MEM[(struct Queue_t *)xQueue_4(D)].xTasksWaitingToReceive.uxNumberOfItems;
  if (_19 != 0)
    goto <bb 13>;
  else
    goto <bb 9>;

  <bb 13>:

  <bb 14>:
  # cTxLock_53 = PHI <cTxLock_18(11), cTxLock_25(13)>
  _21 = xTaskRemoveFromEventList (pretmp_61);
  if (_21 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  vTaskMissedYield ();

  <bb 16>:
  cTxLock.4_23 = (unsigned char) cTxLock_53;
  _24 = cTxLock.4_23 + 255;
  cTxLock_25 = (int8_t) _24;
  if (cTxLock_25 > 0)
    goto <bb 12>;
  else
    goto <bb 9>;

  <bb 17>:
  MEM[(struct Queue_t *)xQueue_4(D)].cRxLock ={v} -1;
  vPortExitCritical ();
  return;

  <bb 18>:
  _51 ={v} MEM[(struct Queue_t *)xQueue_4(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_51 != 0)
    goto <bb 19>;
  else
    goto <bb 17>;

  <bb 19>:
  pretmp_59 = &MEM[(struct Queue_t *)xQueue_4(D)].xTasksWaitingToSend;
  goto <bb 22>;

  <bb 20>:
  _27 ={v} MEM[(struct Queue_t *)xQueue_4(D)].xTasksWaitingToSend.uxNumberOfItems;
  if (_27 != 0)
    goto <bb 21>;
  else
    goto <bb 17>;

  <bb 21>:

  <bb 22>:
  # cRxLock_54 = PHI <cRxLock_26(19), cRxLock_33(21)>
  _29 = xTaskRemoveFromEventList (pretmp_59);
  if (_29 != 0)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  vTaskMissedYield ();

  <bb 24>:
  cRxLock.5_31 = (unsigned char) cRxLock_54;
  _32 = cRxLock.5_31 + 255;
  cRxLock_33 = (int8_t) _32;
  if (cRxLock_33 > 0)
    goto <bb 20>;
  else
    goto <bb 17>;

}


