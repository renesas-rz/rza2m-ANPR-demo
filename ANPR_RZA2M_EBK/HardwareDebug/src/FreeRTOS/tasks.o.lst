   1              		.cpu cortex-a9
   2              		.eabi_attribute 28, 1
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"tasks.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.section	.text.prvTaskCheckFreeStackSpace,"ax",%progbits
  17              		.align	2
  18              		.syntax unified
  19              		.arm
  20              		.fpu neon
  22              	prvTaskCheckFreeStackSpace:
  23              	.LFB47:
  24              		.file 1 "../src/FreeRTOS/tasks.c"
   1:../src/FreeRTOS/tasks.c **** /*
   2:../src/FreeRTOS/tasks.c ****  * FreeRTOS Kernel V10.0.1
   3:../src/FreeRTOS/tasks.c ****  * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../src/FreeRTOS/tasks.c ****  *
   5:../src/FreeRTOS/tasks.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../src/FreeRTOS/tasks.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:../src/FreeRTOS/tasks.c ****  * the Software without restriction, including without limitation the rights to
   8:../src/FreeRTOS/tasks.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../src/FreeRTOS/tasks.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../src/FreeRTOS/tasks.c ****  * subject to the following conditions:
  11:../src/FreeRTOS/tasks.c ****  *
  12:../src/FreeRTOS/tasks.c ****  * The above copyright notice and this permission notice shall be included in all
  13:../src/FreeRTOS/tasks.c ****  * copies or substantial portions of the Software.
  14:../src/FreeRTOS/tasks.c ****  *
  15:../src/FreeRTOS/tasks.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../src/FreeRTOS/tasks.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../src/FreeRTOS/tasks.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../src/FreeRTOS/tasks.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../src/FreeRTOS/tasks.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../src/FreeRTOS/tasks.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../src/FreeRTOS/tasks.c ****  *
  22:../src/FreeRTOS/tasks.c ****  * http://www.FreeRTOS.org
  23:../src/FreeRTOS/tasks.c ****  * http://aws.amazon.com/freertos
  24:../src/FreeRTOS/tasks.c ****  *
  25:../src/FreeRTOS/tasks.c ****  * 1 tab == 4 spaces!
  26:../src/FreeRTOS/tasks.c ****  */
  27:../src/FreeRTOS/tasks.c **** 
  28:../src/FreeRTOS/tasks.c **** /* Standard includes. */
  29:../src/FreeRTOS/tasks.c **** #include <stdlib.h>
  30:../src/FreeRTOS/tasks.c **** #include <string.h>
  31:../src/FreeRTOS/tasks.c **** 
  32:../src/FreeRTOS/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  33:../src/FreeRTOS/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  34:../src/FreeRTOS/tasks.c **** task.h is included from an application file. */
  35:../src/FreeRTOS/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  36:../src/FreeRTOS/tasks.c **** 
  37:../src/FreeRTOS/tasks.c **** /* FreeRTOS includes. */
  38:../src/FreeRTOS/tasks.c **** #include "FreeRTOS.h"
  39:../src/FreeRTOS/tasks.c **** #include "task.h"
  40:../src/FreeRTOS/tasks.c **** #include "timers.h"
  41:../src/FreeRTOS/tasks.c **** #include "stack_macros.h"
  42:../src/FreeRTOS/tasks.c **** 
  43:../src/FreeRTOS/tasks.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  44:../src/FreeRTOS/tasks.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  45:../src/FreeRTOS/tasks.c **** header files above, but not in this file, in order to generate the correct
  46:../src/FreeRTOS/tasks.c **** privileged Vs unprivileged linkage and placement. */
  47:../src/FreeRTOS/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  48:../src/FreeRTOS/tasks.c **** 
  49:../src/FreeRTOS/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  50:../src/FreeRTOS/tasks.c **** functions but without including stdio.h here. */
  51:../src/FreeRTOS/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  52:../src/FreeRTOS/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  53:../src/FreeRTOS/tasks.c **** 	to generate human readable text from the raw data generated by the
  54:../src/FreeRTOS/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  55:../src/FreeRTOS/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  56:../src/FreeRTOS/tasks.c **** 	#include <stdio.h>
  57:../src/FreeRTOS/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  58:../src/FreeRTOS/tasks.c **** 
  59:../src/FreeRTOS/tasks.c **** #if( configUSE_PREEMPTION == 0 )
  60:../src/FreeRTOS/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  61:../src/FreeRTOS/tasks.c **** 	performed just because a higher priority task has been woken. */
  62:../src/FreeRTOS/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
  63:../src/FreeRTOS/tasks.c **** #else
  64:../src/FreeRTOS/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  65:../src/FreeRTOS/tasks.c **** #endif
  66:../src/FreeRTOS/tasks.c **** 
  67:../src/FreeRTOS/tasks.c **** /* Values that can be assigned to the ucNotifyState member of the TCB. */
  68:../src/FreeRTOS/tasks.c **** #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
  69:../src/FreeRTOS/tasks.c **** #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
  70:../src/FreeRTOS/tasks.c **** #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
  71:../src/FreeRTOS/tasks.c **** 
  72:../src/FreeRTOS/tasks.c **** /*
  73:../src/FreeRTOS/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
  74:../src/FreeRTOS/tasks.c ****  * is used purely for checking the high water mark for tasks.
  75:../src/FreeRTOS/tasks.c ****  */
  76:../src/FreeRTOS/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
  77:../src/FreeRTOS/tasks.c **** 
  78:../src/FreeRTOS/tasks.c **** /* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
  79:../src/FreeRTOS/tasks.c **** dynamically allocated RAM, in which case when any task is deleted it is known
  80:../src/FreeRTOS/tasks.c **** that both the task's stack and TCB need to be freed.  Sometimes the
  81:../src/FreeRTOS/tasks.c **** FreeRTOSConfig.h settings only allow a task to be created using statically
  82:../src/FreeRTOS/tasks.c **** allocated RAM, in which case when any task is deleted it is known that neither
  83:../src/FreeRTOS/tasks.c **** the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
  84:../src/FreeRTOS/tasks.c **** settings allow a task to be created using either statically or dynamically
  85:../src/FreeRTOS/tasks.c **** allocated RAM, in which case a member of the TCB is used to record whether the
  86:../src/FreeRTOS/tasks.c **** stack and/or TCB were allocated statically or dynamically, so when a task is
  87:../src/FreeRTOS/tasks.c **** deleted the RAM that was allocated dynamically is freed again and no attempt is
  88:../src/FreeRTOS/tasks.c **** made to free the RAM that was allocated statically.
  89:../src/FreeRTOS/tasks.c **** tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
  90:../src/FreeRTOS/tasks.c **** task to be created using either statically or dynamically allocated RAM.  Note
  91:../src/FreeRTOS/tasks.c **** that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
  92:../src/FreeRTOS/tasks.c **** a statically allocated stack and a dynamically allocated TCB.
  93:../src/FreeRTOS/tasks.c **** !!!NOTE!!! If the definition of tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is
  94:../src/FreeRTOS/tasks.c **** changed then the definition of StaticTask_t must also be updated. */
  95:../src/FreeRTOS/tasks.c **** #define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE	( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( c
  96:../src/FreeRTOS/tasks.c **** #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
  97:../src/FreeRTOS/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
  98:../src/FreeRTOS/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
  99:../src/FreeRTOS/tasks.c **** 
 100:../src/FreeRTOS/tasks.c **** /* If any of the following are set then task stacks are filled with a known
 101:../src/FreeRTOS/tasks.c **** value so the high water mark can be determined.  If none of the following are
 102:../src/FreeRTOS/tasks.c **** set then don't fill the stack so there is no unnecessary dependency on memset. */
 103:../src/FreeRTOS/tasks.c **** #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTas
 104:../src/FreeRTOS/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	1
 105:../src/FreeRTOS/tasks.c **** #else
 106:../src/FreeRTOS/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	0
 107:../src/FreeRTOS/tasks.c **** #endif
 108:../src/FreeRTOS/tasks.c **** 
 109:../src/FreeRTOS/tasks.c **** /*
 110:../src/FreeRTOS/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 111:../src/FreeRTOS/tasks.c ****  */
 112:../src/FreeRTOS/tasks.c **** #define tskRUNNING_CHAR		( 'X' )
 113:../src/FreeRTOS/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
 114:../src/FreeRTOS/tasks.c **** #define tskREADY_CHAR		( 'R' )
 115:../src/FreeRTOS/tasks.c **** #define tskDELETED_CHAR		( 'D' )
 116:../src/FreeRTOS/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 117:../src/FreeRTOS/tasks.c **** 
 118:../src/FreeRTOS/tasks.c **** /*
 119:../src/FreeRTOS/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to be
 120:../src/FreeRTOS/tasks.c ****  * global, rather than file scope.
 121:../src/FreeRTOS/tasks.c ****  */
 122:../src/FreeRTOS/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 123:../src/FreeRTOS/tasks.c **** 	#define static
 124:../src/FreeRTOS/tasks.c **** #endif
 125:../src/FreeRTOS/tasks.c **** 
 126:../src/FreeRTOS/tasks.c **** /* The name allocated to the Idle task.  This can be overridden by defining
 127:../src/FreeRTOS/tasks.c **** configIDLE_TASK_NAME in FreeRTOSConfig.h. */
 128:../src/FreeRTOS/tasks.c **** #ifndef configIDLE_TASK_NAME
 129:../src/FreeRTOS/tasks.c **** 	#define configIDLE_TASK_NAME "IDLE"
 130:../src/FreeRTOS/tasks.c **** #endif
 131:../src/FreeRTOS/tasks.c **** 
 132:../src/FreeRTOS/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 133:../src/FreeRTOS/tasks.c **** 
 134:../src/FreeRTOS/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 135:../src/FreeRTOS/tasks.c **** 	performed in a generic way that is not optimised to any particular
 136:../src/FreeRTOS/tasks.c **** 	microcontroller architecture. */
 137:../src/FreeRTOS/tasks.c **** 
 138:../src/FreeRTOS/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 139:../src/FreeRTOS/tasks.c **** 	state task. */
 140:../src/FreeRTOS/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 141:../src/FreeRTOS/tasks.c **** 	{																									\
 142:../src/FreeRTOS/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 143:../src/FreeRTOS/tasks.c **** 		{																								\
 144:../src/FreeRTOS/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 145:../src/FreeRTOS/tasks.c **** 		}																								\
 146:../src/FreeRTOS/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 147:../src/FreeRTOS/tasks.c **** 
 148:../src/FreeRTOS/tasks.c **** 	/*-----------------------------------------------------------*/
 149:../src/FreeRTOS/tasks.c **** 
 150:../src/FreeRTOS/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 151:../src/FreeRTOS/tasks.c **** 	{																									\
 152:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
 153:../src/FreeRTOS/tasks.c **** 																										\
 154:../src/FreeRTOS/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 155:../src/FreeRTOS/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
 156:../src/FreeRTOS/tasks.c **** 		{																								\
 157:../src/FreeRTOS/tasks.c **** 			configASSERT( uxTopPriority );																\
 158:../src/FreeRTOS/tasks.c **** 			--uxTopPriority;																			\
 159:../src/FreeRTOS/tasks.c **** 		}																								\
 160:../src/FreeRTOS/tasks.c **** 																										\
 161:../src/FreeRTOS/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 162:../src/FreeRTOS/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 163:../src/FreeRTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
 164:../src/FreeRTOS/tasks.c **** 		uxTopReadyPriority = uxTopPriority;																\
 165:../src/FreeRTOS/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 166:../src/FreeRTOS/tasks.c **** 
 167:../src/FreeRTOS/tasks.c **** 	/*-----------------------------------------------------------*/
 168:../src/FreeRTOS/tasks.c **** 
 169:../src/FreeRTOS/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 170:../src/FreeRTOS/tasks.c **** 	they are only required when a port optimised method of task selection is
 171:../src/FreeRTOS/tasks.c **** 	being used. */
 172:../src/FreeRTOS/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 173:../src/FreeRTOS/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 174:../src/FreeRTOS/tasks.c **** 
 175:../src/FreeRTOS/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 176:../src/FreeRTOS/tasks.c **** 
 177:../src/FreeRTOS/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 178:../src/FreeRTOS/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 179:../src/FreeRTOS/tasks.c **** 	architecture being used. */
 180:../src/FreeRTOS/tasks.c **** 
 181:../src/FreeRTOS/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 182:../src/FreeRTOS/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 183:../src/FreeRTOS/tasks.c **** 
 184:../src/FreeRTOS/tasks.c **** 	/*-----------------------------------------------------------*/
 185:../src/FreeRTOS/tasks.c **** 
 186:../src/FreeRTOS/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 187:../src/FreeRTOS/tasks.c **** 	{																								\
 188:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 189:../src/FreeRTOS/tasks.c **** 																									\
 190:../src/FreeRTOS/tasks.c **** 		/* Find the highest priority list that contains ready tasks. */								\
 191:../src/FreeRTOS/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 192:../src/FreeRTOS/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 193:../src/FreeRTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 194:../src/FreeRTOS/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 195:../src/FreeRTOS/tasks.c **** 
 196:../src/FreeRTOS/tasks.c **** 	/*-----------------------------------------------------------*/
 197:../src/FreeRTOS/tasks.c **** 
 198:../src/FreeRTOS/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 199:../src/FreeRTOS/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 200:../src/FreeRTOS/tasks.c **** 	or suspended list then it won't be in a ready list. */
 201:../src/FreeRTOS/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )														\
 202:../src/FreeRTOS/tasks.c **** 	{																									\
 203:../src/FreeRTOS/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
 204:../src/FreeRTOS/tasks.c **** 		{																								\
 205:../src/FreeRTOS/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
 206:../src/FreeRTOS/tasks.c **** 		}																								\
 207:../src/FreeRTOS/tasks.c **** 	}
 208:../src/FreeRTOS/tasks.c **** 
 209:../src/FreeRTOS/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 210:../src/FreeRTOS/tasks.c **** 
 211:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 212:../src/FreeRTOS/tasks.c **** 
 213:../src/FreeRTOS/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 214:../src/FreeRTOS/tasks.c **** count overflows. */
 215:../src/FreeRTOS/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 216:../src/FreeRTOS/tasks.c **** {																									\
 217:../src/FreeRTOS/tasks.c **** 	List_t *pxTemp;																					\
 218:../src/FreeRTOS/tasks.c **** 																									\
 219:../src/FreeRTOS/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 220:../src/FreeRTOS/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 221:../src/FreeRTOS/tasks.c **** 																									\
 222:../src/FreeRTOS/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 223:../src/FreeRTOS/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 224:../src/FreeRTOS/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 225:../src/FreeRTOS/tasks.c **** 	xNumOfOverflows++;																				\
 226:../src/FreeRTOS/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 227:../src/FreeRTOS/tasks.c **** }
 228:../src/FreeRTOS/tasks.c **** 
 229:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 230:../src/FreeRTOS/tasks.c **** 
 231:../src/FreeRTOS/tasks.c **** /*
 232:../src/FreeRTOS/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 233:../src/FreeRTOS/tasks.c ****  * the task.  It is inserted at the end of the list.
 234:../src/FreeRTOS/tasks.c ****  */
 235:../src/FreeRTOS/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 236:../src/FreeRTOS/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
 237:../src/FreeRTOS/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 238:../src/FreeRTOS/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) );
 239:../src/FreeRTOS/tasks.c **** 	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
 240:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 241:../src/FreeRTOS/tasks.c **** 
 242:../src/FreeRTOS/tasks.c **** /*
 243:../src/FreeRTOS/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 244:../src/FreeRTOS/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 245:../src/FreeRTOS/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 246:../src/FreeRTOS/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 247:../src/FreeRTOS/tasks.c ****  */
 248:../src/FreeRTOS/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( T
 249:../src/FreeRTOS/tasks.c **** 
 250:../src/FreeRTOS/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 251:../src/FreeRTOS/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 252:../src/FreeRTOS/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 253:../src/FreeRTOS/tasks.c **** is important its value is not updated due to a task priority change while it is
 254:../src/FreeRTOS/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 255:../src/FreeRTOS/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 256:../src/FreeRTOS/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 257:../src/FreeRTOS/tasks.c **** to its original value when it is released. */
 258:../src/FreeRTOS/tasks.c **** #if( configUSE_16_BIT_TICKS == 1 )
 259:../src/FreeRTOS/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 260:../src/FreeRTOS/tasks.c **** #else
 261:../src/FreeRTOS/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 262:../src/FreeRTOS/tasks.c **** #endif
 263:../src/FreeRTOS/tasks.c **** 
 264:../src/FreeRTOS/tasks.c **** /*
 265:../src/FreeRTOS/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 266:../src/FreeRTOS/tasks.c ****  * and stores task state information, including a pointer to the task's context
 267:../src/FreeRTOS/tasks.c ****  * (the task's run time environment, including register values)
 268:../src/FreeRTOS/tasks.c ****  */
 269:../src/FreeRTOS/tasks.c **** typedef struct tskTaskControlBlock
 270:../src/FreeRTOS/tasks.c **** {
 271:../src/FreeRTOS/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 272:../src/FreeRTOS/tasks.c **** 
 273:../src/FreeRTOS/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 274:../src/FreeRTOS/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 275:../src/FreeRTOS/tasks.c **** 	#endif
 276:../src/FreeRTOS/tasks.c **** 
 277:../src/FreeRTOS/tasks.c **** 	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from den
 278:../src/FreeRTOS/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 279:../src/FreeRTOS/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 280:../src/FreeRTOS/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 281:../src/FreeRTOS/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 282:../src/FreeRTOS/tasks.c **** 
 283:../src/FreeRTOS/tasks.c **** 	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
 284:../src/FreeRTOS/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the highest valid address for the stack. */
 285:../src/FreeRTOS/tasks.c **** 	#endif
 286:../src/FreeRTOS/tasks.c **** 
 287:../src/FreeRTOS/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 288:../src/FreeRTOS/tasks.c **** 		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do no
 289:../src/FreeRTOS/tasks.c **** 	#endif
 290:../src/FreeRTOS/tasks.c **** 
 291:../src/FreeRTOS/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 292:../src/FreeRTOS/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 293:../src/FreeRTOS/tasks.c **** 		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. *
 294:../src/FreeRTOS/tasks.c **** 	#endif
 295:../src/FreeRTOS/tasks.c **** 
 296:../src/FreeRTOS/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 297:../src/FreeRTOS/tasks.c **** 		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 298:../src/FreeRTOS/tasks.c **** 		UBaseType_t		uxMutexesHeld;
 299:../src/FreeRTOS/tasks.c **** 	#endif
 300:../src/FreeRTOS/tasks.c **** 
 301:../src/FreeRTOS/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 302:../src/FreeRTOS/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 303:../src/FreeRTOS/tasks.c **** 	#endif
 304:../src/FreeRTOS/tasks.c **** 
 305:../src/FreeRTOS/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 306:../src/FreeRTOS/tasks.c **** 		void			*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 307:../src/FreeRTOS/tasks.c **** 	#endif
 308:../src/FreeRTOS/tasks.c **** 
 309:../src/FreeRTOS/tasks.c **** 	#if( configGENERATE_RUN_TIME_STATS == 1 )
 310:../src/FreeRTOS/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 311:../src/FreeRTOS/tasks.c **** 	#endif
 312:../src/FreeRTOS/tasks.c **** 
 313:../src/FreeRTOS/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 314:../src/FreeRTOS/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 315:../src/FreeRTOS/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 316:../src/FreeRTOS/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 317:../src/FreeRTOS/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 318:../src/FreeRTOS/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 319:../src/FreeRTOS/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 320:../src/FreeRTOS/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 321:../src/FreeRTOS/tasks.c **** 		struct	_reent xNewLib_reent;
 322:../src/FreeRTOS/tasks.c **** 	#endif
 323:../src/FreeRTOS/tasks.c **** 
 324:../src/FreeRTOS/tasks.c **** 	#if( configUSE_TASK_NOTIFICATIONS == 1 )
 325:../src/FreeRTOS/tasks.c **** 		volatile uint32_t ulNotifiedValue;
 326:../src/FreeRTOS/tasks.c **** 		volatile uint8_t ucNotifyState;
 327:../src/FreeRTOS/tasks.c **** 	#endif
 328:../src/FreeRTOS/tasks.c **** 
 329:../src/FreeRTOS/tasks.c **** 	/* See the comments above the definition of
 330:../src/FreeRTOS/tasks.c **** 	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
 331:../src/FreeRTOS/tasks.c **** 	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for
 332:../src/FreeRTOS/tasks.c **** 		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensur
 333:../src/FreeRTOS/tasks.c **** 	#endif
 334:../src/FreeRTOS/tasks.c **** 
 335:../src/FreeRTOS/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 336:../src/FreeRTOS/tasks.c **** 		uint8_t ucDelayAborted;
 337:../src/FreeRTOS/tasks.c **** 	#endif
 338:../src/FreeRTOS/tasks.c **** 
 339:../src/FreeRTOS/tasks.c **** 	#if( configUSE_POSIX_ERRNO == 1 )
 340:../src/FreeRTOS/tasks.c **** 		int iTaskErrno;
 341:../src/FreeRTOS/tasks.c **** 	#endif
 342:../src/FreeRTOS/tasks.c **** 
 343:../src/FreeRTOS/tasks.c **** } tskTCB;
 344:../src/FreeRTOS/tasks.c **** 
 345:../src/FreeRTOS/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 346:../src/FreeRTOS/tasks.c **** below to enable the use of older kernel aware debuggers. */
 347:../src/FreeRTOS/tasks.c **** typedef tskTCB TCB_t;
 348:../src/FreeRTOS/tasks.c **** 
 349:../src/FreeRTOS/tasks.c **** /*lint -save -e956 A manual analysis and inspection has been used to determine
 350:../src/FreeRTOS/tasks.c **** which static variables must be declared volatile. */
 351:../src/FreeRTOS/tasks.c **** 
 352:../src/FreeRTOS/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 353:../src/FreeRTOS/tasks.c **** 
 354:../src/FreeRTOS/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 355:../src/FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 356:../src/FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 357:../src/FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 358:../src/FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 359:../src/FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 360:../src/FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 361:../src/FreeRTOS/tasks.c **** 
 362:../src/FreeRTOS/tasks.c **** #if( INCLUDE_vTaskDelete == 1 )
 363:../src/FreeRTOS/tasks.c **** 
 364:../src/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 365:../src/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
 366:../src/FreeRTOS/tasks.c **** 
 367:../src/FreeRTOS/tasks.c **** #endif
 368:../src/FreeRTOS/tasks.c **** 
 369:../src/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 370:../src/FreeRTOS/tasks.c **** 
 371:../src/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 372:../src/FreeRTOS/tasks.c **** 
 373:../src/FreeRTOS/tasks.c **** #endif
 374:../src/FreeRTOS/tasks.c **** 
 375:../src/FreeRTOS/tasks.c **** /* Global POSIX errno. Its value is changed upon context switching to match
 376:../src/FreeRTOS/tasks.c **** the errno of the currently running task. */
 377:../src/FreeRTOS/tasks.c **** #if ( configUSE_POSIX_ERRNO == 1 )
 378:../src/FreeRTOS/tasks.c **** 	int FreeRTOS_errno = 0;
 379:../src/FreeRTOS/tasks.c **** #endif
 380:../src/FreeRTOS/tasks.c **** 
 381:../src/FreeRTOS/tasks.c **** /* Other file private variables. --------------------------------*/
 382:../src/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 383:../src/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) configINITIAL_TICK_COUNT
 384:../src/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xIdleTickCount 			= ( TickType_t ) configINITIAL_TICK_CO
 385:../src/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 386:../src/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 387:../src/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
 388:../src/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 389:../src/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 390:../src/FreeRTOS/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 391:../src/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialise
 392:../src/FreeRTOS/tasks.c **** PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle 
 393:../src/FreeRTOS/tasks.c **** 
 394:../src/FreeRTOS/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 395:../src/FreeRTOS/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 396:../src/FreeRTOS/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 397:../src/FreeRTOS/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 398:../src/FreeRTOS/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 399:../src/FreeRTOS/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 400:../src/FreeRTOS/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 401:../src/FreeRTOS/tasks.c **** accessed from a critical section. */
 402:../src/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 403:../src/FreeRTOS/tasks.c **** 
 404:../src/FreeRTOS/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 405:../src/FreeRTOS/tasks.c **** 
 406:../src/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 407:../src/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 408:../src/FreeRTOS/tasks.c **** 
 409:../src/FreeRTOS/tasks.c **** #endif
 410:../src/FreeRTOS/tasks.c **** 
 411:../src/FreeRTOS/tasks.c **** /*lint -restore */
 412:../src/FreeRTOS/tasks.c **** 
 413:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 414:../src/FreeRTOS/tasks.c **** 
 415:../src/FreeRTOS/tasks.c **** /* Callback function prototypes. --------------------------*/
 416:../src/FreeRTOS/tasks.c **** #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
 417:../src/FreeRTOS/tasks.c **** 
 418:../src/FreeRTOS/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 419:../src/FreeRTOS/tasks.c **** 
 420:../src/FreeRTOS/tasks.c **** #endif
 421:../src/FreeRTOS/tasks.c **** 
 422:../src/FreeRTOS/tasks.c **** #if( configUSE_TICK_HOOK > 0 )
 423:../src/FreeRTOS/tasks.c **** 
 424:../src/FreeRTOS/tasks.c **** 	extern void vApplicationTickHook( void );
 425:../src/FreeRTOS/tasks.c **** 
 426:../src/FreeRTOS/tasks.c **** #endif
 427:../src/FreeRTOS/tasks.c **** 
 428:../src/FreeRTOS/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 429:../src/FreeRTOS/tasks.c **** 
 430:../src/FreeRTOS/tasks.c **** 	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxI
 431:../src/FreeRTOS/tasks.c **** 
 432:../src/FreeRTOS/tasks.c **** #endif
 433:../src/FreeRTOS/tasks.c **** 
 434:../src/FreeRTOS/tasks.c **** /* File private functions. --------------------------------*/
 435:../src/FreeRTOS/tasks.c **** 
 436:../src/FreeRTOS/tasks.c **** /**
 437:../src/FreeRTOS/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 438:../src/FreeRTOS/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 439:../src/FreeRTOS/tasks.c ****  * is in any other state.
 440:../src/FreeRTOS/tasks.c ****  */
 441:../src/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 442:../src/FreeRTOS/tasks.c **** 
 443:../src/FreeRTOS/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 444:../src/FreeRTOS/tasks.c **** 
 445:../src/FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 446:../src/FreeRTOS/tasks.c **** 
 447:../src/FreeRTOS/tasks.c **** /*
 448:../src/FreeRTOS/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 449:../src/FreeRTOS/tasks.c ****  * automatically upon the creation of the first task.
 450:../src/FreeRTOS/tasks.c ****  */
 451:../src/FreeRTOS/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 452:../src/FreeRTOS/tasks.c **** 
 453:../src/FreeRTOS/tasks.c **** /*
 454:../src/FreeRTOS/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 455:../src/FreeRTOS/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 456:../src/FreeRTOS/tasks.c ****  * creation of the first user task.
 457:../src/FreeRTOS/tasks.c ****  *
 458:../src/FreeRTOS/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 459:../src/FreeRTOS/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 460:../src/FreeRTOS/tasks.c ****  *
 461:../src/FreeRTOS/tasks.c ****  * void prvIdleTask( void *pvParameters );
 462:../src/FreeRTOS/tasks.c ****  *
 463:../src/FreeRTOS/tasks.c ****  */
 464:../src/FreeRTOS/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 465:../src/FreeRTOS/tasks.c **** 
 466:../src/FreeRTOS/tasks.c **** /*
 467:../src/FreeRTOS/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 468:../src/FreeRTOS/tasks.c ****  * including the stack pointed to by the TCB.
 469:../src/FreeRTOS/tasks.c ****  *
 470:../src/FreeRTOS/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 471:../src/FreeRTOS/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 472:../src/FreeRTOS/tasks.c ****  */
 473:../src/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 474:../src/FreeRTOS/tasks.c **** 
 475:../src/FreeRTOS/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 476:../src/FreeRTOS/tasks.c **** 
 477:../src/FreeRTOS/tasks.c **** #endif
 478:../src/FreeRTOS/tasks.c **** 
 479:../src/FreeRTOS/tasks.c **** /*
 480:../src/FreeRTOS/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 481:../src/FreeRTOS/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 482:../src/FreeRTOS/tasks.c ****  * and its TCB deleted.
 483:../src/FreeRTOS/tasks.c ****  */
 484:../src/FreeRTOS/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 485:../src/FreeRTOS/tasks.c **** 
 486:../src/FreeRTOS/tasks.c **** /*
 487:../src/FreeRTOS/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 488:../src/FreeRTOS/tasks.c ****  * either the current or the overflow delayed task list.
 489:../src/FreeRTOS/tasks.c ****  */
 490:../src/FreeRTOS/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
 491:../src/FreeRTOS/tasks.c **** 
 492:../src/FreeRTOS/tasks.c **** /*
 493:../src/FreeRTOS/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 494:../src/FreeRTOS/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 495:../src/FreeRTOS/tasks.c ****  * a suspended list, etc.).
 496:../src/FreeRTOS/tasks.c ****  *
 497:../src/FreeRTOS/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 498:../src/FreeRTOS/tasks.c ****  * NORMAL APPLICATION CODE.
 499:../src/FreeRTOS/tasks.c ****  */
 500:../src/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 501:../src/FreeRTOS/tasks.c **** 
 502:../src/FreeRTOS/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
 503:../src/FreeRTOS/tasks.c **** 
 504:../src/FreeRTOS/tasks.c **** #endif
 505:../src/FreeRTOS/tasks.c **** 
 506:../src/FreeRTOS/tasks.c **** /*
 507:../src/FreeRTOS/tasks.c ****  * Searches pxList for a task with name pcNameToQuery - returning a handle to
 508:../src/FreeRTOS/tasks.c ****  * the task if it is found, or NULL if the task is not found.
 509:../src/FreeRTOS/tasks.c ****  */
 510:../src/FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
 511:../src/FreeRTOS/tasks.c **** 
 512:../src/FreeRTOS/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVI
 513:../src/FreeRTOS/tasks.c **** 
 514:../src/FreeRTOS/tasks.c **** #endif
 515:../src/FreeRTOS/tasks.c **** 
 516:../src/FreeRTOS/tasks.c **** /*
 517:../src/FreeRTOS/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 518:../src/FreeRTOS/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 519:../src/FreeRTOS/tasks.c ****  * determining how much of the stack remains at the original preset value.
 520:../src/FreeRTOS/tasks.c ****  */
 521:../src/FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 522:../src/FreeRTOS/tasks.c **** 
 523:../src/FreeRTOS/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
 524:../src/FreeRTOS/tasks.c **** 
 525:../src/FreeRTOS/tasks.c **** #endif
 526:../src/FreeRTOS/tasks.c **** 
 527:../src/FreeRTOS/tasks.c **** /*
 528:../src/FreeRTOS/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 529:../src/FreeRTOS/tasks.c ****  * next move a task from the Blocked state to the Running state.
 530:../src/FreeRTOS/tasks.c ****  *
 531:../src/FreeRTOS/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 532:../src/FreeRTOS/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 533:../src/FreeRTOS/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 534:../src/FreeRTOS/tasks.c ****  * set to a value other than 1.
 535:../src/FreeRTOS/tasks.c ****  */
 536:../src/FreeRTOS/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 537:../src/FreeRTOS/tasks.c **** 
 538:../src/FreeRTOS/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 539:../src/FreeRTOS/tasks.c **** 
 540:../src/FreeRTOS/tasks.c **** #endif
 541:../src/FreeRTOS/tasks.c **** 
 542:../src/FreeRTOS/tasks.c **** /*
 543:../src/FreeRTOS/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 544:../src/FreeRTOS/tasks.c ****  * will exit the Blocked state.
 545:../src/FreeRTOS/tasks.c ****  */
 546:../src/FreeRTOS/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 547:../src/FreeRTOS/tasks.c **** 
 548:../src/FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 549:../src/FreeRTOS/tasks.c **** 
 550:../src/FreeRTOS/tasks.c **** 	/*
 551:../src/FreeRTOS/tasks.c **** 	 * Helper function used to pad task names with spaces when printing out
 552:../src/FreeRTOS/tasks.c **** 	 * human readable tables of task information.
 553:../src/FreeRTOS/tasks.c **** 	 */
 554:../src/FreeRTOS/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
 555:../src/FreeRTOS/tasks.c **** 
 556:../src/FreeRTOS/tasks.c **** #endif
 557:../src/FreeRTOS/tasks.c **** 
 558:../src/FreeRTOS/tasks.c **** /*
 559:../src/FreeRTOS/tasks.c ****  * Called after a Task_t structure has been allocated either statically or
 560:../src/FreeRTOS/tasks.c ****  * dynamically to fill in the structure's members.
 561:../src/FreeRTOS/tasks.c ****  */
 562:../src/FreeRTOS/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 563:../src/FreeRTOS/tasks.c **** 									const char * const pcName, 		/*lint !e971 Unqualified char types are allowed for strings a
 564:../src/FreeRTOS/tasks.c **** 									const uint32_t ulStackDepth,
 565:../src/FreeRTOS/tasks.c **** 									void * const pvParameters,
 566:../src/FreeRTOS/tasks.c **** 									UBaseType_t uxPriority,
 567:../src/FreeRTOS/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 568:../src/FreeRTOS/tasks.c **** 									TCB_t *pxNewTCB,
 569:../src/FreeRTOS/tasks.c **** 									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
 570:../src/FreeRTOS/tasks.c **** 
 571:../src/FreeRTOS/tasks.c **** /*
 572:../src/FreeRTOS/tasks.c ****  * Called after a new task has been created and initialised to place the task
 573:../src/FreeRTOS/tasks.c ****  * under the control of the scheduler.
 574:../src/FreeRTOS/tasks.c ****  */
 575:../src/FreeRTOS/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
 576:../src/FreeRTOS/tasks.c **** 
 577:../src/FreeRTOS/tasks.c **** /*
 578:../src/FreeRTOS/tasks.c ****  * freertos_tasks_c_additions_init() should only be called if the user definable
 579:../src/FreeRTOS/tasks.c ****  * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
 580:../src/FreeRTOS/tasks.c ****  * called by the function.
 581:../src/FreeRTOS/tasks.c ****  */
 582:../src/FreeRTOS/tasks.c **** #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
 583:../src/FreeRTOS/tasks.c **** 
 584:../src/FreeRTOS/tasks.c **** 	static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
 585:../src/FreeRTOS/tasks.c **** 
 586:../src/FreeRTOS/tasks.c **** #endif
 587:../src/FreeRTOS/tasks.c **** 
 588:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 589:../src/FreeRTOS/tasks.c **** 
 590:../src/FreeRTOS/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 591:../src/FreeRTOS/tasks.c **** 
 592:../src/FreeRTOS/tasks.c **** 	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
 593:../src/FreeRTOS/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 594:../src/FreeRTOS/tasks.c **** 									const uint32_t ulStackDepth,
 595:../src/FreeRTOS/tasks.c **** 									void * const pvParameters,
 596:../src/FreeRTOS/tasks.c **** 									UBaseType_t uxPriority,
 597:../src/FreeRTOS/tasks.c **** 									StackType_t * const puxStackBuffer,
 598:../src/FreeRTOS/tasks.c **** 									StaticTask_t * const pxTaskBuffer )
 599:../src/FreeRTOS/tasks.c **** 	{
 600:../src/FreeRTOS/tasks.c **** 	TCB_t *pxNewTCB;
 601:../src/FreeRTOS/tasks.c **** 	TaskHandle_t xReturn;
 602:../src/FreeRTOS/tasks.c **** 
 603:../src/FreeRTOS/tasks.c **** 		configASSERT( puxStackBuffer != NULL );
 604:../src/FreeRTOS/tasks.c **** 		configASSERT( pxTaskBuffer != NULL );
 605:../src/FreeRTOS/tasks.c **** 
 606:../src/FreeRTOS/tasks.c **** 		#if( configASSERT_DEFINED == 1 )
 607:../src/FreeRTOS/tasks.c **** 		{
 608:../src/FreeRTOS/tasks.c **** 			/* Sanity check that the size of the structure used to declare a
 609:../src/FreeRTOS/tasks.c **** 			variable of type StaticTask_t equals the size of the real task
 610:../src/FreeRTOS/tasks.c **** 			structure. */
 611:../src/FreeRTOS/tasks.c **** 			volatile size_t xSize = sizeof( StaticTask_t );
 612:../src/FreeRTOS/tasks.c **** 			configASSERT( xSize == sizeof( TCB_t ) );
 613:../src/FreeRTOS/tasks.c **** 		}
 614:../src/FreeRTOS/tasks.c **** 		#endif /* configASSERT_DEFINED */
 615:../src/FreeRTOS/tasks.c **** 
 616:../src/FreeRTOS/tasks.c **** 
 617:../src/FreeRTOS/tasks.c **** 		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 618:../src/FreeRTOS/tasks.c **** 		{
 619:../src/FreeRTOS/tasks.c **** 			/* The memory used for the task's TCB and stack are passed into this
 620:../src/FreeRTOS/tasks.c **** 			function - use them. */
 621:../src/FreeRTOS/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are desig
 622:../src/FreeRTOS/tasks.c **** 			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 623:../src/FreeRTOS/tasks.c **** 
 624:../src/FreeRTOS/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated f
 625:../src/FreeRTOS/tasks.c **** 			{
 626:../src/FreeRTOS/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 627:../src/FreeRTOS/tasks.c **** 				task was created statically in case the task is later deleted. */
 628:../src/FreeRTOS/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 629:../src/FreeRTOS/tasks.c **** 			}
 630:../src/FreeRTOS/tasks.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 631:../src/FreeRTOS/tasks.c **** 
 632:../src/FreeRTOS/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNe
 633:../src/FreeRTOS/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 634:../src/FreeRTOS/tasks.c **** 		}
 635:../src/FreeRTOS/tasks.c **** 		else
 636:../src/FreeRTOS/tasks.c **** 		{
 637:../src/FreeRTOS/tasks.c **** 			xReturn = NULL;
 638:../src/FreeRTOS/tasks.c **** 		}
 639:../src/FreeRTOS/tasks.c **** 
 640:../src/FreeRTOS/tasks.c **** 		return xReturn;
 641:../src/FreeRTOS/tasks.c **** 	}
 642:../src/FreeRTOS/tasks.c **** 
 643:../src/FreeRTOS/tasks.c **** #endif /* SUPPORT_STATIC_ALLOCATION */
 644:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 645:../src/FreeRTOS/tasks.c **** 
 646:../src/FreeRTOS/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 647:../src/FreeRTOS/tasks.c **** 
 648:../src/FreeRTOS/tasks.c **** 	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandl
 649:../src/FreeRTOS/tasks.c **** 	{
 650:../src/FreeRTOS/tasks.c **** 	TCB_t *pxNewTCB;
 651:../src/FreeRTOS/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 652:../src/FreeRTOS/tasks.c **** 
 653:../src/FreeRTOS/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
 654:../src/FreeRTOS/tasks.c **** 		configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 655:../src/FreeRTOS/tasks.c **** 
 656:../src/FreeRTOS/tasks.c **** 		if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
 657:../src/FreeRTOS/tasks.c **** 		{
 658:../src/FreeRTOS/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 659:../src/FreeRTOS/tasks.c **** 			on the implementation of the port malloc function and whether or
 660:../src/FreeRTOS/tasks.c **** 			not static allocation is being used. */
 661:../src/FreeRTOS/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
 662:../src/FreeRTOS/tasks.c **** 
 663:../src/FreeRTOS/tasks.c **** 			/* Store the stack location in the TCB. */
 664:../src/FreeRTOS/tasks.c **** 			pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 665:../src/FreeRTOS/tasks.c **** 
 666:../src/FreeRTOS/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 667:../src/FreeRTOS/tasks.c **** 			{
 668:../src/FreeRTOS/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 669:../src/FreeRTOS/tasks.c **** 				task was created statically in case the task is later deleted. */
 670:../src/FreeRTOS/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 671:../src/FreeRTOS/tasks.c **** 			}
 672:../src/FreeRTOS/tasks.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 673:../src/FreeRTOS/tasks.c **** 
 674:../src/FreeRTOS/tasks.c **** 			prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 675:../src/FreeRTOS/tasks.c **** 									pxTaskDefinition->pcName,
 676:../src/FreeRTOS/tasks.c **** 									( uint32_t ) pxTaskDefinition->usStackDepth,
 677:../src/FreeRTOS/tasks.c **** 									pxTaskDefinition->pvParameters,
 678:../src/FreeRTOS/tasks.c **** 									pxTaskDefinition->uxPriority,
 679:../src/FreeRTOS/tasks.c **** 									pxCreatedTask, pxNewTCB,
 680:../src/FreeRTOS/tasks.c **** 									pxTaskDefinition->xRegions );
 681:../src/FreeRTOS/tasks.c **** 
 682:../src/FreeRTOS/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 683:../src/FreeRTOS/tasks.c **** 			xReturn = pdPASS;
 684:../src/FreeRTOS/tasks.c **** 		}
 685:../src/FreeRTOS/tasks.c **** 
 686:../src/FreeRTOS/tasks.c **** 		return xReturn;
 687:../src/FreeRTOS/tasks.c **** 	}
 688:../src/FreeRTOS/tasks.c **** 
 689:../src/FreeRTOS/tasks.c **** #endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 690:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 691:../src/FreeRTOS/tasks.c **** 
 692:../src/FreeRTOS/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 693:../src/FreeRTOS/tasks.c **** 
 694:../src/FreeRTOS/tasks.c **** 	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *p
 695:../src/FreeRTOS/tasks.c **** 	{
 696:../src/FreeRTOS/tasks.c **** 	TCB_t *pxNewTCB;
 697:../src/FreeRTOS/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 698:../src/FreeRTOS/tasks.c **** 
 699:../src/FreeRTOS/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer );
 700:../src/FreeRTOS/tasks.c **** 
 701:../src/FreeRTOS/tasks.c **** 		if( pxTaskDefinition->puxStackBuffer != NULL )
 702:../src/FreeRTOS/tasks.c **** 		{
 703:../src/FreeRTOS/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 704:../src/FreeRTOS/tasks.c **** 			on the implementation of the port malloc function and whether or
 705:../src/FreeRTOS/tasks.c **** 			not static allocation is being used. */
 706:../src/FreeRTOS/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 707:../src/FreeRTOS/tasks.c **** 
 708:../src/FreeRTOS/tasks.c **** 			if( pxNewTCB != NULL )
 709:../src/FreeRTOS/tasks.c **** 			{
 710:../src/FreeRTOS/tasks.c **** 				/* Store the stack location in the TCB. */
 711:../src/FreeRTOS/tasks.c **** 				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 712:../src/FreeRTOS/tasks.c **** 
 713:../src/FreeRTOS/tasks.c **** 				#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 714:../src/FreeRTOS/tasks.c **** 				{
 715:../src/FreeRTOS/tasks.c **** 					/* Tasks can be created statically or dynamically, so note
 716:../src/FreeRTOS/tasks.c **** 					this task had a statically allocated stack in case it is
 717:../src/FreeRTOS/tasks.c **** 					later deleted.  The TCB was allocated dynamically. */
 718:../src/FreeRTOS/tasks.c **** 					pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 719:../src/FreeRTOS/tasks.c **** 				}
 720:../src/FreeRTOS/tasks.c **** 				#endif
 721:../src/FreeRTOS/tasks.c **** 
 722:../src/FreeRTOS/tasks.c **** 				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 723:../src/FreeRTOS/tasks.c **** 										pxTaskDefinition->pcName,
 724:../src/FreeRTOS/tasks.c **** 										( uint32_t ) pxTaskDefinition->usStackDepth,
 725:../src/FreeRTOS/tasks.c **** 										pxTaskDefinition->pvParameters,
 726:../src/FreeRTOS/tasks.c **** 										pxTaskDefinition->uxPriority,
 727:../src/FreeRTOS/tasks.c **** 										pxCreatedTask, pxNewTCB,
 728:../src/FreeRTOS/tasks.c **** 										pxTaskDefinition->xRegions );
 729:../src/FreeRTOS/tasks.c **** 
 730:../src/FreeRTOS/tasks.c **** 				prvAddNewTaskToReadyList( pxNewTCB );
 731:../src/FreeRTOS/tasks.c **** 				xReturn = pdPASS;
 732:../src/FreeRTOS/tasks.c **** 			}
 733:../src/FreeRTOS/tasks.c **** 		}
 734:../src/FreeRTOS/tasks.c **** 
 735:../src/FreeRTOS/tasks.c **** 		return xReturn;
 736:../src/FreeRTOS/tasks.c **** 	}
 737:../src/FreeRTOS/tasks.c **** 
 738:../src/FreeRTOS/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
 739:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 740:../src/FreeRTOS/tasks.c **** 
 741:../src/FreeRTOS/tasks.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 742:../src/FreeRTOS/tasks.c **** 
 743:../src/FreeRTOS/tasks.c **** 	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
 744:../src/FreeRTOS/tasks.c **** 							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and 
 745:../src/FreeRTOS/tasks.c **** 							const configSTACK_DEPTH_TYPE usStackDepth,
 746:../src/FreeRTOS/tasks.c **** 							void * const pvParameters,
 747:../src/FreeRTOS/tasks.c **** 							UBaseType_t uxPriority,
 748:../src/FreeRTOS/tasks.c **** 							TaskHandle_t * const pxCreatedTask )
 749:../src/FreeRTOS/tasks.c **** 	{
 750:../src/FreeRTOS/tasks.c **** 	TCB_t *pxNewTCB;
 751:../src/FreeRTOS/tasks.c **** 	BaseType_t xReturn;
 752:../src/FreeRTOS/tasks.c **** 
 753:../src/FreeRTOS/tasks.c **** 		/* If the stack grows down then allocate the stack then the TCB so the stack
 754:../src/FreeRTOS/tasks.c **** 		does not grow into the TCB.  Likewise if the stack grows up then allocate
 755:../src/FreeRTOS/tasks.c **** 		the TCB then the stack. */
 756:../src/FreeRTOS/tasks.c **** 		#if( portSTACK_GROWTH > 0 )
 757:../src/FreeRTOS/tasks.c **** 		{
 758:../src/FreeRTOS/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends on
 759:../src/FreeRTOS/tasks.c **** 			the implementation of the port malloc function and whether or not static
 760:../src/FreeRTOS/tasks.c **** 			allocation is being used. */
 761:../src/FreeRTOS/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 762:../src/FreeRTOS/tasks.c **** 
 763:../src/FreeRTOS/tasks.c **** 			if( pxNewTCB != NULL )
 764:../src/FreeRTOS/tasks.c **** 			{
 765:../src/FreeRTOS/tasks.c **** 				/* Allocate space for the stack used by the task being created.
 766:../src/FreeRTOS/tasks.c **** 				The base of the stack memory stored in the TCB so the task can
 767:../src/FreeRTOS/tasks.c **** 				be deleted later if required. */
 768:../src/FreeRTOS/tasks.c **** 				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( Sta
 769:../src/FreeRTOS/tasks.c **** 
 770:../src/FreeRTOS/tasks.c **** 				if( pxNewTCB->pxStack == NULL )
 771:../src/FreeRTOS/tasks.c **** 				{
 772:../src/FreeRTOS/tasks.c **** 					/* Could not allocate the stack.  Delete the allocated TCB. */
 773:../src/FreeRTOS/tasks.c **** 					vPortFree( pxNewTCB );
 774:../src/FreeRTOS/tasks.c **** 					pxNewTCB = NULL;
 775:../src/FreeRTOS/tasks.c **** 				}
 776:../src/FreeRTOS/tasks.c **** 			}
 777:../src/FreeRTOS/tasks.c **** 		}
 778:../src/FreeRTOS/tasks.c **** 		#else /* portSTACK_GROWTH */
 779:../src/FreeRTOS/tasks.c **** 		{
 780:../src/FreeRTOS/tasks.c **** 		StackType_t *pxStack;
 781:../src/FreeRTOS/tasks.c **** 
 782:../src/FreeRTOS/tasks.c **** 			/* Allocate space for the stack used by the task being created. */
 783:../src/FreeRTOS/tasks.c **** 			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) 
 784:../src/FreeRTOS/tasks.c **** 
 785:../src/FreeRTOS/tasks.c **** 			if( pxStack != NULL )
 786:../src/FreeRTOS/tasks.c **** 			{
 787:../src/FreeRTOS/tasks.c **** 				/* Allocate space for the TCB. */
 788:../src/FreeRTOS/tasks.c **** 				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the cas
 789:../src/FreeRTOS/tasks.c **** 
 790:../src/FreeRTOS/tasks.c **** 				if( pxNewTCB != NULL )
 791:../src/FreeRTOS/tasks.c **** 				{
 792:../src/FreeRTOS/tasks.c **** 					/* Store the stack location in the TCB. */
 793:../src/FreeRTOS/tasks.c **** 					pxNewTCB->pxStack = pxStack;
 794:../src/FreeRTOS/tasks.c **** 				}
 795:../src/FreeRTOS/tasks.c **** 				else
 796:../src/FreeRTOS/tasks.c **** 				{
 797:../src/FreeRTOS/tasks.c **** 					/* The stack cannot be used as the TCB was not created.  Free
 798:../src/FreeRTOS/tasks.c **** 					it again. */
 799:../src/FreeRTOS/tasks.c **** 					vPortFree( pxStack );
 800:../src/FreeRTOS/tasks.c **** 				}
 801:../src/FreeRTOS/tasks.c **** 			}
 802:../src/FreeRTOS/tasks.c **** 			else
 803:../src/FreeRTOS/tasks.c **** 			{
 804:../src/FreeRTOS/tasks.c **** 				pxNewTCB = NULL;
 805:../src/FreeRTOS/tasks.c **** 			}
 806:../src/FreeRTOS/tasks.c **** 		}
 807:../src/FreeRTOS/tasks.c **** 		#endif /* portSTACK_GROWTH */
 808:../src/FreeRTOS/tasks.c **** 
 809:../src/FreeRTOS/tasks.c **** 		if( pxNewTCB != NULL )
 810:../src/FreeRTOS/tasks.c **** 		{
 811:../src/FreeRTOS/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated f
 812:../src/FreeRTOS/tasks.c **** 			{
 813:../src/FreeRTOS/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 814:../src/FreeRTOS/tasks.c **** 				task was created dynamically in case it is later deleted. */
 815:../src/FreeRTOS/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 816:../src/FreeRTOS/tasks.c **** 			}
 817:../src/FreeRTOS/tasks.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 818:../src/FreeRTOS/tasks.c **** 
 819:../src/FreeRTOS/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, p
 820:../src/FreeRTOS/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 821:../src/FreeRTOS/tasks.c **** 			xReturn = pdPASS;
 822:../src/FreeRTOS/tasks.c **** 		}
 823:../src/FreeRTOS/tasks.c **** 		else
 824:../src/FreeRTOS/tasks.c **** 		{
 825:../src/FreeRTOS/tasks.c **** 			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 826:../src/FreeRTOS/tasks.c **** 		}
 827:../src/FreeRTOS/tasks.c **** 
 828:../src/FreeRTOS/tasks.c **** 		return xReturn;
 829:../src/FreeRTOS/tasks.c **** 	}
 830:../src/FreeRTOS/tasks.c **** 
 831:../src/FreeRTOS/tasks.c **** #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 832:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 833:../src/FreeRTOS/tasks.c **** 
 834:../src/FreeRTOS/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 835:../src/FreeRTOS/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 836:../src/FreeRTOS/tasks.c **** 									const uint32_t ulStackDepth,
 837:../src/FreeRTOS/tasks.c **** 									void * const pvParameters,
 838:../src/FreeRTOS/tasks.c **** 									UBaseType_t uxPriority,
 839:../src/FreeRTOS/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 840:../src/FreeRTOS/tasks.c **** 									TCB_t *pxNewTCB,
 841:../src/FreeRTOS/tasks.c **** 									const MemoryRegion_t * const xRegions )
 842:../src/FreeRTOS/tasks.c **** {
 843:../src/FreeRTOS/tasks.c **** StackType_t *pxTopOfStack;
 844:../src/FreeRTOS/tasks.c **** UBaseType_t x;
 845:../src/FreeRTOS/tasks.c **** 
 846:../src/FreeRTOS/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
 847:../src/FreeRTOS/tasks.c **** 		/* Should the task be created in privileged mode? */
 848:../src/FreeRTOS/tasks.c **** 		BaseType_t xRunPrivileged;
 849:../src/FreeRTOS/tasks.c **** 		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 850:../src/FreeRTOS/tasks.c **** 		{
 851:../src/FreeRTOS/tasks.c **** 			xRunPrivileged = pdTRUE;
 852:../src/FreeRTOS/tasks.c **** 		}
 853:../src/FreeRTOS/tasks.c **** 		else
 854:../src/FreeRTOS/tasks.c **** 		{
 855:../src/FreeRTOS/tasks.c **** 			xRunPrivileged = pdFALSE;
 856:../src/FreeRTOS/tasks.c **** 		}
 857:../src/FreeRTOS/tasks.c **** 		uxPriority &= ~portPRIVILEGE_BIT;
 858:../src/FreeRTOS/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS == 1 */
 859:../src/FreeRTOS/tasks.c **** 
 860:../src/FreeRTOS/tasks.c **** 	/* Avoid dependency on memset() if it is not required. */
 861:../src/FreeRTOS/tasks.c **** 	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
 862:../src/FreeRTOS/tasks.c **** 	{
 863:../src/FreeRTOS/tasks.c **** 		/* Fill the stack with a known value to assist debugging. */
 864:../src/FreeRTOS/tasks.c **** 		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof(
 865:../src/FreeRTOS/tasks.c **** 	}
 866:../src/FreeRTOS/tasks.c **** 	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
 867:../src/FreeRTOS/tasks.c **** 
 868:../src/FreeRTOS/tasks.c **** 	/* Calculate the top of stack address.  This depends on whether the stack
 869:../src/FreeRTOS/tasks.c **** 	grows from high memory to low (as per the 80x86) or vice versa.
 870:../src/FreeRTOS/tasks.c **** 	portSTACK_GROWTH is used to make the result positive or negative as required
 871:../src/FreeRTOS/tasks.c **** 	by the port. */
 872:../src/FreeRTOS/tasks.c **** 	#if( portSTACK_GROWTH < 0 )
 873:../src/FreeRTOS/tasks.c **** 	{
 874:../src/FreeRTOS/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 875:../src/FreeRTOS/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 876:../src/FreeRTOS/tasks.c **** 
 877:../src/FreeRTOS/tasks.c **** 		/* Check the alignment of the calculated top of stack is correct. */
 878:../src/FreeRTOS/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALI
 879:../src/FreeRTOS/tasks.c **** 
 880:../src/FreeRTOS/tasks.c **** 		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
 881:../src/FreeRTOS/tasks.c **** 		{
 882:../src/FreeRTOS/tasks.c **** 			/* Also record the stack's high address, which may assist
 883:../src/FreeRTOS/tasks.c **** 			debugging. */
 884:../src/FreeRTOS/tasks.c **** 			pxNewTCB->pxEndOfStack = pxTopOfStack;
 885:../src/FreeRTOS/tasks.c **** 		}
 886:../src/FreeRTOS/tasks.c **** 		#endif /* configRECORD_STACK_HIGH_ADDRESS */
 887:../src/FreeRTOS/tasks.c **** 	}
 888:../src/FreeRTOS/tasks.c **** 	#else /* portSTACK_GROWTH */
 889:../src/FreeRTOS/tasks.c **** 	{
 890:../src/FreeRTOS/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack;
 891:../src/FreeRTOS/tasks.c **** 
 892:../src/FreeRTOS/tasks.c **** 		/* Check the alignment of the stack buffer is correct. */
 893:../src/FreeRTOS/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYT
 894:../src/FreeRTOS/tasks.c **** 
 895:../src/FreeRTOS/tasks.c **** 		/* The other extreme of the stack space is required if stack checking is
 896:../src/FreeRTOS/tasks.c **** 		performed. */
 897:../src/FreeRTOS/tasks.c **** 		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 898:../src/FreeRTOS/tasks.c **** 	}
 899:../src/FreeRTOS/tasks.c **** 	#endif /* portSTACK_GROWTH */
 900:../src/FreeRTOS/tasks.c **** 
 901:../src/FreeRTOS/tasks.c **** 	/* Store the task name in the TCB. */
 902:../src/FreeRTOS/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 903:../src/FreeRTOS/tasks.c **** 	{
 904:../src/FreeRTOS/tasks.c **** 		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 905:../src/FreeRTOS/tasks.c **** 
 906:../src/FreeRTOS/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
 907:../src/FreeRTOS/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
 908:../src/FreeRTOS/tasks.c **** 		string is not accessible (extremely unlikely). */
 909:../src/FreeRTOS/tasks.c **** 		if( pcName[ x ] == 0x00 )
 910:../src/FreeRTOS/tasks.c **** 		{
 911:../src/FreeRTOS/tasks.c **** 			break;
 912:../src/FreeRTOS/tasks.c **** 		}
 913:../src/FreeRTOS/tasks.c **** 		else
 914:../src/FreeRTOS/tasks.c **** 		{
 915:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 916:../src/FreeRTOS/tasks.c **** 		}
 917:../src/FreeRTOS/tasks.c **** 	}
 918:../src/FreeRTOS/tasks.c **** 
 919:../src/FreeRTOS/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
 920:../src/FreeRTOS/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
 921:../src/FreeRTOS/tasks.c **** 	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 922:../src/FreeRTOS/tasks.c **** 
 923:../src/FreeRTOS/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
 924:../src/FreeRTOS/tasks.c **** 	remove the privilege bit if one is present. */
 925:../src/FreeRTOS/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 926:../src/FreeRTOS/tasks.c **** 	{
 927:../src/FreeRTOS/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 928:../src/FreeRTOS/tasks.c **** 	}
 929:../src/FreeRTOS/tasks.c **** 	else
 930:../src/FreeRTOS/tasks.c **** 	{
 931:../src/FreeRTOS/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 932:../src/FreeRTOS/tasks.c **** 	}
 933:../src/FreeRTOS/tasks.c **** 
 934:../src/FreeRTOS/tasks.c **** 	pxNewTCB->uxPriority = uxPriority;
 935:../src/FreeRTOS/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 936:../src/FreeRTOS/tasks.c **** 	{
 937:../src/FreeRTOS/tasks.c **** 		pxNewTCB->uxBasePriority = uxPriority;
 938:../src/FreeRTOS/tasks.c **** 		pxNewTCB->uxMutexesHeld = 0;
 939:../src/FreeRTOS/tasks.c **** 	}
 940:../src/FreeRTOS/tasks.c **** 	#endif /* configUSE_MUTEXES */
 941:../src/FreeRTOS/tasks.c **** 
 942:../src/FreeRTOS/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 943:../src/FreeRTOS/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 944:../src/FreeRTOS/tasks.c **** 
 945:../src/FreeRTOS/tasks.c **** 	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
 946:../src/FreeRTOS/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
 947:../src/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 948:../src/FreeRTOS/tasks.c **** 
 949:../src/FreeRTOS/tasks.c **** 	/* Event lists are always in priority order. */
 950:../src/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( Ti
 951:../src/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 952:../src/FreeRTOS/tasks.c **** 
 953:../src/FreeRTOS/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 954:../src/FreeRTOS/tasks.c **** 	{
 955:../src/FreeRTOS/tasks.c **** 		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 956:../src/FreeRTOS/tasks.c **** 	}
 957:../src/FreeRTOS/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
 958:../src/FreeRTOS/tasks.c **** 
 959:../src/FreeRTOS/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 960:../src/FreeRTOS/tasks.c **** 	{
 961:../src/FreeRTOS/tasks.c **** 		pxNewTCB->pxTaskTag = NULL;
 962:../src/FreeRTOS/tasks.c **** 	}
 963:../src/FreeRTOS/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
 964:../src/FreeRTOS/tasks.c **** 
 965:../src/FreeRTOS/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 966:../src/FreeRTOS/tasks.c **** 	{
 967:../src/FreeRTOS/tasks.c **** 		pxNewTCB->ulRunTimeCounter = 0UL;
 968:../src/FreeRTOS/tasks.c **** 	}
 969:../src/FreeRTOS/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
 970:../src/FreeRTOS/tasks.c **** 
 971:../src/FreeRTOS/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 972:../src/FreeRTOS/tasks.c **** 	{
 973:../src/FreeRTOS/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth
 974:../src/FreeRTOS/tasks.c **** 	}
 975:../src/FreeRTOS/tasks.c **** 	#else
 976:../src/FreeRTOS/tasks.c **** 	{
 977:../src/FreeRTOS/tasks.c **** 		/* Avoid compiler warning about unreferenced parameter. */
 978:../src/FreeRTOS/tasks.c **** 		( void ) xRegions;
 979:../src/FreeRTOS/tasks.c **** 	}
 980:../src/FreeRTOS/tasks.c **** 	#endif
 981:../src/FreeRTOS/tasks.c **** 
 982:../src/FreeRTOS/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
 983:../src/FreeRTOS/tasks.c **** 	{
 984:../src/FreeRTOS/tasks.c **** 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
 985:../src/FreeRTOS/tasks.c **** 		{
 986:../src/FreeRTOS/tasks.c **** 			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 987:../src/FreeRTOS/tasks.c **** 		}
 988:../src/FreeRTOS/tasks.c **** 	}
 989:../src/FreeRTOS/tasks.c **** 	#endif
 990:../src/FreeRTOS/tasks.c **** 
 991:../src/FreeRTOS/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
 992:../src/FreeRTOS/tasks.c **** 	{
 993:../src/FreeRTOS/tasks.c **** 		pxNewTCB->ulNotifiedValue = 0;
 994:../src/FreeRTOS/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 995:../src/FreeRTOS/tasks.c **** 	}
 996:../src/FreeRTOS/tasks.c **** 	#endif
 997:../src/FreeRTOS/tasks.c **** 
 998:../src/FreeRTOS/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 999:../src/FreeRTOS/tasks.c **** 	{
1000:../src/FreeRTOS/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
1001:../src/FreeRTOS/tasks.c **** 		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
1002:../src/FreeRTOS/tasks.c **** 	}
1003:../src/FreeRTOS/tasks.c **** 	#endif
1004:../src/FreeRTOS/tasks.c **** 
1005:../src/FreeRTOS/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
1006:../src/FreeRTOS/tasks.c **** 	{
1007:../src/FreeRTOS/tasks.c **** 		pxNewTCB->ucDelayAborted = pdFALSE;
1008:../src/FreeRTOS/tasks.c **** 	}
1009:../src/FreeRTOS/tasks.c **** 	#endif
1010:../src/FreeRTOS/tasks.c **** 
1011:../src/FreeRTOS/tasks.c **** 	/* Initialize the TCB stack to look as if the task was already running,
1012:../src/FreeRTOS/tasks.c **** 	but had been interrupted by the scheduler.  The return address is set
1013:../src/FreeRTOS/tasks.c **** 	to the start of the task function. Once the stack has been initialised
1014:../src/FreeRTOS/tasks.c **** 	the top of stack variable is updated. */
1015:../src/FreeRTOS/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
1016:../src/FreeRTOS/tasks.c **** 	{
1017:../src/FreeRTOS/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivi
1018:../src/FreeRTOS/tasks.c **** 	}
1019:../src/FreeRTOS/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
1020:../src/FreeRTOS/tasks.c **** 	{
1021:../src/FreeRTOS/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
1022:../src/FreeRTOS/tasks.c **** 	}
1023:../src/FreeRTOS/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
1024:../src/FreeRTOS/tasks.c **** 
1025:../src/FreeRTOS/tasks.c **** 	if( ( void * ) pxCreatedTask != NULL )
1026:../src/FreeRTOS/tasks.c **** 	{
1027:../src/FreeRTOS/tasks.c **** 		/* Pass the handle out in an anonymous way.  The handle can be used to
1028:../src/FreeRTOS/tasks.c **** 		change the created task's priority, delete the created task, etc.*/
1029:../src/FreeRTOS/tasks.c **** 		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
1030:../src/FreeRTOS/tasks.c **** 	}
1031:../src/FreeRTOS/tasks.c **** 	else
1032:../src/FreeRTOS/tasks.c **** 	{
1033:../src/FreeRTOS/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1034:../src/FreeRTOS/tasks.c **** 	}
1035:../src/FreeRTOS/tasks.c **** }
1036:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1037:../src/FreeRTOS/tasks.c **** 
1038:../src/FreeRTOS/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
1039:../src/FreeRTOS/tasks.c **** {
1040:../src/FreeRTOS/tasks.c **** 	/* Ensure interrupts don't access the task lists while the lists are being
1041:../src/FreeRTOS/tasks.c **** 	updated. */
1042:../src/FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
1043:../src/FreeRTOS/tasks.c **** 	{
1044:../src/FreeRTOS/tasks.c **** 		uxCurrentNumberOfTasks++;
1045:../src/FreeRTOS/tasks.c **** 		if( pxCurrentTCB == NULL )
1046:../src/FreeRTOS/tasks.c **** 		{
1047:../src/FreeRTOS/tasks.c **** 			/* There are no other tasks, or all the other tasks are in
1048:../src/FreeRTOS/tasks.c **** 			the suspended state - make this the current task. */
1049:../src/FreeRTOS/tasks.c **** 			pxCurrentTCB = pxNewTCB;
1050:../src/FreeRTOS/tasks.c **** 
1051:../src/FreeRTOS/tasks.c **** 			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
1052:../src/FreeRTOS/tasks.c **** 			{
1053:../src/FreeRTOS/tasks.c **** 				/* This is the first task to be created so do the preliminary
1054:../src/FreeRTOS/tasks.c **** 				initialisation required.  We will not recover if this call
1055:../src/FreeRTOS/tasks.c **** 				fails, but we will report the failure. */
1056:../src/FreeRTOS/tasks.c **** 				prvInitialiseTaskLists();
1057:../src/FreeRTOS/tasks.c **** 			}
1058:../src/FreeRTOS/tasks.c **** 			else
1059:../src/FreeRTOS/tasks.c **** 			{
1060:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1061:../src/FreeRTOS/tasks.c **** 			}
1062:../src/FreeRTOS/tasks.c **** 		}
1063:../src/FreeRTOS/tasks.c **** 		else
1064:../src/FreeRTOS/tasks.c **** 		{
1065:../src/FreeRTOS/tasks.c **** 			/* If the scheduler is not already running, make this task the
1066:../src/FreeRTOS/tasks.c **** 			current task if it is the highest priority task to be created
1067:../src/FreeRTOS/tasks.c **** 			so far. */
1068:../src/FreeRTOS/tasks.c **** 			if( xSchedulerRunning == pdFALSE )
1069:../src/FreeRTOS/tasks.c **** 			{
1070:../src/FreeRTOS/tasks.c **** 				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
1071:../src/FreeRTOS/tasks.c **** 				{
1072:../src/FreeRTOS/tasks.c **** 					pxCurrentTCB = pxNewTCB;
1073:../src/FreeRTOS/tasks.c **** 				}
1074:../src/FreeRTOS/tasks.c **** 				else
1075:../src/FreeRTOS/tasks.c **** 				{
1076:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1077:../src/FreeRTOS/tasks.c **** 				}
1078:../src/FreeRTOS/tasks.c **** 			}
1079:../src/FreeRTOS/tasks.c **** 			else
1080:../src/FreeRTOS/tasks.c **** 			{
1081:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1082:../src/FreeRTOS/tasks.c **** 			}
1083:../src/FreeRTOS/tasks.c **** 		}
1084:../src/FreeRTOS/tasks.c **** 
1085:../src/FreeRTOS/tasks.c **** 		uxTaskNumber++;
1086:../src/FreeRTOS/tasks.c **** 
1087:../src/FreeRTOS/tasks.c **** 		#if ( configUSE_TRACE_FACILITY == 1 )
1088:../src/FreeRTOS/tasks.c **** 		{
1089:../src/FreeRTOS/tasks.c **** 			/* Add a counter into the TCB for tracing only. */
1090:../src/FreeRTOS/tasks.c **** 			pxNewTCB->uxTCBNumber = uxTaskNumber;
1091:../src/FreeRTOS/tasks.c **** 		}
1092:../src/FreeRTOS/tasks.c **** 		#endif /* configUSE_TRACE_FACILITY */
1093:../src/FreeRTOS/tasks.c **** 		traceTASK_CREATE( pxNewTCB );
1094:../src/FreeRTOS/tasks.c **** 
1095:../src/FreeRTOS/tasks.c **** 		prvAddTaskToReadyList( pxNewTCB );
1096:../src/FreeRTOS/tasks.c **** 
1097:../src/FreeRTOS/tasks.c **** 		portSETUP_TCB( pxNewTCB );
1098:../src/FreeRTOS/tasks.c **** 	}
1099:../src/FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
1100:../src/FreeRTOS/tasks.c **** 
1101:../src/FreeRTOS/tasks.c **** 	if( xSchedulerRunning != pdFALSE )
1102:../src/FreeRTOS/tasks.c **** 	{
1103:../src/FreeRTOS/tasks.c **** 		/* If the created task is of a higher priority than the current task
1104:../src/FreeRTOS/tasks.c **** 		then it should run now. */
1105:../src/FreeRTOS/tasks.c **** 		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
1106:../src/FreeRTOS/tasks.c **** 		{
1107:../src/FreeRTOS/tasks.c **** 			taskYIELD_IF_USING_PREEMPTION();
1108:../src/FreeRTOS/tasks.c **** 		}
1109:../src/FreeRTOS/tasks.c **** 		else
1110:../src/FreeRTOS/tasks.c **** 		{
1111:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1112:../src/FreeRTOS/tasks.c **** 		}
1113:../src/FreeRTOS/tasks.c **** 	}
1114:../src/FreeRTOS/tasks.c **** 	else
1115:../src/FreeRTOS/tasks.c **** 	{
1116:../src/FreeRTOS/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1117:../src/FreeRTOS/tasks.c **** 	}
1118:../src/FreeRTOS/tasks.c **** }
1119:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1120:../src/FreeRTOS/tasks.c **** 
1121:../src/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
1122:../src/FreeRTOS/tasks.c **** 
1123:../src/FreeRTOS/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
1124:../src/FreeRTOS/tasks.c **** 	{
1125:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
1126:../src/FreeRTOS/tasks.c **** 
1127:../src/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
1128:../src/FreeRTOS/tasks.c **** 		{
1129:../src/FreeRTOS/tasks.c **** 			/* If null is passed in here then it is the calling task that is
1130:../src/FreeRTOS/tasks.c **** 			being deleted. */
1131:../src/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
1132:../src/FreeRTOS/tasks.c **** 
1133:../src/FreeRTOS/tasks.c **** 			/* Remove task from the ready list. */
1134:../src/FreeRTOS/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1135:../src/FreeRTOS/tasks.c **** 			{
1136:../src/FreeRTOS/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1137:../src/FreeRTOS/tasks.c **** 			}
1138:../src/FreeRTOS/tasks.c **** 			else
1139:../src/FreeRTOS/tasks.c **** 			{
1140:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1141:../src/FreeRTOS/tasks.c **** 			}
1142:../src/FreeRTOS/tasks.c **** 
1143:../src/FreeRTOS/tasks.c **** 			/* Is the task waiting on an event also? */
1144:../src/FreeRTOS/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1145:../src/FreeRTOS/tasks.c **** 			{
1146:../src/FreeRTOS/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1147:../src/FreeRTOS/tasks.c **** 			}
1148:../src/FreeRTOS/tasks.c **** 			else
1149:../src/FreeRTOS/tasks.c **** 			{
1150:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1151:../src/FreeRTOS/tasks.c **** 			}
1152:../src/FreeRTOS/tasks.c **** 
1153:../src/FreeRTOS/tasks.c **** 			/* Increment the uxTaskNumber also so kernel aware debuggers can
1154:../src/FreeRTOS/tasks.c **** 			detect that the task lists need re-generating.  This is done before
1155:../src/FreeRTOS/tasks.c **** 			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1156:../src/FreeRTOS/tasks.c **** 			not return. */
1157:../src/FreeRTOS/tasks.c **** 			uxTaskNumber++;
1158:../src/FreeRTOS/tasks.c **** 
1159:../src/FreeRTOS/tasks.c **** 			if( pxTCB == pxCurrentTCB )
1160:../src/FreeRTOS/tasks.c **** 			{
1161:../src/FreeRTOS/tasks.c **** 				/* A task is deleting itself.  This cannot complete within the
1162:../src/FreeRTOS/tasks.c **** 				task itself, as a context switch to another task is required.
1163:../src/FreeRTOS/tasks.c **** 				Place the task in the termination list.  The idle task will
1164:../src/FreeRTOS/tasks.c **** 				check the termination list and free up any memory allocated by
1165:../src/FreeRTOS/tasks.c **** 				the scheduler for the TCB and stack of the deleted task. */
1166:../src/FreeRTOS/tasks.c **** 				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
1167:../src/FreeRTOS/tasks.c **** 
1168:../src/FreeRTOS/tasks.c **** 				/* Increment the ucTasksDeleted variable so the idle task knows
1169:../src/FreeRTOS/tasks.c **** 				there is a task that has been deleted and that it should therefore
1170:../src/FreeRTOS/tasks.c **** 				check the xTasksWaitingTermination list. */
1171:../src/FreeRTOS/tasks.c **** 				++uxDeletedTasksWaitingCleanUp;
1172:../src/FreeRTOS/tasks.c **** 
1173:../src/FreeRTOS/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
1174:../src/FreeRTOS/tasks.c **** 				in which Windows specific clean up operations are performed,
1175:../src/FreeRTOS/tasks.c **** 				after which it is not possible to yield away from this task -
1176:../src/FreeRTOS/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
1177:../src/FreeRTOS/tasks.c **** 				required. */
1178:../src/FreeRTOS/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1179:../src/FreeRTOS/tasks.c **** 			}
1180:../src/FreeRTOS/tasks.c **** 			else
1181:../src/FreeRTOS/tasks.c **** 			{
1182:../src/FreeRTOS/tasks.c **** 				--uxCurrentNumberOfTasks;
1183:../src/FreeRTOS/tasks.c **** 				prvDeleteTCB( pxTCB );
1184:../src/FreeRTOS/tasks.c **** 
1185:../src/FreeRTOS/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
1186:../src/FreeRTOS/tasks.c **** 				the task that has just been deleted. */
1187:../src/FreeRTOS/tasks.c **** 				prvResetNextTaskUnblockTime();
1188:../src/FreeRTOS/tasks.c **** 			}
1189:../src/FreeRTOS/tasks.c **** 
1190:../src/FreeRTOS/tasks.c **** 			traceTASK_DELETE( pxTCB );
1191:../src/FreeRTOS/tasks.c **** 		}
1192:../src/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
1193:../src/FreeRTOS/tasks.c **** 
1194:../src/FreeRTOS/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
1195:../src/FreeRTOS/tasks.c **** 		been deleted. */
1196:../src/FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
1197:../src/FreeRTOS/tasks.c **** 		{
1198:../src/FreeRTOS/tasks.c **** 			if( pxTCB == pxCurrentTCB )
1199:../src/FreeRTOS/tasks.c **** 			{
1200:../src/FreeRTOS/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1201:../src/FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
1202:../src/FreeRTOS/tasks.c **** 			}
1203:../src/FreeRTOS/tasks.c **** 			else
1204:../src/FreeRTOS/tasks.c **** 			{
1205:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1206:../src/FreeRTOS/tasks.c **** 			}
1207:../src/FreeRTOS/tasks.c **** 		}
1208:../src/FreeRTOS/tasks.c **** 	}
1209:../src/FreeRTOS/tasks.c **** 
1210:../src/FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskDelete */
1211:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1212:../src/FreeRTOS/tasks.c **** 
1213:../src/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
1214:../src/FreeRTOS/tasks.c **** 
1215:../src/FreeRTOS/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
1216:../src/FreeRTOS/tasks.c **** 	{
1217:../src/FreeRTOS/tasks.c **** 	TickType_t xTimeToWake;
1218:../src/FreeRTOS/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
1219:../src/FreeRTOS/tasks.c **** 
1220:../src/FreeRTOS/tasks.c **** 		configASSERT( pxPreviousWakeTime );
1221:../src/FreeRTOS/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
1222:../src/FreeRTOS/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
1223:../src/FreeRTOS/tasks.c **** 
1224:../src/FreeRTOS/tasks.c **** 		vTaskSuspendAll();
1225:../src/FreeRTOS/tasks.c **** 		{
1226:../src/FreeRTOS/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1227:../src/FreeRTOS/tasks.c **** 			block. */
1228:../src/FreeRTOS/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
1229:../src/FreeRTOS/tasks.c **** 
1230:../src/FreeRTOS/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
1231:../src/FreeRTOS/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
1232:../src/FreeRTOS/tasks.c **** 
1233:../src/FreeRTOS/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
1234:../src/FreeRTOS/tasks.c **** 			{
1235:../src/FreeRTOS/tasks.c **** 				/* The tick count has overflowed since this function was
1236:../src/FreeRTOS/tasks.c **** 				lasted called.  In this case the only time we should ever
1237:../src/FreeRTOS/tasks.c **** 				actually delay is if the wake time has also	overflowed,
1238:../src/FreeRTOS/tasks.c **** 				and the wake time is greater than the tick time.  When this
1239:../src/FreeRTOS/tasks.c **** 				is the case it is as if neither time had overflowed. */
1240:../src/FreeRTOS/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
1241:../src/FreeRTOS/tasks.c **** 				{
1242:../src/FreeRTOS/tasks.c **** 					xShouldDelay = pdTRUE;
1243:../src/FreeRTOS/tasks.c **** 				}
1244:../src/FreeRTOS/tasks.c **** 				else
1245:../src/FreeRTOS/tasks.c **** 				{
1246:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1247:../src/FreeRTOS/tasks.c **** 				}
1248:../src/FreeRTOS/tasks.c **** 			}
1249:../src/FreeRTOS/tasks.c **** 			else
1250:../src/FreeRTOS/tasks.c **** 			{
1251:../src/FreeRTOS/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
1252:../src/FreeRTOS/tasks.c **** 				delay if either the wake time has overflowed, and/or the
1253:../src/FreeRTOS/tasks.c **** 				tick time is less than the wake time. */
1254:../src/FreeRTOS/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
1255:../src/FreeRTOS/tasks.c **** 				{
1256:../src/FreeRTOS/tasks.c **** 					xShouldDelay = pdTRUE;
1257:../src/FreeRTOS/tasks.c **** 				}
1258:../src/FreeRTOS/tasks.c **** 				else
1259:../src/FreeRTOS/tasks.c **** 				{
1260:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1261:../src/FreeRTOS/tasks.c **** 				}
1262:../src/FreeRTOS/tasks.c **** 			}
1263:../src/FreeRTOS/tasks.c **** 
1264:../src/FreeRTOS/tasks.c **** 			/* Update the wake time ready for the next call. */
1265:../src/FreeRTOS/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
1266:../src/FreeRTOS/tasks.c **** 
1267:../src/FreeRTOS/tasks.c **** 			if( xShouldDelay != pdFALSE )
1268:../src/FreeRTOS/tasks.c **** 			{
1269:../src/FreeRTOS/tasks.c **** 				traceTASK_DELAY_UNTIL( xTimeToWake );
1270:../src/FreeRTOS/tasks.c **** 
1271:../src/FreeRTOS/tasks.c **** 				/* prvAddCurrentTaskToDelayedList() needs the block time, not
1272:../src/FreeRTOS/tasks.c **** 				the time to wake, so subtract the current tick count. */
1273:../src/FreeRTOS/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
1274:../src/FreeRTOS/tasks.c **** 			}
1275:../src/FreeRTOS/tasks.c **** 			else
1276:../src/FreeRTOS/tasks.c **** 			{
1277:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1278:../src/FreeRTOS/tasks.c **** 			}
1279:../src/FreeRTOS/tasks.c **** 		}
1280:../src/FreeRTOS/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
1281:../src/FreeRTOS/tasks.c **** 
1282:../src/FreeRTOS/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1283:../src/FreeRTOS/tasks.c **** 		have put ourselves to sleep. */
1284:../src/FreeRTOS/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
1285:../src/FreeRTOS/tasks.c **** 		{
1286:../src/FreeRTOS/tasks.c **** 			portYIELD_WITHIN_API();
1287:../src/FreeRTOS/tasks.c **** 		}
1288:../src/FreeRTOS/tasks.c **** 		else
1289:../src/FreeRTOS/tasks.c **** 		{
1290:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1291:../src/FreeRTOS/tasks.c **** 		}
1292:../src/FreeRTOS/tasks.c **** 	}
1293:../src/FreeRTOS/tasks.c **** 
1294:../src/FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
1295:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1296:../src/FreeRTOS/tasks.c **** 
1297:../src/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
1298:../src/FreeRTOS/tasks.c **** 
1299:../src/FreeRTOS/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
1300:../src/FreeRTOS/tasks.c **** 	{
1301:../src/FreeRTOS/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
1302:../src/FreeRTOS/tasks.c **** 
1303:../src/FreeRTOS/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
1304:../src/FreeRTOS/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
1305:../src/FreeRTOS/tasks.c **** 		{
1306:../src/FreeRTOS/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
1307:../src/FreeRTOS/tasks.c **** 			vTaskSuspendAll();
1308:../src/FreeRTOS/tasks.c **** 			{
1309:../src/FreeRTOS/tasks.c **** 				traceTASK_DELAY();
1310:../src/FreeRTOS/tasks.c **** 
1311:../src/FreeRTOS/tasks.c **** 				/* A task that is removed from the event list while the
1312:../src/FreeRTOS/tasks.c **** 				scheduler is suspended will not get placed in the ready
1313:../src/FreeRTOS/tasks.c **** 				list or removed from the blocked list until the scheduler
1314:../src/FreeRTOS/tasks.c **** 				is resumed.
1315:../src/FreeRTOS/tasks.c **** 
1316:../src/FreeRTOS/tasks.c **** 				This task cannot be in an event list as it is the currently
1317:../src/FreeRTOS/tasks.c **** 				executing task. */
1318:../src/FreeRTOS/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
1319:../src/FreeRTOS/tasks.c **** 			}
1320:../src/FreeRTOS/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
1321:../src/FreeRTOS/tasks.c **** 		}
1322:../src/FreeRTOS/tasks.c **** 		else
1323:../src/FreeRTOS/tasks.c **** 		{
1324:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1325:../src/FreeRTOS/tasks.c **** 		}
1326:../src/FreeRTOS/tasks.c **** 
1327:../src/FreeRTOS/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1328:../src/FreeRTOS/tasks.c **** 		have put ourselves to sleep. */
1329:../src/FreeRTOS/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
1330:../src/FreeRTOS/tasks.c **** 		{
1331:../src/FreeRTOS/tasks.c **** 			portYIELD_WITHIN_API();
1332:../src/FreeRTOS/tasks.c **** 		}
1333:../src/FreeRTOS/tasks.c **** 		else
1334:../src/FreeRTOS/tasks.c **** 		{
1335:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1336:../src/FreeRTOS/tasks.c **** 		}
1337:../src/FreeRTOS/tasks.c **** 	}
1338:../src/FreeRTOS/tasks.c **** 
1339:../src/FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskDelay */
1340:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1341:../src/FreeRTOS/tasks.c **** 
1342:../src/FreeRTOS/tasks.c **** #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
1343:../src/FreeRTOS/tasks.c **** 
1344:../src/FreeRTOS/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
1345:../src/FreeRTOS/tasks.c **** 	{
1346:../src/FreeRTOS/tasks.c **** 	eTaskState eReturn;
1347:../src/FreeRTOS/tasks.c **** 	List_t *pxStateList;
1348:../src/FreeRTOS/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
1349:../src/FreeRTOS/tasks.c **** 
1350:../src/FreeRTOS/tasks.c **** 		configASSERT( pxTCB );
1351:../src/FreeRTOS/tasks.c **** 
1352:../src/FreeRTOS/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1353:../src/FreeRTOS/tasks.c **** 		{
1354:../src/FreeRTOS/tasks.c **** 			/* The task calling this function is querying its own state. */
1355:../src/FreeRTOS/tasks.c **** 			eReturn = eRunning;
1356:../src/FreeRTOS/tasks.c **** 		}
1357:../src/FreeRTOS/tasks.c **** 		else
1358:../src/FreeRTOS/tasks.c **** 		{
1359:../src/FreeRTOS/tasks.c **** 			taskENTER_CRITICAL();
1360:../src/FreeRTOS/tasks.c **** 			{
1361:../src/FreeRTOS/tasks.c **** 				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
1362:../src/FreeRTOS/tasks.c **** 			}
1363:../src/FreeRTOS/tasks.c **** 			taskEXIT_CRITICAL();
1364:../src/FreeRTOS/tasks.c **** 
1365:../src/FreeRTOS/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
1366:../src/FreeRTOS/tasks.c **** 			{
1367:../src/FreeRTOS/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
1368:../src/FreeRTOS/tasks.c **** 				lists. */
1369:../src/FreeRTOS/tasks.c **** 				eReturn = eBlocked;
1370:../src/FreeRTOS/tasks.c **** 			}
1371:../src/FreeRTOS/tasks.c **** 
1372:../src/FreeRTOS/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1373:../src/FreeRTOS/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
1374:../src/FreeRTOS/tasks.c **** 				{
1375:../src/FreeRTOS/tasks.c **** 					/* The task being queried is referenced from the suspended
1376:../src/FreeRTOS/tasks.c **** 					list.  Is it genuinely suspended or is it block
1377:../src/FreeRTOS/tasks.c **** 					indefinitely? */
1378:../src/FreeRTOS/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1379:../src/FreeRTOS/tasks.c **** 					{
1380:../src/FreeRTOS/tasks.c **** 						eReturn = eSuspended;
1381:../src/FreeRTOS/tasks.c **** 					}
1382:../src/FreeRTOS/tasks.c **** 					else
1383:../src/FreeRTOS/tasks.c **** 					{
1384:../src/FreeRTOS/tasks.c **** 						eReturn = eBlocked;
1385:../src/FreeRTOS/tasks.c **** 					}
1386:../src/FreeRTOS/tasks.c **** 				}
1387:../src/FreeRTOS/tasks.c **** 			#endif
1388:../src/FreeRTOS/tasks.c **** 
1389:../src/FreeRTOS/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1390:../src/FreeRTOS/tasks.c **** 				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
1391:../src/FreeRTOS/tasks.c **** 				{
1392:../src/FreeRTOS/tasks.c **** 					/* The task being queried is referenced from the deleted
1393:../src/FreeRTOS/tasks.c **** 					tasks list, or it is not referenced from any lists at
1394:../src/FreeRTOS/tasks.c **** 					all. */
1395:../src/FreeRTOS/tasks.c **** 					eReturn = eDeleted;
1396:../src/FreeRTOS/tasks.c **** 				}
1397:../src/FreeRTOS/tasks.c **** 			#endif
1398:../src/FreeRTOS/tasks.c **** 
1399:../src/FreeRTOS/tasks.c **** 			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1400:../src/FreeRTOS/tasks.c **** 			{
1401:../src/FreeRTOS/tasks.c **** 				/* If the task is not in any other state, it must be in the
1402:../src/FreeRTOS/tasks.c **** 				Ready (including pending ready) state. */
1403:../src/FreeRTOS/tasks.c **** 				eReturn = eReady;
1404:../src/FreeRTOS/tasks.c **** 			}
1405:../src/FreeRTOS/tasks.c **** 		}
1406:../src/FreeRTOS/tasks.c **** 
1407:../src/FreeRTOS/tasks.c **** 		return eReturn;
1408:../src/FreeRTOS/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1409:../src/FreeRTOS/tasks.c **** 
1410:../src/FreeRTOS/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1411:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1412:../src/FreeRTOS/tasks.c **** 
1413:../src/FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1414:../src/FreeRTOS/tasks.c **** 
1415:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1416:../src/FreeRTOS/tasks.c **** 	{
1417:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
1418:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxReturn;
1419:../src/FreeRTOS/tasks.c **** 
1420:../src/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
1421:../src/FreeRTOS/tasks.c **** 		{
1422:../src/FreeRTOS/tasks.c **** 			/* If null is passed in here then it is the priority of the that
1423:../src/FreeRTOS/tasks.c **** 			called uxTaskPriorityGet() that is being queried. */
1424:../src/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1425:../src/FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1426:../src/FreeRTOS/tasks.c **** 		}
1427:../src/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
1428:../src/FreeRTOS/tasks.c **** 
1429:../src/FreeRTOS/tasks.c **** 		return uxReturn;
1430:../src/FreeRTOS/tasks.c **** 	}
1431:../src/FreeRTOS/tasks.c **** 
1432:../src/FreeRTOS/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1433:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1434:../src/FreeRTOS/tasks.c **** 
1435:../src/FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1436:../src/FreeRTOS/tasks.c **** 
1437:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
1438:../src/FreeRTOS/tasks.c **** 	{
1439:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
1440:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxReturn, uxSavedInterruptState;
1441:../src/FreeRTOS/tasks.c **** 
1442:../src/FreeRTOS/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1443:../src/FreeRTOS/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1444:../src/FreeRTOS/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1445:../src/FreeRTOS/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1446:../src/FreeRTOS/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1447:../src/FreeRTOS/tasks.c **** 		is defined in FreeRTOSConfig.h then
1448:../src/FreeRTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1449:../src/FreeRTOS/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1450:../src/FreeRTOS/tasks.c **** 		been assigned a priority above the configured maximum system call
1451:../src/FreeRTOS/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1452:../src/FreeRTOS/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1453:../src/FreeRTOS/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1454:../src/FreeRTOS/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1455:../src/FreeRTOS/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1456:../src/FreeRTOS/tasks.c **** 		provided on the following link:
1457:../src/FreeRTOS/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1458:../src/FreeRTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1459:../src/FreeRTOS/tasks.c **** 
1460:../src/FreeRTOS/tasks.c **** 		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
1461:../src/FreeRTOS/tasks.c **** 		{
1462:../src/FreeRTOS/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1463:../src/FreeRTOS/tasks.c **** 			task that is being queried. */
1464:../src/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1465:../src/FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1466:../src/FreeRTOS/tasks.c **** 		}
1467:../src/FreeRTOS/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1468:../src/FreeRTOS/tasks.c **** 
1469:../src/FreeRTOS/tasks.c **** 		return uxReturn;
1470:../src/FreeRTOS/tasks.c **** 	}
1471:../src/FreeRTOS/tasks.c **** 
1472:../src/FreeRTOS/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1473:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1474:../src/FreeRTOS/tasks.c **** 
1475:../src/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1476:../src/FreeRTOS/tasks.c **** 
1477:../src/FreeRTOS/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1478:../src/FreeRTOS/tasks.c **** 	{
1479:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
1480:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1481:../src/FreeRTOS/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1482:../src/FreeRTOS/tasks.c **** 
1483:../src/FreeRTOS/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1484:../src/FreeRTOS/tasks.c **** 
1485:../src/FreeRTOS/tasks.c **** 		/* Ensure the new priority is valid. */
1486:../src/FreeRTOS/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
1487:../src/FreeRTOS/tasks.c **** 		{
1488:../src/FreeRTOS/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
1489:../src/FreeRTOS/tasks.c **** 		}
1490:../src/FreeRTOS/tasks.c **** 		else
1491:../src/FreeRTOS/tasks.c **** 		{
1492:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1493:../src/FreeRTOS/tasks.c **** 		}
1494:../src/FreeRTOS/tasks.c **** 
1495:../src/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
1496:../src/FreeRTOS/tasks.c **** 		{
1497:../src/FreeRTOS/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1498:../src/FreeRTOS/tasks.c **** 			task that is being changed. */
1499:../src/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1500:../src/FreeRTOS/tasks.c **** 
1501:../src/FreeRTOS/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1502:../src/FreeRTOS/tasks.c **** 
1503:../src/FreeRTOS/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1504:../src/FreeRTOS/tasks.c **** 			{
1505:../src/FreeRTOS/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
1506:../src/FreeRTOS/tasks.c **** 			}
1507:../src/FreeRTOS/tasks.c **** 			#else
1508:../src/FreeRTOS/tasks.c **** 			{
1509:../src/FreeRTOS/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1510:../src/FreeRTOS/tasks.c **** 			}
1511:../src/FreeRTOS/tasks.c **** 			#endif
1512:../src/FreeRTOS/tasks.c **** 
1513:../src/FreeRTOS/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
1514:../src/FreeRTOS/tasks.c **** 			{
1515:../src/FreeRTOS/tasks.c **** 				/* The priority change may have readied a task of higher
1516:../src/FreeRTOS/tasks.c **** 				priority than the calling task. */
1517:../src/FreeRTOS/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
1518:../src/FreeRTOS/tasks.c **** 				{
1519:../src/FreeRTOS/tasks.c **** 					if( pxTCB != pxCurrentTCB )
1520:../src/FreeRTOS/tasks.c **** 					{
1521:../src/FreeRTOS/tasks.c **** 						/* The priority of a task other than the currently
1522:../src/FreeRTOS/tasks.c **** 						running task is being raised.  Is the priority being
1523:../src/FreeRTOS/tasks.c **** 						raised above that of the running task? */
1524:../src/FreeRTOS/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
1525:../src/FreeRTOS/tasks.c **** 						{
1526:../src/FreeRTOS/tasks.c **** 							xYieldRequired = pdTRUE;
1527:../src/FreeRTOS/tasks.c **** 						}
1528:../src/FreeRTOS/tasks.c **** 						else
1529:../src/FreeRTOS/tasks.c **** 						{
1530:../src/FreeRTOS/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1531:../src/FreeRTOS/tasks.c **** 						}
1532:../src/FreeRTOS/tasks.c **** 					}
1533:../src/FreeRTOS/tasks.c **** 					else
1534:../src/FreeRTOS/tasks.c **** 					{
1535:../src/FreeRTOS/tasks.c **** 						/* The priority of the running task is being raised,
1536:../src/FreeRTOS/tasks.c **** 						but the running task must already be the highest
1537:../src/FreeRTOS/tasks.c **** 						priority task able to run so no yield is required. */
1538:../src/FreeRTOS/tasks.c **** 					}
1539:../src/FreeRTOS/tasks.c **** 				}
1540:../src/FreeRTOS/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
1541:../src/FreeRTOS/tasks.c **** 				{
1542:../src/FreeRTOS/tasks.c **** 					/* Setting the priority of the running task down means
1543:../src/FreeRTOS/tasks.c **** 					there may now be another task of higher priority that
1544:../src/FreeRTOS/tasks.c **** 					is ready to execute. */
1545:../src/FreeRTOS/tasks.c **** 					xYieldRequired = pdTRUE;
1546:../src/FreeRTOS/tasks.c **** 				}
1547:../src/FreeRTOS/tasks.c **** 				else
1548:../src/FreeRTOS/tasks.c **** 				{
1549:../src/FreeRTOS/tasks.c **** 					/* Setting the priority of any other task down does not
1550:../src/FreeRTOS/tasks.c **** 					require a yield as the running task must be above the
1551:../src/FreeRTOS/tasks.c **** 					new priority of the task being modified. */
1552:../src/FreeRTOS/tasks.c **** 				}
1553:../src/FreeRTOS/tasks.c **** 
1554:../src/FreeRTOS/tasks.c **** 				/* Remember the ready list the task might be referenced from
1555:../src/FreeRTOS/tasks.c **** 				before its uxPriority member is changed so the
1556:../src/FreeRTOS/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1557:../src/FreeRTOS/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
1558:../src/FreeRTOS/tasks.c **** 
1559:../src/FreeRTOS/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1560:../src/FreeRTOS/tasks.c **** 				{
1561:../src/FreeRTOS/tasks.c **** 					/* Only change the priority being used if the task is not
1562:../src/FreeRTOS/tasks.c **** 					currently using an inherited priority. */
1563:../src/FreeRTOS/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1564:../src/FreeRTOS/tasks.c **** 					{
1565:../src/FreeRTOS/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
1566:../src/FreeRTOS/tasks.c **** 					}
1567:../src/FreeRTOS/tasks.c **** 					else
1568:../src/FreeRTOS/tasks.c **** 					{
1569:../src/FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1570:../src/FreeRTOS/tasks.c **** 					}
1571:../src/FreeRTOS/tasks.c **** 
1572:../src/FreeRTOS/tasks.c **** 					/* The base priority gets set whatever. */
1573:../src/FreeRTOS/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
1574:../src/FreeRTOS/tasks.c **** 				}
1575:../src/FreeRTOS/tasks.c **** 				#else
1576:../src/FreeRTOS/tasks.c **** 				{
1577:../src/FreeRTOS/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1578:../src/FreeRTOS/tasks.c **** 				}
1579:../src/FreeRTOS/tasks.c **** 				#endif
1580:../src/FreeRTOS/tasks.c **** 
1581:../src/FreeRTOS/tasks.c **** 				/* Only reset the event list item value if the value is not
1582:../src/FreeRTOS/tasks.c **** 				being used for anything else. */
1583:../src/FreeRTOS/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
1584:../src/FreeRTOS/tasks.c **** 				{
1585:../src/FreeRTOS/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
1586:../src/FreeRTOS/tasks.c **** 				}
1587:../src/FreeRTOS/tasks.c **** 				else
1588:../src/FreeRTOS/tasks.c **** 				{
1589:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1590:../src/FreeRTOS/tasks.c **** 				}
1591:../src/FreeRTOS/tasks.c **** 
1592:../src/FreeRTOS/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1593:../src/FreeRTOS/tasks.c **** 				nothing more than change its priority variable. However, if
1594:../src/FreeRTOS/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1595:../src/FreeRTOS/tasks.c **** 				in the list appropriate to its new priority. */
1596:../src/FreeRTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateL
1597:../src/FreeRTOS/tasks.c **** 				{
1598:../src/FreeRTOS/tasks.c **** 					/* The task is currently in its ready list - remove before
1599:../src/FreeRTOS/tasks.c **** 					adding it to it's new ready list.  As we are in a critical
1600:../src/FreeRTOS/tasks.c **** 					section we can do this even if the scheduler is suspended. */
1601:../src/FreeRTOS/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1602:../src/FreeRTOS/tasks.c **** 					{
1603:../src/FreeRTOS/tasks.c **** 						/* It is known that the task is in its ready list so
1604:../src/FreeRTOS/tasks.c **** 						there is no need to check again and the port level
1605:../src/FreeRTOS/tasks.c **** 						reset macro can be called directly. */
1606:../src/FreeRTOS/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1607:../src/FreeRTOS/tasks.c **** 					}
1608:../src/FreeRTOS/tasks.c **** 					else
1609:../src/FreeRTOS/tasks.c **** 					{
1610:../src/FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1611:../src/FreeRTOS/tasks.c **** 					}
1612:../src/FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1613:../src/FreeRTOS/tasks.c **** 				}
1614:../src/FreeRTOS/tasks.c **** 				else
1615:../src/FreeRTOS/tasks.c **** 				{
1616:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1617:../src/FreeRTOS/tasks.c **** 				}
1618:../src/FreeRTOS/tasks.c **** 
1619:../src/FreeRTOS/tasks.c **** 				if( xYieldRequired != pdFALSE )
1620:../src/FreeRTOS/tasks.c **** 				{
1621:../src/FreeRTOS/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1622:../src/FreeRTOS/tasks.c **** 				}
1623:../src/FreeRTOS/tasks.c **** 				else
1624:../src/FreeRTOS/tasks.c **** 				{
1625:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1626:../src/FreeRTOS/tasks.c **** 				}
1627:../src/FreeRTOS/tasks.c **** 
1628:../src/FreeRTOS/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1629:../src/FreeRTOS/tasks.c **** 				optimised task selection is not being used. */
1630:../src/FreeRTOS/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1631:../src/FreeRTOS/tasks.c **** 			}
1632:../src/FreeRTOS/tasks.c **** 		}
1633:../src/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
1634:../src/FreeRTOS/tasks.c **** 	}
1635:../src/FreeRTOS/tasks.c **** 
1636:../src/FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1637:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1638:../src/FreeRTOS/tasks.c **** 
1639:../src/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1640:../src/FreeRTOS/tasks.c **** 
1641:../src/FreeRTOS/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1642:../src/FreeRTOS/tasks.c **** 	{
1643:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
1644:../src/FreeRTOS/tasks.c **** 
1645:../src/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
1646:../src/FreeRTOS/tasks.c **** 		{
1647:../src/FreeRTOS/tasks.c **** 			/* If null is passed in here then it is the running task that is
1648:../src/FreeRTOS/tasks.c **** 			being suspended. */
1649:../src/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
1650:../src/FreeRTOS/tasks.c **** 
1651:../src/FreeRTOS/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1652:../src/FreeRTOS/tasks.c **** 
1653:../src/FreeRTOS/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1654:../src/FreeRTOS/tasks.c **** 			suspended list. */
1655:../src/FreeRTOS/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1656:../src/FreeRTOS/tasks.c **** 			{
1657:../src/FreeRTOS/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1658:../src/FreeRTOS/tasks.c **** 			}
1659:../src/FreeRTOS/tasks.c **** 			else
1660:../src/FreeRTOS/tasks.c **** 			{
1661:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1662:../src/FreeRTOS/tasks.c **** 			}
1663:../src/FreeRTOS/tasks.c **** 
1664:../src/FreeRTOS/tasks.c **** 			/* Is the task waiting on an event also? */
1665:../src/FreeRTOS/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1666:../src/FreeRTOS/tasks.c **** 			{
1667:../src/FreeRTOS/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1668:../src/FreeRTOS/tasks.c **** 			}
1669:../src/FreeRTOS/tasks.c **** 			else
1670:../src/FreeRTOS/tasks.c **** 			{
1671:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1672:../src/FreeRTOS/tasks.c **** 			}
1673:../src/FreeRTOS/tasks.c **** 
1674:../src/FreeRTOS/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
1675:../src/FreeRTOS/tasks.c **** 
1676:../src/FreeRTOS/tasks.c **** 			#if( configUSE_TASK_NOTIFICATIONS == 1 )
1677:../src/FreeRTOS/tasks.c **** 			{
1678:../src/FreeRTOS/tasks.c **** 				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
1679:../src/FreeRTOS/tasks.c **** 				{
1680:../src/FreeRTOS/tasks.c **** 					/* The task was blocked to wait for a notification, but is
1681:../src/FreeRTOS/tasks.c **** 					now suspended, so no notification was received. */
1682:../src/FreeRTOS/tasks.c **** 					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
1683:../src/FreeRTOS/tasks.c **** 				}
1684:../src/FreeRTOS/tasks.c **** 			}
1685:../src/FreeRTOS/tasks.c **** 			#endif
1686:../src/FreeRTOS/tasks.c **** 		}
1687:../src/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
1688:../src/FreeRTOS/tasks.c **** 
1689:../src/FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
1690:../src/FreeRTOS/tasks.c **** 		{
1691:../src/FreeRTOS/tasks.c **** 			/* Reset the next expected unblock time in case it referred to the
1692:../src/FreeRTOS/tasks.c **** 			task that is now in the Suspended state. */
1693:../src/FreeRTOS/tasks.c **** 			taskENTER_CRITICAL();
1694:../src/FreeRTOS/tasks.c **** 			{
1695:../src/FreeRTOS/tasks.c **** 				prvResetNextTaskUnblockTime();
1696:../src/FreeRTOS/tasks.c **** 			}
1697:../src/FreeRTOS/tasks.c **** 			taskEXIT_CRITICAL();
1698:../src/FreeRTOS/tasks.c **** 		}
1699:../src/FreeRTOS/tasks.c **** 		else
1700:../src/FreeRTOS/tasks.c **** 		{
1701:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1702:../src/FreeRTOS/tasks.c **** 		}
1703:../src/FreeRTOS/tasks.c **** 
1704:../src/FreeRTOS/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1705:../src/FreeRTOS/tasks.c **** 		{
1706:../src/FreeRTOS/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
1707:../src/FreeRTOS/tasks.c **** 			{
1708:../src/FreeRTOS/tasks.c **** 				/* The current task has just been suspended. */
1709:../src/FreeRTOS/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1710:../src/FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
1711:../src/FreeRTOS/tasks.c **** 			}
1712:../src/FreeRTOS/tasks.c **** 			else
1713:../src/FreeRTOS/tasks.c **** 			{
1714:../src/FreeRTOS/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1715:../src/FreeRTOS/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1716:../src/FreeRTOS/tasks.c **** 				must be adjusted to point to a different task. */
1717:../src/FreeRTOS/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
1718:../src/FreeRTOS/tasks.c **** 				{
1719:../src/FreeRTOS/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1720:../src/FreeRTOS/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1721:../src/FreeRTOS/tasks.c **** 					be set to point to it no matter what its relative priority
1722:../src/FreeRTOS/tasks.c **** 					is. */
1723:../src/FreeRTOS/tasks.c **** 					pxCurrentTCB = NULL;
1724:../src/FreeRTOS/tasks.c **** 				}
1725:../src/FreeRTOS/tasks.c **** 				else
1726:../src/FreeRTOS/tasks.c **** 				{
1727:../src/FreeRTOS/tasks.c **** 					vTaskSwitchContext();
1728:../src/FreeRTOS/tasks.c **** 				}
1729:../src/FreeRTOS/tasks.c **** 			}
1730:../src/FreeRTOS/tasks.c **** 		}
1731:../src/FreeRTOS/tasks.c **** 		else
1732:../src/FreeRTOS/tasks.c **** 		{
1733:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1734:../src/FreeRTOS/tasks.c **** 		}
1735:../src/FreeRTOS/tasks.c **** 	}
1736:../src/FreeRTOS/tasks.c **** 
1737:../src/FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1738:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1739:../src/FreeRTOS/tasks.c **** 
1740:../src/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1741:../src/FreeRTOS/tasks.c **** 
1742:../src/FreeRTOS/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1743:../src/FreeRTOS/tasks.c **** 	{
1744:../src/FreeRTOS/tasks.c **** 	BaseType_t xReturn = pdFALSE;
1745:../src/FreeRTOS/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
1746:../src/FreeRTOS/tasks.c **** 
1747:../src/FreeRTOS/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1748:../src/FreeRTOS/tasks.c **** 		section. */
1749:../src/FreeRTOS/tasks.c **** 
1750:../src/FreeRTOS/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1751:../src/FreeRTOS/tasks.c **** 		configASSERT( xTask );
1752:../src/FreeRTOS/tasks.c **** 
1753:../src/FreeRTOS/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1754:../src/FreeRTOS/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
1755:../src/FreeRTOS/tasks.c **** 		{
1756:../src/FreeRTOS/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1757:../src/FreeRTOS/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
1758:../src/FreeRTOS/tasks.c **** 			{
1759:../src/FreeRTOS/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1760:../src/FreeRTOS/tasks.c **** 				state, or because is is blocked with no timeout? */
1761:../src/FreeRTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The
1762:../src/FreeRTOS/tasks.c **** 				{
1763:../src/FreeRTOS/tasks.c **** 					xReturn = pdTRUE;
1764:../src/FreeRTOS/tasks.c **** 				}
1765:../src/FreeRTOS/tasks.c **** 				else
1766:../src/FreeRTOS/tasks.c **** 				{
1767:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1768:../src/FreeRTOS/tasks.c **** 				}
1769:../src/FreeRTOS/tasks.c **** 			}
1770:../src/FreeRTOS/tasks.c **** 			else
1771:../src/FreeRTOS/tasks.c **** 			{
1772:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1773:../src/FreeRTOS/tasks.c **** 			}
1774:../src/FreeRTOS/tasks.c **** 		}
1775:../src/FreeRTOS/tasks.c **** 		else
1776:../src/FreeRTOS/tasks.c **** 		{
1777:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1778:../src/FreeRTOS/tasks.c **** 		}
1779:../src/FreeRTOS/tasks.c **** 
1780:../src/FreeRTOS/tasks.c **** 		return xReturn;
1781:../src/FreeRTOS/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1782:../src/FreeRTOS/tasks.c **** 
1783:../src/FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1784:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1785:../src/FreeRTOS/tasks.c **** 
1786:../src/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1787:../src/FreeRTOS/tasks.c **** 
1788:../src/FreeRTOS/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1789:../src/FreeRTOS/tasks.c **** 	{
1790:../src/FreeRTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1791:../src/FreeRTOS/tasks.c **** 
1792:../src/FreeRTOS/tasks.c **** 		/* It does not make sense to resume the calling task. */
1793:../src/FreeRTOS/tasks.c **** 		configASSERT( xTaskToResume );
1794:../src/FreeRTOS/tasks.c **** 
1795:../src/FreeRTOS/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1796:../src/FreeRTOS/tasks.c **** 		currently executing task. */
1797:../src/FreeRTOS/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
1798:../src/FreeRTOS/tasks.c **** 		{
1799:../src/FreeRTOS/tasks.c **** 			taskENTER_CRITICAL();
1800:../src/FreeRTOS/tasks.c **** 			{
1801:../src/FreeRTOS/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1802:../src/FreeRTOS/tasks.c **** 				{
1803:../src/FreeRTOS/tasks.c **** 					traceTASK_RESUME( pxTCB );
1804:../src/FreeRTOS/tasks.c **** 
1805:../src/FreeRTOS/tasks.c **** 					/* The ready list can be accessed even if the scheduler is
1806:../src/FreeRTOS/tasks.c **** 					suspended because this is inside a critical section. */
1807:../src/FreeRTOS/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
1808:../src/FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1809:../src/FreeRTOS/tasks.c **** 
1810:../src/FreeRTOS/tasks.c **** 					/* A higher priority task may have just been resumed. */
1811:../src/FreeRTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1812:../src/FreeRTOS/tasks.c **** 					{
1813:../src/FreeRTOS/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1814:../src/FreeRTOS/tasks.c **** 						but will leave the lists in the correct state for the
1815:../src/FreeRTOS/tasks.c **** 						next yield. */
1816:../src/FreeRTOS/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
1817:../src/FreeRTOS/tasks.c **** 					}
1818:../src/FreeRTOS/tasks.c **** 					else
1819:../src/FreeRTOS/tasks.c **** 					{
1820:../src/FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1821:../src/FreeRTOS/tasks.c **** 					}
1822:../src/FreeRTOS/tasks.c **** 				}
1823:../src/FreeRTOS/tasks.c **** 				else
1824:../src/FreeRTOS/tasks.c **** 				{
1825:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1826:../src/FreeRTOS/tasks.c **** 				}
1827:../src/FreeRTOS/tasks.c **** 			}
1828:../src/FreeRTOS/tasks.c **** 			taskEXIT_CRITICAL();
1829:../src/FreeRTOS/tasks.c **** 		}
1830:../src/FreeRTOS/tasks.c **** 		else
1831:../src/FreeRTOS/tasks.c **** 		{
1832:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1833:../src/FreeRTOS/tasks.c **** 		}
1834:../src/FreeRTOS/tasks.c **** 	}
1835:../src/FreeRTOS/tasks.c **** 
1836:../src/FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1837:../src/FreeRTOS/tasks.c **** 
1838:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1839:../src/FreeRTOS/tasks.c **** 
1840:../src/FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1841:../src/FreeRTOS/tasks.c **** 
1842:../src/FreeRTOS/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1843:../src/FreeRTOS/tasks.c **** 	{
1844:../src/FreeRTOS/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1845:../src/FreeRTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1846:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1847:../src/FreeRTOS/tasks.c **** 
1848:../src/FreeRTOS/tasks.c **** 		configASSERT( xTaskToResume );
1849:../src/FreeRTOS/tasks.c **** 
1850:../src/FreeRTOS/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1851:../src/FreeRTOS/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1852:../src/FreeRTOS/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1853:../src/FreeRTOS/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1854:../src/FreeRTOS/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1855:../src/FreeRTOS/tasks.c **** 		is defined in FreeRTOSConfig.h then
1856:../src/FreeRTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1857:../src/FreeRTOS/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1858:../src/FreeRTOS/tasks.c **** 		been assigned a priority above the configured maximum system call
1859:../src/FreeRTOS/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1860:../src/FreeRTOS/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1861:../src/FreeRTOS/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1862:../src/FreeRTOS/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1863:../src/FreeRTOS/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1864:../src/FreeRTOS/tasks.c **** 		provided on the following link:
1865:../src/FreeRTOS/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1866:../src/FreeRTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1867:../src/FreeRTOS/tasks.c **** 
1868:../src/FreeRTOS/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1869:../src/FreeRTOS/tasks.c **** 		{
1870:../src/FreeRTOS/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1871:../src/FreeRTOS/tasks.c **** 			{
1872:../src/FreeRTOS/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1873:../src/FreeRTOS/tasks.c **** 
1874:../src/FreeRTOS/tasks.c **** 				/* Check the ready lists can be accessed. */
1875:../src/FreeRTOS/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1876:../src/FreeRTOS/tasks.c **** 				{
1877:../src/FreeRTOS/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1878:../src/FreeRTOS/tasks.c **** 					suspended list to the ready list directly. */
1879:../src/FreeRTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1880:../src/FreeRTOS/tasks.c **** 					{
1881:../src/FreeRTOS/tasks.c **** 						xYieldRequired = pdTRUE;
1882:../src/FreeRTOS/tasks.c **** 					}
1883:../src/FreeRTOS/tasks.c **** 					else
1884:../src/FreeRTOS/tasks.c **** 					{
1885:../src/FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1886:../src/FreeRTOS/tasks.c **** 					}
1887:../src/FreeRTOS/tasks.c **** 
1888:../src/FreeRTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1889:../src/FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1890:../src/FreeRTOS/tasks.c **** 				}
1891:../src/FreeRTOS/tasks.c **** 				else
1892:../src/FreeRTOS/tasks.c **** 				{
1893:../src/FreeRTOS/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1894:../src/FreeRTOS/tasks.c **** 					is held in the pending ready list until the scheduler is
1895:../src/FreeRTOS/tasks.c **** 					unsuspended. */
1896:../src/FreeRTOS/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1897:../src/FreeRTOS/tasks.c **** 				}
1898:../src/FreeRTOS/tasks.c **** 			}
1899:../src/FreeRTOS/tasks.c **** 			else
1900:../src/FreeRTOS/tasks.c **** 			{
1901:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1902:../src/FreeRTOS/tasks.c **** 			}
1903:../src/FreeRTOS/tasks.c **** 		}
1904:../src/FreeRTOS/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1905:../src/FreeRTOS/tasks.c **** 
1906:../src/FreeRTOS/tasks.c **** 		return xYieldRequired;
1907:../src/FreeRTOS/tasks.c **** 	}
1908:../src/FreeRTOS/tasks.c **** 
1909:../src/FreeRTOS/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1910:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1911:../src/FreeRTOS/tasks.c **** 
1912:../src/FreeRTOS/tasks.c **** void vTaskStartScheduler( void )
1913:../src/FreeRTOS/tasks.c **** {
1914:../src/FreeRTOS/tasks.c **** BaseType_t xReturn;
1915:../src/FreeRTOS/tasks.c **** 
1916:../src/FreeRTOS/tasks.c **** 	/* Add the idle task at the lowest priority. */
1917:../src/FreeRTOS/tasks.c **** 	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1918:../src/FreeRTOS/tasks.c **** 	{
1919:../src/FreeRTOS/tasks.c **** 		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1920:../src/FreeRTOS/tasks.c **** 		StackType_t *pxIdleTaskStackBuffer = NULL;
1921:../src/FreeRTOS/tasks.c **** 		uint32_t ulIdleTaskStackSize;
1922:../src/FreeRTOS/tasks.c **** 
1923:../src/FreeRTOS/tasks.c **** 		/* The Idle task is created using user provided RAM - obtain the
1924:../src/FreeRTOS/tasks.c **** 		address of the RAM then create the idle task. */
1925:../src/FreeRTOS/tasks.c **** 		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize
1926:../src/FreeRTOS/tasks.c **** 		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1927:../src/FreeRTOS/tasks.c **** 												configIDLE_TASK_NAME,
1928:../src/FreeRTOS/tasks.c **** 												ulIdleTaskStackSize,
1929:../src/FreeRTOS/tasks.c **** 												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
1930:../src/FreeRTOS/tasks.c **** 												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1931:../src/FreeRTOS/tasks.c **** 												pxIdleTaskStackBuffer,
1932:../src/FreeRTOS/tasks.c **** 												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant
1933:../src/FreeRTOS/tasks.c **** 
1934:../src/FreeRTOS/tasks.c **** 		if( xIdleTaskHandle != NULL )
1935:../src/FreeRTOS/tasks.c **** 		{
1936:../src/FreeRTOS/tasks.c **** 			xReturn = pdPASS;
1937:../src/FreeRTOS/tasks.c **** 		}
1938:../src/FreeRTOS/tasks.c **** 		else
1939:../src/FreeRTOS/tasks.c **** 		{
1940:../src/FreeRTOS/tasks.c **** 			xReturn = pdFAIL;
1941:../src/FreeRTOS/tasks.c **** 		}
1942:../src/FreeRTOS/tasks.c **** 	}
1943:../src/FreeRTOS/tasks.c **** 	#else
1944:../src/FreeRTOS/tasks.c **** 	{
1945:../src/FreeRTOS/tasks.c **** 		/* The Idle task is being created using dynamically allocated RAM. */
1946:../src/FreeRTOS/tasks.c **** 		xReturn = xTaskCreate(	prvIdleTask,
1947:../src/FreeRTOS/tasks.c **** 								configIDLE_TASK_NAME,
1948:../src/FreeRTOS/tasks.c **** 								configMINIMAL_STACK_SIZE,
1949:../src/FreeRTOS/tasks.c **** 								( void * ) NULL,
1950:../src/FreeRTOS/tasks.c **** 								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1951:../src/FreeRTOS/tasks.c **** 								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explic
1952:../src/FreeRTOS/tasks.c **** 	}
1953:../src/FreeRTOS/tasks.c **** 	#endif /* configSUPPORT_STATIC_ALLOCATION */
1954:../src/FreeRTOS/tasks.c **** 
1955:../src/FreeRTOS/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1956:../src/FreeRTOS/tasks.c **** 	{
1957:../src/FreeRTOS/tasks.c **** 		if( xReturn == pdPASS )
1958:../src/FreeRTOS/tasks.c **** 		{
1959:../src/FreeRTOS/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1960:../src/FreeRTOS/tasks.c **** 		}
1961:../src/FreeRTOS/tasks.c **** 		else
1962:../src/FreeRTOS/tasks.c **** 		{
1963:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1964:../src/FreeRTOS/tasks.c **** 		}
1965:../src/FreeRTOS/tasks.c **** 	}
1966:../src/FreeRTOS/tasks.c **** 	#endif /* configUSE_TIMERS */
1967:../src/FreeRTOS/tasks.c **** 
1968:../src/FreeRTOS/tasks.c **** 	if( xReturn == pdPASS )
1969:../src/FreeRTOS/tasks.c **** 	{
1970:../src/FreeRTOS/tasks.c **** 		/* freertos_tasks_c_additions_init() should only be called if the user
1971:../src/FreeRTOS/tasks.c **** 		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
1972:../src/FreeRTOS/tasks.c **** 		the only macro called by the function. */
1973:../src/FreeRTOS/tasks.c **** 		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
1974:../src/FreeRTOS/tasks.c **** 		{
1975:../src/FreeRTOS/tasks.c **** 			freertos_tasks_c_additions_init();
1976:../src/FreeRTOS/tasks.c **** 		}
1977:../src/FreeRTOS/tasks.c **** 		#endif
1978:../src/FreeRTOS/tasks.c **** 
1979:../src/FreeRTOS/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1980:../src/FreeRTOS/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1981:../src/FreeRTOS/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1982:../src/FreeRTOS/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1983:../src/FreeRTOS/tasks.c **** 		starts to run. */
1984:../src/FreeRTOS/tasks.c **** 		portDISABLE_INTERRUPTS();
1985:../src/FreeRTOS/tasks.c **** 
1986:../src/FreeRTOS/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1987:../src/FreeRTOS/tasks.c **** 		{
1988:../src/FreeRTOS/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
1989:../src/FreeRTOS/tasks.c **** 			structure specific to the task that will run first. */
1990:../src/FreeRTOS/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1991:../src/FreeRTOS/tasks.c **** 		}
1992:../src/FreeRTOS/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
1993:../src/FreeRTOS/tasks.c **** 
1994:../src/FreeRTOS/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
1995:../src/FreeRTOS/tasks.c **** 		xSchedulerRunning = pdTRUE;
1996:../src/FreeRTOS/tasks.c **** 		xTickCount = ( TickType_t ) 0U;
1997:../src/FreeRTOS/tasks.c **** 
1998:../src/FreeRTOS/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1999:../src/FreeRTOS/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
2000:../src/FreeRTOS/tasks.c **** 		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
2001:../src/FreeRTOS/tasks.c **** 		is set to 0 and the following line fails to build then ensure you do not
2002:../src/FreeRTOS/tasks.c **** 		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
2003:../src/FreeRTOS/tasks.c **** 		FreeRTOSConfig.h file. */
2004:../src/FreeRTOS/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
2005:../src/FreeRTOS/tasks.c **** 
2006:../src/FreeRTOS/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
2007:../src/FreeRTOS/tasks.c **** 		portable interface. */
2008:../src/FreeRTOS/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
2009:../src/FreeRTOS/tasks.c **** 		{
2010:../src/FreeRTOS/tasks.c **** 			/* Should not reach here as if the scheduler is running the
2011:../src/FreeRTOS/tasks.c **** 			function will not return. */
2012:../src/FreeRTOS/tasks.c **** 		}
2013:../src/FreeRTOS/tasks.c **** 		else
2014:../src/FreeRTOS/tasks.c **** 		{
2015:../src/FreeRTOS/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
2016:../src/FreeRTOS/tasks.c **** 		}
2017:../src/FreeRTOS/tasks.c **** 	}
2018:../src/FreeRTOS/tasks.c **** 	else
2019:../src/FreeRTOS/tasks.c **** 	{
2020:../src/FreeRTOS/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
2021:../src/FreeRTOS/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
2022:../src/FreeRTOS/tasks.c **** 		or the timer task. */
2023:../src/FreeRTOS/tasks.c **** 		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
2024:../src/FreeRTOS/tasks.c **** 	}
2025:../src/FreeRTOS/tasks.c **** 
2026:../src/FreeRTOS/tasks.c **** 	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
2027:../src/FreeRTOS/tasks.c **** 	meaning xIdleTaskHandle is not used anywhere else. */
2028:../src/FreeRTOS/tasks.c **** 	( void ) xIdleTaskHandle;
2029:../src/FreeRTOS/tasks.c **** }
2030:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2031:../src/FreeRTOS/tasks.c **** 
2032:../src/FreeRTOS/tasks.c **** void vTaskEndScheduler( void )
2033:../src/FreeRTOS/tasks.c **** {
2034:../src/FreeRTOS/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
2035:../src/FreeRTOS/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
2036:../src/FreeRTOS/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
2037:../src/FreeRTOS/tasks.c **** 	portDISABLE_INTERRUPTS();
2038:../src/FreeRTOS/tasks.c **** 	xSchedulerRunning = pdFALSE;
2039:../src/FreeRTOS/tasks.c **** 	vPortEndScheduler();
2040:../src/FreeRTOS/tasks.c **** }
2041:../src/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
2042:../src/FreeRTOS/tasks.c **** 
2043:../src/FreeRTOS/tasks.c **** void vTaskSuspendAll( void )
2044:../src/FreeRTOS/tasks.c **** {
2045:../src/FreeRTOS/tasks.c **** 	/* A critical section is not required as the variable is of type
2046:../src/FreeRTOS/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
2047:../src/FreeRTOS/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
2048:../src/FreeRTOS/tasks.c **** 	http://goo.gl/wu4acr */
2049:../src/FreeRTOS/tasks.c **** 	++uxSchedulerSuspended;
2050:../src/FreeRTOS/tasks.c **** }
2051:../src/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
2052:../src/FreeRTOS/tasks.c **** 
2053:../src/FreeRTOS/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2054:../src/FreeRTOS/tasks.c **** 
2055:../src/FreeRTOS/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
2056:../src/FreeRTOS/tasks.c **** 	{
2057:../src/FreeRTOS/tasks.c **** 	TickType_t xReturn;
2058:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
2059:../src/FreeRTOS/tasks.c **** 
2060:../src/FreeRTOS/tasks.c **** 		/* uxHigherPriorityReadyTasks takes care of the case where
2061:../src/FreeRTOS/tasks.c **** 		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
2062:../src/FreeRTOS/tasks.c **** 		task that are in the Ready state, even though the idle task is
2063:../src/FreeRTOS/tasks.c **** 		running. */
2064:../src/FreeRTOS/tasks.c **** 		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
2065:../src/FreeRTOS/tasks.c **** 		{
2066:../src/FreeRTOS/tasks.c **** 			if( uxTopReadyPriority > tskIDLE_PRIORITY )
2067:../src/FreeRTOS/tasks.c **** 			{
2068:../src/FreeRTOS/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2069:../src/FreeRTOS/tasks.c **** 			}
2070:../src/FreeRTOS/tasks.c **** 		}
2071:../src/FreeRTOS/tasks.c **** 		#else
2072:../src/FreeRTOS/tasks.c **** 		{
2073:../src/FreeRTOS/tasks.c **** 			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
2074:../src/FreeRTOS/tasks.c **** 
2075:../src/FreeRTOS/tasks.c **** 			/* When port optimised task selection is used the uxTopReadyPriority
2076:../src/FreeRTOS/tasks.c **** 			variable is used as a bit map.  If bits other than the least
2077:../src/FreeRTOS/tasks.c **** 			significant bit are set then there are tasks that have a priority
2078:../src/FreeRTOS/tasks.c **** 			above the idle priority that are in the Ready state.  This takes
2079:../src/FreeRTOS/tasks.c **** 			care of the case where the co-operative scheduler is in use. */
2080:../src/FreeRTOS/tasks.c **** 			if( uxTopReadyPriority > uxLeastSignificantBit )
2081:../src/FreeRTOS/tasks.c **** 			{
2082:../src/FreeRTOS/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2083:../src/FreeRTOS/tasks.c **** 			}
2084:../src/FreeRTOS/tasks.c **** 		}
2085:../src/FreeRTOS/tasks.c **** 		#endif
2086:../src/FreeRTOS/tasks.c **** 
2087:../src/FreeRTOS/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
2088:../src/FreeRTOS/tasks.c **** 		{
2089:../src/FreeRTOS/tasks.c **** 			xReturn = 0;
2090:../src/FreeRTOS/tasks.c **** 		}
2091:../src/FreeRTOS/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
2092:../src/FreeRTOS/tasks.c **** 		{
2093:../src/FreeRTOS/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
2094:../src/FreeRTOS/tasks.c **** 			time slicing is used then the very next tick interrupt must be
2095:../src/FreeRTOS/tasks.c **** 			processed. */
2096:../src/FreeRTOS/tasks.c **** 			xReturn = 0;
2097:../src/FreeRTOS/tasks.c **** 		}
2098:../src/FreeRTOS/tasks.c **** 		else if( uxHigherPriorityReadyTasks != pdFALSE )
2099:../src/FreeRTOS/tasks.c **** 		{
2100:../src/FreeRTOS/tasks.c **** 			/* There are tasks in the Ready state that have a priority above the
2101:../src/FreeRTOS/tasks.c **** 			idle priority.  This path can only be reached if
2102:../src/FreeRTOS/tasks.c **** 			configUSE_PREEMPTION is 0. */
2103:../src/FreeRTOS/tasks.c **** 			xReturn = 0;
2104:../src/FreeRTOS/tasks.c **** 		}
2105:../src/FreeRTOS/tasks.c **** 		else
2106:../src/FreeRTOS/tasks.c **** 		{
2107:../src/FreeRTOS/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
2108:../src/FreeRTOS/tasks.c **** 		}
2109:../src/FreeRTOS/tasks.c **** 
2110:../src/FreeRTOS/tasks.c **** 		return xReturn;
2111:../src/FreeRTOS/tasks.c **** 	}
2112:../src/FreeRTOS/tasks.c **** 
2113:../src/FreeRTOS/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2114:../src/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
2115:../src/FreeRTOS/tasks.c **** 
2116:../src/FreeRTOS/tasks.c **** BaseType_t xTaskResumeAll( void )
2117:../src/FreeRTOS/tasks.c **** {
2118:../src/FreeRTOS/tasks.c **** TCB_t *pxTCB = NULL;
2119:../src/FreeRTOS/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
2120:../src/FreeRTOS/tasks.c **** 
2121:../src/FreeRTOS/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
2122:../src/FreeRTOS/tasks.c **** 	previous call to vTaskSuspendAll(). */
2123:../src/FreeRTOS/tasks.c **** 	configASSERT( uxSchedulerSuspended );
2124:../src/FreeRTOS/tasks.c **** 
2125:../src/FreeRTOS/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
2126:../src/FreeRTOS/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
2127:../src/FreeRTOS/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
2128:../src/FreeRTOS/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
2129:../src/FreeRTOS/tasks.c **** 	tasks from this list into their appropriate ready list. */
2130:../src/FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
2131:../src/FreeRTOS/tasks.c **** 	{
2132:../src/FreeRTOS/tasks.c **** 		--uxSchedulerSuspended;
2133:../src/FreeRTOS/tasks.c **** 
2134:../src/FreeRTOS/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2135:../src/FreeRTOS/tasks.c **** 		{
2136:../src/FreeRTOS/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
2137:../src/FreeRTOS/tasks.c **** 			{
2138:../src/FreeRTOS/tasks.c **** 				/* Move any readied tasks from the pending list into the
2139:../src/FreeRTOS/tasks.c **** 				appropriate ready list. */
2140:../src/FreeRTOS/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
2141:../src/FreeRTOS/tasks.c **** 				{
2142:../src/FreeRTOS/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
2143:../src/FreeRTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2144:../src/FreeRTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2145:../src/FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
2146:../src/FreeRTOS/tasks.c **** 
2147:../src/FreeRTOS/tasks.c **** 					/* If the moved task has a priority higher than the current
2148:../src/FreeRTOS/tasks.c **** 					task then a yield must be performed. */
2149:../src/FreeRTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2150:../src/FreeRTOS/tasks.c **** 					{
2151:../src/FreeRTOS/tasks.c **** 						xYieldPending = pdTRUE;
2152:../src/FreeRTOS/tasks.c **** 					}
2153:../src/FreeRTOS/tasks.c **** 					else
2154:../src/FreeRTOS/tasks.c **** 					{
2155:../src/FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2156:../src/FreeRTOS/tasks.c **** 					}
2157:../src/FreeRTOS/tasks.c **** 				}
2158:../src/FreeRTOS/tasks.c **** 
2159:../src/FreeRTOS/tasks.c **** 				if( pxTCB != NULL )
2160:../src/FreeRTOS/tasks.c **** 				{
2161:../src/FreeRTOS/tasks.c **** 					/* A task was unblocked while the scheduler was suspended,
2162:../src/FreeRTOS/tasks.c **** 					which may have prevented the next unblock time from being
2163:../src/FreeRTOS/tasks.c **** 					re-calculated, in which case re-calculate it now.  Mainly
2164:../src/FreeRTOS/tasks.c **** 					important for low power tickless implementations, where
2165:../src/FreeRTOS/tasks.c **** 					this can prevent an unnecessary exit from low power
2166:../src/FreeRTOS/tasks.c **** 					state. */
2167:../src/FreeRTOS/tasks.c **** 					prvResetNextTaskUnblockTime();
2168:../src/FreeRTOS/tasks.c **** 				}
2169:../src/FreeRTOS/tasks.c **** 
2170:../src/FreeRTOS/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
2171:../src/FreeRTOS/tasks.c **** 				they should be processed now.  This ensures the tick count does
2172:../src/FreeRTOS/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
2173:../src/FreeRTOS/tasks.c **** 				time. */
2174:../src/FreeRTOS/tasks.c **** 				{
2175:../src/FreeRTOS/tasks.c **** 					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
2176:../src/FreeRTOS/tasks.c **** 
2177:../src/FreeRTOS/tasks.c **** 					if( uxPendedCounts > ( UBaseType_t ) 0U )
2178:../src/FreeRTOS/tasks.c **** 					{
2179:../src/FreeRTOS/tasks.c **** 						do
2180:../src/FreeRTOS/tasks.c **** 						{
2181:../src/FreeRTOS/tasks.c **** 							if( xTaskIncrementTick() != pdFALSE )
2182:../src/FreeRTOS/tasks.c **** 							{
2183:../src/FreeRTOS/tasks.c **** 								xYieldPending = pdTRUE;
2184:../src/FreeRTOS/tasks.c **** 							}
2185:../src/FreeRTOS/tasks.c **** 							else
2186:../src/FreeRTOS/tasks.c **** 							{
2187:../src/FreeRTOS/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
2188:../src/FreeRTOS/tasks.c **** 							}
2189:../src/FreeRTOS/tasks.c **** 							--uxPendedCounts;
2190:../src/FreeRTOS/tasks.c **** 						} while( uxPendedCounts > ( UBaseType_t ) 0U );
2191:../src/FreeRTOS/tasks.c **** 
2192:../src/FreeRTOS/tasks.c **** 						uxPendedTicks = 0;
2193:../src/FreeRTOS/tasks.c **** 					}
2194:../src/FreeRTOS/tasks.c **** 					else
2195:../src/FreeRTOS/tasks.c **** 					{
2196:../src/FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2197:../src/FreeRTOS/tasks.c **** 					}
2198:../src/FreeRTOS/tasks.c **** 				}
2199:../src/FreeRTOS/tasks.c **** 
2200:../src/FreeRTOS/tasks.c **** 				if( xYieldPending != pdFALSE )
2201:../src/FreeRTOS/tasks.c **** 				{
2202:../src/FreeRTOS/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
2203:../src/FreeRTOS/tasks.c **** 					{
2204:../src/FreeRTOS/tasks.c **** 						xAlreadyYielded = pdTRUE;
2205:../src/FreeRTOS/tasks.c **** 					}
2206:../src/FreeRTOS/tasks.c **** 					#endif
2207:../src/FreeRTOS/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
2208:../src/FreeRTOS/tasks.c **** 				}
2209:../src/FreeRTOS/tasks.c **** 				else
2210:../src/FreeRTOS/tasks.c **** 				{
2211:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2212:../src/FreeRTOS/tasks.c **** 				}
2213:../src/FreeRTOS/tasks.c **** 			}
2214:../src/FreeRTOS/tasks.c **** 		}
2215:../src/FreeRTOS/tasks.c **** 		else
2216:../src/FreeRTOS/tasks.c **** 		{
2217:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2218:../src/FreeRTOS/tasks.c **** 		}
2219:../src/FreeRTOS/tasks.c **** 	}
2220:../src/FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
2221:../src/FreeRTOS/tasks.c **** 
2222:../src/FreeRTOS/tasks.c **** 	return xAlreadyYielded;
2223:../src/FreeRTOS/tasks.c **** }
2224:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2225:../src/FreeRTOS/tasks.c **** 
2226:../src/FreeRTOS/tasks.c **** TickType_t xTaskGetTickCount( void )
2227:../src/FreeRTOS/tasks.c **** {
2228:../src/FreeRTOS/tasks.c **** TickType_t xTicks;
2229:../src/FreeRTOS/tasks.c **** 
2230:../src/FreeRTOS/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
2231:../src/FreeRTOS/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
2232:../src/FreeRTOS/tasks.c **** 	{
2233:../src/FreeRTOS/tasks.c **** 		xTicks = xTickCount;
2234:../src/FreeRTOS/tasks.c **** 	}
2235:../src/FreeRTOS/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
2236:../src/FreeRTOS/tasks.c **** 
2237:../src/FreeRTOS/tasks.c **** 	return xTicks;
2238:../src/FreeRTOS/tasks.c **** }
2239:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2240:../src/FreeRTOS/tasks.c **** 
2241:../src/FreeRTOS/tasks.c **** TickType_t xTaskGetIdleTickCount( void )
2242:../src/FreeRTOS/tasks.c **** {
2243:../src/FreeRTOS/tasks.c **** TickType_t xTicks;
2244:../src/FreeRTOS/tasks.c **** 
2245:../src/FreeRTOS/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
2246:../src/FreeRTOS/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
2247:../src/FreeRTOS/tasks.c **** 	{
2248:../src/FreeRTOS/tasks.c **** 		xTicks = xIdleTickCount;
2249:../src/FreeRTOS/tasks.c **** 	}
2250:../src/FreeRTOS/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
2251:../src/FreeRTOS/tasks.c **** 
2252:../src/FreeRTOS/tasks.c **** 	return xTicks;
2253:../src/FreeRTOS/tasks.c **** }
2254:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2255:../src/FreeRTOS/tasks.c **** 
2256:../src/FreeRTOS/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
2257:../src/FreeRTOS/tasks.c **** {
2258:../src/FreeRTOS/tasks.c **** TickType_t xReturn;
2259:../src/FreeRTOS/tasks.c **** UBaseType_t uxSavedInterruptStatus;
2260:../src/FreeRTOS/tasks.c **** 
2261:../src/FreeRTOS/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
2262:../src/FreeRTOS/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
2263:../src/FreeRTOS/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
2264:../src/FreeRTOS/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
2265:../src/FreeRTOS/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2266:../src/FreeRTOS/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2267:../src/FreeRTOS/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
2268:../src/FreeRTOS/tasks.c **** 	assigned a priority above the configured maximum system call priority.
2269:../src/FreeRTOS/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
2270:../src/FreeRTOS/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
2271:../src/FreeRTOS/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2272:../src/FreeRTOS/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
2273:../src/FreeRTOS/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
2274:../src/FreeRTOS/tasks.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
2275:../src/FreeRTOS/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2276:../src/FreeRTOS/tasks.c **** 
2277:../src/FreeRTOS/tasks.c **** 	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
2278:../src/FreeRTOS/tasks.c **** 	{
2279:../src/FreeRTOS/tasks.c **** 		xReturn = xTickCount;
2280:../src/FreeRTOS/tasks.c **** 	}
2281:../src/FreeRTOS/tasks.c **** 	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2282:../src/FreeRTOS/tasks.c **** 
2283:../src/FreeRTOS/tasks.c **** 	return xReturn;
2284:../src/FreeRTOS/tasks.c **** }
2285:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2286:../src/FreeRTOS/tasks.c **** 
2287:../src/FreeRTOS/tasks.c **** TickType_t xTaskGetIdleTickCountFromISR( void )
2288:../src/FreeRTOS/tasks.c **** {
2289:../src/FreeRTOS/tasks.c **** TickType_t xReturn;
2290:../src/FreeRTOS/tasks.c **** UBaseType_t uxSavedInterruptStatus;
2291:../src/FreeRTOS/tasks.c **** 
2292:../src/FreeRTOS/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
2293:../src/FreeRTOS/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
2294:../src/FreeRTOS/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
2295:../src/FreeRTOS/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
2296:../src/FreeRTOS/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2297:../src/FreeRTOS/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2298:../src/FreeRTOS/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
2299:../src/FreeRTOS/tasks.c **** 	assigned a priority above the configured maximum system call priority.
2300:../src/FreeRTOS/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
2301:../src/FreeRTOS/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
2302:../src/FreeRTOS/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2303:../src/FreeRTOS/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
2304:../src/FreeRTOS/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
2305:../src/FreeRTOS/tasks.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
2306:../src/FreeRTOS/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2307:../src/FreeRTOS/tasks.c **** 
2308:../src/FreeRTOS/tasks.c **** 	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
2309:../src/FreeRTOS/tasks.c **** 	{
2310:../src/FreeRTOS/tasks.c **** 		xReturn = xIdleTickCount;
2311:../src/FreeRTOS/tasks.c **** 	}
2312:../src/FreeRTOS/tasks.c **** 	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2313:../src/FreeRTOS/tasks.c **** 
2314:../src/FreeRTOS/tasks.c **** 	return xReturn;
2315:../src/FreeRTOS/tasks.c **** }
2316:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2317:../src/FreeRTOS/tasks.c **** 
2318:../src/FreeRTOS/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
2319:../src/FreeRTOS/tasks.c **** {
2320:../src/FreeRTOS/tasks.c **** 	/* A critical section is not required because the variables are of type
2321:../src/FreeRTOS/tasks.c **** 	BaseType_t. */
2322:../src/FreeRTOS/tasks.c **** 	return uxCurrentNumberOfTasks;
2323:../src/FreeRTOS/tasks.c **** }
2324:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2325:../src/FreeRTOS/tasks.c **** 
2326:../src/FreeRTOS/tasks.c **** char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed fo
2327:../src/FreeRTOS/tasks.c **** {
2328:../src/FreeRTOS/tasks.c **** TCB_t *pxTCB;
2329:../src/FreeRTOS/tasks.c **** 
2330:../src/FreeRTOS/tasks.c **** 	/* If null is passed in here then the name of the calling task is being
2331:../src/FreeRTOS/tasks.c **** 	queried. */
2332:../src/FreeRTOS/tasks.c **** 	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
2333:../src/FreeRTOS/tasks.c **** 	configASSERT( pxTCB );
2334:../src/FreeRTOS/tasks.c **** 	return &( pxTCB->pcTaskName[ 0 ] );
2335:../src/FreeRTOS/tasks.c **** }
2336:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2337:../src/FreeRTOS/tasks.c **** 
2338:../src/FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2339:../src/FreeRTOS/tasks.c **** 
2340:../src/FreeRTOS/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
2341:../src/FreeRTOS/tasks.c **** 	{
2342:../src/FreeRTOS/tasks.c **** 	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
2343:../src/FreeRTOS/tasks.c **** 	UBaseType_t x;
2344:../src/FreeRTOS/tasks.c **** 	char cNextChar;
2345:../src/FreeRTOS/tasks.c **** 
2346:../src/FreeRTOS/tasks.c **** 		/* This function is called with the scheduler suspended. */
2347:../src/FreeRTOS/tasks.c **** 
2348:../src/FreeRTOS/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2349:../src/FreeRTOS/tasks.c **** 		{
2350:../src/FreeRTOS/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2351:../src/FreeRTOS/tasks.c **** 
2352:../src/FreeRTOS/tasks.c **** 			do
2353:../src/FreeRTOS/tasks.c **** 			{
2354:../src/FreeRTOS/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2355:../src/FreeRTOS/tasks.c **** 
2356:../src/FreeRTOS/tasks.c **** 				/* Check each character in the name looking for a match or
2357:../src/FreeRTOS/tasks.c **** 				mismatch. */
2358:../src/FreeRTOS/tasks.c **** 				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2359:../src/FreeRTOS/tasks.c **** 				{
2360:../src/FreeRTOS/tasks.c **** 					cNextChar = pxNextTCB->pcTaskName[ x ];
2361:../src/FreeRTOS/tasks.c **** 
2362:../src/FreeRTOS/tasks.c **** 					if( cNextChar != pcNameToQuery[ x ] )
2363:../src/FreeRTOS/tasks.c **** 					{
2364:../src/FreeRTOS/tasks.c **** 						/* Characters didn't match. */
2365:../src/FreeRTOS/tasks.c **** 						break;
2366:../src/FreeRTOS/tasks.c **** 					}
2367:../src/FreeRTOS/tasks.c **** 					else if( cNextChar == 0x00 )
2368:../src/FreeRTOS/tasks.c **** 					{
2369:../src/FreeRTOS/tasks.c **** 						/* Both strings terminated, a match must have been
2370:../src/FreeRTOS/tasks.c **** 						found. */
2371:../src/FreeRTOS/tasks.c **** 						pxReturn = pxNextTCB;
2372:../src/FreeRTOS/tasks.c **** 						break;
2373:../src/FreeRTOS/tasks.c **** 					}
2374:../src/FreeRTOS/tasks.c **** 					else
2375:../src/FreeRTOS/tasks.c **** 					{
2376:../src/FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2377:../src/FreeRTOS/tasks.c **** 					}
2378:../src/FreeRTOS/tasks.c **** 				}
2379:../src/FreeRTOS/tasks.c **** 
2380:../src/FreeRTOS/tasks.c **** 				if( pxReturn != NULL )
2381:../src/FreeRTOS/tasks.c **** 				{
2382:../src/FreeRTOS/tasks.c **** 					/* The handle has been found. */
2383:../src/FreeRTOS/tasks.c **** 					break;
2384:../src/FreeRTOS/tasks.c **** 				}
2385:../src/FreeRTOS/tasks.c **** 
2386:../src/FreeRTOS/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
2387:../src/FreeRTOS/tasks.c **** 		}
2388:../src/FreeRTOS/tasks.c **** 		else
2389:../src/FreeRTOS/tasks.c **** 		{
2390:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2391:../src/FreeRTOS/tasks.c **** 		}
2392:../src/FreeRTOS/tasks.c **** 
2393:../src/FreeRTOS/tasks.c **** 		return pxReturn;
2394:../src/FreeRTOS/tasks.c **** 	}
2395:../src/FreeRTOS/tasks.c **** 
2396:../src/FreeRTOS/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2397:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2398:../src/FreeRTOS/tasks.c **** 
2399:../src/FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2400:../src/FreeRTOS/tasks.c **** 
2401:../src/FreeRTOS/tasks.c **** 	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are a
2402:../src/FreeRTOS/tasks.c **** 	{
2403:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxQueue = configMAX_PRIORITIES;
2404:../src/FreeRTOS/tasks.c **** 	TCB_t* pxTCB;
2405:../src/FreeRTOS/tasks.c **** 
2406:../src/FreeRTOS/tasks.c **** 		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2407:../src/FreeRTOS/tasks.c **** 		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2408:../src/FreeRTOS/tasks.c **** 
2409:../src/FreeRTOS/tasks.c **** 		vTaskSuspendAll();
2410:../src/FreeRTOS/tasks.c **** 		{
2411:../src/FreeRTOS/tasks.c **** 			/* Search the ready lists. */
2412:../src/FreeRTOS/tasks.c **** 			do
2413:../src/FreeRTOS/tasks.c **** 			{
2414:../src/FreeRTOS/tasks.c **** 				uxQueue--;
2415:../src/FreeRTOS/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNam
2416:../src/FreeRTOS/tasks.c **** 
2417:../src/FreeRTOS/tasks.c **** 				if( pxTCB != NULL )
2418:../src/FreeRTOS/tasks.c **** 				{
2419:../src/FreeRTOS/tasks.c **** 					/* Found the handle. */
2420:../src/FreeRTOS/tasks.c **** 					break;
2421:../src/FreeRTOS/tasks.c **** 				}
2422:../src/FreeRTOS/tasks.c **** 
2423:../src/FreeRTOS/tasks.c **** 			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts
2424:../src/FreeRTOS/tasks.c **** 
2425:../src/FreeRTOS/tasks.c **** 			/* Search the delayed lists. */
2426:../src/FreeRTOS/tasks.c **** 			if( pxTCB == NULL )
2427:../src/FreeRTOS/tasks.c **** 			{
2428:../src/FreeRTOS/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
2429:../src/FreeRTOS/tasks.c **** 			}
2430:../src/FreeRTOS/tasks.c **** 
2431:../src/FreeRTOS/tasks.c **** 			if( pxTCB == NULL )
2432:../src/FreeRTOS/tasks.c **** 			{
2433:../src/FreeRTOS/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery
2434:../src/FreeRTOS/tasks.c **** 			}
2435:../src/FreeRTOS/tasks.c **** 
2436:../src/FreeRTOS/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
2437:../src/FreeRTOS/tasks.c **** 			{
2438:../src/FreeRTOS/tasks.c **** 				if( pxTCB == NULL )
2439:../src/FreeRTOS/tasks.c **** 				{
2440:../src/FreeRTOS/tasks.c **** 					/* Search the suspended list. */
2441:../src/FreeRTOS/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2442:../src/FreeRTOS/tasks.c **** 				}
2443:../src/FreeRTOS/tasks.c **** 			}
2444:../src/FreeRTOS/tasks.c **** 			#endif
2445:../src/FreeRTOS/tasks.c **** 
2446:../src/FreeRTOS/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
2447:../src/FreeRTOS/tasks.c **** 			{
2448:../src/FreeRTOS/tasks.c **** 				if( pxTCB == NULL )
2449:../src/FreeRTOS/tasks.c **** 				{
2450:../src/FreeRTOS/tasks.c **** 					/* Search the deleted list. */
2451:../src/FreeRTOS/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
2452:../src/FreeRTOS/tasks.c **** 				}
2453:../src/FreeRTOS/tasks.c **** 			}
2454:../src/FreeRTOS/tasks.c **** 			#endif
2455:../src/FreeRTOS/tasks.c **** 		}
2456:../src/FreeRTOS/tasks.c **** 		( void ) xTaskResumeAll();
2457:../src/FreeRTOS/tasks.c **** 
2458:../src/FreeRTOS/tasks.c **** 		return ( TaskHandle_t ) pxTCB;
2459:../src/FreeRTOS/tasks.c **** 	}
2460:../src/FreeRTOS/tasks.c **** 
2461:../src/FreeRTOS/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2462:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2463:../src/FreeRTOS/tasks.c **** 
2464:../src/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2465:../src/FreeRTOS/tasks.c **** 
2466:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
2467:../src/FreeRTOS/tasks.c **** 	{
2468:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2469:../src/FreeRTOS/tasks.c **** 
2470:../src/FreeRTOS/tasks.c **** 		vTaskSuspendAll();
2471:../src/FreeRTOS/tasks.c **** 		{
2472:../src/FreeRTOS/tasks.c **** 			/* Is there a space in the array for each task in the system? */
2473:../src/FreeRTOS/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
2474:../src/FreeRTOS/tasks.c **** 			{
2475:../src/FreeRTOS/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2476:../src/FreeRTOS/tasks.c **** 				task in the Ready state. */
2477:../src/FreeRTOS/tasks.c **** 				do
2478:../src/FreeRTOS/tasks.c **** 				{
2479:../src/FreeRTOS/tasks.c **** 					uxQueue--;
2480:../src/FreeRTOS/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists
2481:../src/FreeRTOS/tasks.c **** 
2482:../src/FreeRTOS/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
2483:../src/FreeRTOS/tasks.c **** 
2484:../src/FreeRTOS/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2485:../src/FreeRTOS/tasks.c **** 				task in the Blocked state. */
2486:../src/FreeRTOS/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelaye
2487:../src/FreeRTOS/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverfl
2488:../src/FreeRTOS/tasks.c **** 
2489:../src/FreeRTOS/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
2490:../src/FreeRTOS/tasks.c **** 				{
2491:../src/FreeRTOS/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2492:../src/FreeRTOS/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
2493:../src/FreeRTOS/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermin
2494:../src/FreeRTOS/tasks.c **** 				}
2495:../src/FreeRTOS/tasks.c **** 				#endif
2496:../src/FreeRTOS/tasks.c **** 
2497:../src/FreeRTOS/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
2498:../src/FreeRTOS/tasks.c **** 				{
2499:../src/FreeRTOS/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2500:../src/FreeRTOS/tasks.c **** 					each task in the Suspended state. */
2501:../src/FreeRTOS/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList,
2502:../src/FreeRTOS/tasks.c **** 				}
2503:../src/FreeRTOS/tasks.c **** 				#endif
2504:../src/FreeRTOS/tasks.c **** 
2505:../src/FreeRTOS/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
2506:../src/FreeRTOS/tasks.c **** 				{
2507:../src/FreeRTOS/tasks.c **** 					if( pulTotalRunTime != NULL )
2508:../src/FreeRTOS/tasks.c **** 					{
2509:../src/FreeRTOS/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2510:../src/FreeRTOS/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2511:../src/FreeRTOS/tasks.c **** 						#else
2512:../src/FreeRTOS/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2513:../src/FreeRTOS/tasks.c **** 						#endif
2514:../src/FreeRTOS/tasks.c **** 					}
2515:../src/FreeRTOS/tasks.c **** 				}
2516:../src/FreeRTOS/tasks.c **** 				#else
2517:../src/FreeRTOS/tasks.c **** 				{
2518:../src/FreeRTOS/tasks.c **** 					if( pulTotalRunTime != NULL )
2519:../src/FreeRTOS/tasks.c **** 					{
2520:../src/FreeRTOS/tasks.c **** 						*pulTotalRunTime = 0;
2521:../src/FreeRTOS/tasks.c **** 					}
2522:../src/FreeRTOS/tasks.c **** 				}
2523:../src/FreeRTOS/tasks.c **** 				#endif
2524:../src/FreeRTOS/tasks.c **** 			}
2525:../src/FreeRTOS/tasks.c **** 			else
2526:../src/FreeRTOS/tasks.c **** 			{
2527:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2528:../src/FreeRTOS/tasks.c **** 			}
2529:../src/FreeRTOS/tasks.c **** 		}
2530:../src/FreeRTOS/tasks.c **** 		( void ) xTaskResumeAll();
2531:../src/FreeRTOS/tasks.c **** 
2532:../src/FreeRTOS/tasks.c **** 		return uxTask;
2533:../src/FreeRTOS/tasks.c **** 	}
2534:../src/FreeRTOS/tasks.c **** 
2535:../src/FreeRTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2536:../src/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
2537:../src/FreeRTOS/tasks.c **** 
2538:../src/FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2539:../src/FreeRTOS/tasks.c **** 
2540:../src/FreeRTOS/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
2541:../src/FreeRTOS/tasks.c **** 	{
2542:../src/FreeRTOS/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2543:../src/FreeRTOS/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
2544:../src/FreeRTOS/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
2545:../src/FreeRTOS/tasks.c **** 		return xIdleTaskHandle;
2546:../src/FreeRTOS/tasks.c **** 	}
2547:../src/FreeRTOS/tasks.c **** 
2548:../src/FreeRTOS/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2549:../src/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
2550:../src/FreeRTOS/tasks.c **** 
2551:../src/FreeRTOS/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
2552:../src/FreeRTOS/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
2553:../src/FreeRTOS/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2554:../src/FreeRTOS/tasks.c **** 1. */
2555:../src/FreeRTOS/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2556:../src/FreeRTOS/tasks.c **** 
2557:../src/FreeRTOS/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
2558:../src/FreeRTOS/tasks.c **** 	{
2559:../src/FreeRTOS/tasks.c **** 		/* Correct the tick count value after a period during which the tick
2560:../src/FreeRTOS/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
2561:../src/FreeRTOS/tasks.c **** 		each stepped tick. */
2562:../src/FreeRTOS/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2563:../src/FreeRTOS/tasks.c **** 		xTickCount += xTicksToJump;
2564:../src/FreeRTOS/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
2565:../src/FreeRTOS/tasks.c **** 	}
2566:../src/FreeRTOS/tasks.c **** 
2567:../src/FreeRTOS/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2568:../src/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
2569:../src/FreeRTOS/tasks.c **** 
2570:../src/FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskAbortDelay == 1 )
2571:../src/FreeRTOS/tasks.c **** 
2572:../src/FreeRTOS/tasks.c **** 	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2573:../src/FreeRTOS/tasks.c **** 	{
2574:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB = ( TCB_t * ) xTask;
2575:../src/FreeRTOS/tasks.c **** 	BaseType_t xReturn;
2576:../src/FreeRTOS/tasks.c **** 
2577:../src/FreeRTOS/tasks.c **** 		configASSERT( pxTCB );
2578:../src/FreeRTOS/tasks.c **** 
2579:../src/FreeRTOS/tasks.c **** 		vTaskSuspendAll();
2580:../src/FreeRTOS/tasks.c **** 		{
2581:../src/FreeRTOS/tasks.c **** 			/* A task can only be prematurely removed from the Blocked state if
2582:../src/FreeRTOS/tasks.c **** 			it is actually in the Blocked state. */
2583:../src/FreeRTOS/tasks.c **** 			if( eTaskGetState( xTask ) == eBlocked )
2584:../src/FreeRTOS/tasks.c **** 			{
2585:../src/FreeRTOS/tasks.c **** 				xReturn = pdPASS;
2586:../src/FreeRTOS/tasks.c **** 
2587:../src/FreeRTOS/tasks.c **** 				/* Remove the reference to the task from the blocked list.  An
2588:../src/FreeRTOS/tasks.c **** 				interrupt won't touch the xStateListItem because the
2589:../src/FreeRTOS/tasks.c **** 				scheduler is suspended. */
2590:../src/FreeRTOS/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2591:../src/FreeRTOS/tasks.c **** 
2592:../src/FreeRTOS/tasks.c **** 				/* Is the task waiting on an event also?  If so remove it from
2593:../src/FreeRTOS/tasks.c **** 				the event list too.  Interrupts can touch the event list item,
2594:../src/FreeRTOS/tasks.c **** 				even though the scheduler is suspended, so a critical section
2595:../src/FreeRTOS/tasks.c **** 				is used. */
2596:../src/FreeRTOS/tasks.c **** 				taskENTER_CRITICAL();
2597:../src/FreeRTOS/tasks.c **** 				{
2598:../src/FreeRTOS/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2599:../src/FreeRTOS/tasks.c **** 					{
2600:../src/FreeRTOS/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2601:../src/FreeRTOS/tasks.c **** 						pxTCB->ucDelayAborted = pdTRUE;
2602:../src/FreeRTOS/tasks.c **** 					}
2603:../src/FreeRTOS/tasks.c **** 					else
2604:../src/FreeRTOS/tasks.c **** 					{
2605:../src/FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2606:../src/FreeRTOS/tasks.c **** 					}
2607:../src/FreeRTOS/tasks.c **** 				}
2608:../src/FreeRTOS/tasks.c **** 				taskEXIT_CRITICAL();
2609:../src/FreeRTOS/tasks.c **** 
2610:../src/FreeRTOS/tasks.c **** 				/* Place the unblocked task into the appropriate ready list. */
2611:../src/FreeRTOS/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
2612:../src/FreeRTOS/tasks.c **** 
2613:../src/FreeRTOS/tasks.c **** 				/* A task being unblocked cannot cause an immediate context
2614:../src/FreeRTOS/tasks.c **** 				switch if preemption is turned off. */
2615:../src/FreeRTOS/tasks.c **** 				#if (  configUSE_PREEMPTION == 1 )
2616:../src/FreeRTOS/tasks.c **** 				{
2617:../src/FreeRTOS/tasks.c **** 					/* Preemption is on, but a context switch should only be
2618:../src/FreeRTOS/tasks.c **** 					performed if the unblocked task has a priority that is
2619:../src/FreeRTOS/tasks.c **** 					equal to or higher than the currently executing task. */
2620:../src/FreeRTOS/tasks.c **** 					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2621:../src/FreeRTOS/tasks.c **** 					{
2622:../src/FreeRTOS/tasks.c **** 						/* Pend the yield to be performed when the scheduler
2623:../src/FreeRTOS/tasks.c **** 						is unsuspended. */
2624:../src/FreeRTOS/tasks.c **** 						xYieldPending = pdTRUE;
2625:../src/FreeRTOS/tasks.c **** 					}
2626:../src/FreeRTOS/tasks.c **** 					else
2627:../src/FreeRTOS/tasks.c **** 					{
2628:../src/FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2629:../src/FreeRTOS/tasks.c **** 					}
2630:../src/FreeRTOS/tasks.c **** 				}
2631:../src/FreeRTOS/tasks.c **** 				#endif /* configUSE_PREEMPTION */
2632:../src/FreeRTOS/tasks.c **** 			}
2633:../src/FreeRTOS/tasks.c **** 			else
2634:../src/FreeRTOS/tasks.c **** 			{
2635:../src/FreeRTOS/tasks.c **** 				xReturn = pdFAIL;
2636:../src/FreeRTOS/tasks.c **** 			}
2637:../src/FreeRTOS/tasks.c **** 		}
2638:../src/FreeRTOS/tasks.c **** 		( void ) xTaskResumeAll();
2639:../src/FreeRTOS/tasks.c **** 
2640:../src/FreeRTOS/tasks.c **** 		return xReturn;
2641:../src/FreeRTOS/tasks.c **** 	}
2642:../src/FreeRTOS/tasks.c **** 
2643:../src/FreeRTOS/tasks.c **** #endif /* INCLUDE_xTaskAbortDelay */
2644:../src/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
2645:../src/FreeRTOS/tasks.c **** 
2646:../src/FreeRTOS/tasks.c **** BaseType_t xTaskIncrementTick( void )
2647:../src/FreeRTOS/tasks.c **** {
2648:../src/FreeRTOS/tasks.c **** TCB_t * pxTCB;
2649:../src/FreeRTOS/tasks.c **** TickType_t xItemValue;
2650:../src/FreeRTOS/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
2651:../src/FreeRTOS/tasks.c **** 
2652:../src/FreeRTOS/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
2653:../src/FreeRTOS/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
2654:../src/FreeRTOS/tasks.c **** 	tasks to be unblocked. */
2655:../src/FreeRTOS/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
2656:../src/FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2657:../src/FreeRTOS/tasks.c **** 	{
2658:../src/FreeRTOS/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this
2659:../src/FreeRTOS/tasks.c **** 		block. */
2660:../src/FreeRTOS/tasks.c **** 		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
2661:../src/FreeRTOS/tasks.c **** 
2662:../src/FreeRTOS/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
2663:../src/FreeRTOS/tasks.c **** 		delayed lists if it wraps to 0. */
2664:../src/FreeRTOS/tasks.c **** 		xTickCount = xConstTickCount;
2665:../src/FreeRTOS/tasks.c **** 
2666:../src/FreeRTOS/tasks.c **** 		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as
2667:../src/FreeRTOS/tasks.c **** 		{
2668:../src/FreeRTOS/tasks.c **** 			taskSWITCH_DELAYED_LISTS();
2669:../src/FreeRTOS/tasks.c **** 		}
2670:../src/FreeRTOS/tasks.c **** 		else
2671:../src/FreeRTOS/tasks.c **** 		{
2672:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2673:../src/FreeRTOS/tasks.c **** 		}
2674:../src/FreeRTOS/tasks.c **** 
2675:../src/FreeRTOS/tasks.c **** 		/* See if this tick has made a timeout expire.  Tasks are stored in
2676:../src/FreeRTOS/tasks.c **** 		the	queue in the order of their wake time - meaning once one task
2677:../src/FreeRTOS/tasks.c **** 		has been found whose block time has not expired there is no need to
2678:../src/FreeRTOS/tasks.c **** 		look any further down the list. */
2679:../src/FreeRTOS/tasks.c **** 		if( xConstTickCount >= xNextTaskUnblockTime )
2680:../src/FreeRTOS/tasks.c **** 		{
2681:../src/FreeRTOS/tasks.c **** 			for( ;; )
2682:../src/FreeRTOS/tasks.c **** 			{
2683:../src/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
2684:../src/FreeRTOS/tasks.c **** 				{
2685:../src/FreeRTOS/tasks.c **** 					/* The delayed list is empty.  Set xNextTaskUnblockTime
2686:../src/FreeRTOS/tasks.c **** 					to the maximum possible value so it is extremely
2687:../src/FreeRTOS/tasks.c **** 					unlikely that the
2688:../src/FreeRTOS/tasks.c **** 					if( xTickCount >= xNextTaskUnblockTime ) test will pass
2689:../src/FreeRTOS/tasks.c **** 					next time through. */
2690:../src/FreeRTOS/tasks.c **** 					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redun
2691:../src/FreeRTOS/tasks.c **** 					break;
2692:../src/FreeRTOS/tasks.c **** 				}
2693:../src/FreeRTOS/tasks.c **** 				else
2694:../src/FreeRTOS/tasks.c **** 				{
2695:../src/FreeRTOS/tasks.c **** 					/* The delayed list is not empty, get the value of the
2696:../src/FreeRTOS/tasks.c **** 					item at the head of the delayed list.  This is the time
2697:../src/FreeRTOS/tasks.c **** 					at which the task at the head of the delayed list must
2698:../src/FreeRTOS/tasks.c **** 					be removed from the Blocked state. */
2699:../src/FreeRTOS/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
2700:../src/FreeRTOS/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
2701:../src/FreeRTOS/tasks.c **** 
2702:../src/FreeRTOS/tasks.c **** 					if( xConstTickCount < xItemValue )
2703:../src/FreeRTOS/tasks.c **** 					{
2704:../src/FreeRTOS/tasks.c **** 						/* It is not time to unblock this item yet, but the
2705:../src/FreeRTOS/tasks.c **** 						item value is the time at which the task at the head
2706:../src/FreeRTOS/tasks.c **** 						of the blocked list must be removed from the Blocked
2707:../src/FreeRTOS/tasks.c **** 						state -	so record the item value in
2708:../src/FreeRTOS/tasks.c **** 						xNextTaskUnblockTime. */
2709:../src/FreeRTOS/tasks.c **** 						xNextTaskUnblockTime = xItemValue;
2710:../src/FreeRTOS/tasks.c **** 						break;
2711:../src/FreeRTOS/tasks.c **** 					}
2712:../src/FreeRTOS/tasks.c **** 					else
2713:../src/FreeRTOS/tasks.c **** 					{
2714:../src/FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2715:../src/FreeRTOS/tasks.c **** 					}
2716:../src/FreeRTOS/tasks.c **** 
2717:../src/FreeRTOS/tasks.c **** 					/* It is time to remove the item from the Blocked state. */
2718:../src/FreeRTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2719:../src/FreeRTOS/tasks.c **** 
2720:../src/FreeRTOS/tasks.c **** 					/* Is the task waiting on an event also?  If so remove
2721:../src/FreeRTOS/tasks.c **** 					it from the event list. */
2722:../src/FreeRTOS/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2723:../src/FreeRTOS/tasks.c **** 					{
2724:../src/FreeRTOS/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2725:../src/FreeRTOS/tasks.c **** 					}
2726:../src/FreeRTOS/tasks.c **** 					else
2727:../src/FreeRTOS/tasks.c **** 					{
2728:../src/FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2729:../src/FreeRTOS/tasks.c **** 					}
2730:../src/FreeRTOS/tasks.c **** 
2731:../src/FreeRTOS/tasks.c **** 					/* Place the unblocked task into the appropriate ready
2732:../src/FreeRTOS/tasks.c **** 					list. */
2733:../src/FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
2734:../src/FreeRTOS/tasks.c **** 
2735:../src/FreeRTOS/tasks.c **** 					/* A task being unblocked cannot cause an immediate
2736:../src/FreeRTOS/tasks.c **** 					context switch if preemption is turned off. */
2737:../src/FreeRTOS/tasks.c **** 					#if (  configUSE_PREEMPTION == 1 )
2738:../src/FreeRTOS/tasks.c **** 					{
2739:../src/FreeRTOS/tasks.c **** 						/* Preemption is on, but a context switch should
2740:../src/FreeRTOS/tasks.c **** 						only be performed if the unblocked task has a
2741:../src/FreeRTOS/tasks.c **** 						priority that is equal to or higher than the
2742:../src/FreeRTOS/tasks.c **** 						currently executing task. */
2743:../src/FreeRTOS/tasks.c **** 						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2744:../src/FreeRTOS/tasks.c **** 						{
2745:../src/FreeRTOS/tasks.c **** 							xSwitchRequired = pdTRUE;
2746:../src/FreeRTOS/tasks.c **** 						}
2747:../src/FreeRTOS/tasks.c **** 						else
2748:../src/FreeRTOS/tasks.c **** 						{
2749:../src/FreeRTOS/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2750:../src/FreeRTOS/tasks.c **** 						}
2751:../src/FreeRTOS/tasks.c **** 					}
2752:../src/FreeRTOS/tasks.c **** 					#endif /* configUSE_PREEMPTION */
2753:../src/FreeRTOS/tasks.c **** 				}
2754:../src/FreeRTOS/tasks.c **** 			}
2755:../src/FreeRTOS/tasks.c **** 		}
2756:../src/FreeRTOS/tasks.c **** 
2757:../src/FreeRTOS/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
2758:../src/FreeRTOS/tasks.c **** 		processing time (time slice) if preemption is on, and the application
2759:../src/FreeRTOS/tasks.c **** 		writer has not explicitly turned time slicing off. */
2760:../src/FreeRTOS/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2761:../src/FreeRTOS/tasks.c **** 		{
2762:../src/FreeRTOS/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
2763:../src/FreeRTOS/tasks.c **** 			{
2764:../src/FreeRTOS/tasks.c **** 				xSwitchRequired = pdTRUE;
2765:../src/FreeRTOS/tasks.c **** 			}
2766:../src/FreeRTOS/tasks.c **** 			else
2767:../src/FreeRTOS/tasks.c **** 			{
2768:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2769:../src/FreeRTOS/tasks.c **** 			}
2770:../src/FreeRTOS/tasks.c **** 		}
2771:../src/FreeRTOS/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2772:../src/FreeRTOS/tasks.c **** 
2773:../src/FreeRTOS/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2774:../src/FreeRTOS/tasks.c **** 		{
2775:../src/FreeRTOS/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
2776:../src/FreeRTOS/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
2777:../src/FreeRTOS/tasks.c **** 			if( uxPendedTicks == ( UBaseType_t ) 0U )
2778:../src/FreeRTOS/tasks.c **** 			{
2779:../src/FreeRTOS/tasks.c **** 				vApplicationTickHook();
2780:../src/FreeRTOS/tasks.c **** 			}
2781:../src/FreeRTOS/tasks.c **** 			else
2782:../src/FreeRTOS/tasks.c **** 			{
2783:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2784:../src/FreeRTOS/tasks.c **** 			}
2785:../src/FreeRTOS/tasks.c **** 		}
2786:../src/FreeRTOS/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
2787:../src/FreeRTOS/tasks.c **** 	}
2788:../src/FreeRTOS/tasks.c **** 	else
2789:../src/FreeRTOS/tasks.c **** 	{
2790:../src/FreeRTOS/tasks.c **** 		++uxPendedTicks;
2791:../src/FreeRTOS/tasks.c **** 
2792:../src/FreeRTOS/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
2793:../src/FreeRTOS/tasks.c **** 		scheduler is locked. */
2794:../src/FreeRTOS/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2795:../src/FreeRTOS/tasks.c **** 		{
2796:../src/FreeRTOS/tasks.c **** 			vApplicationTickHook();
2797:../src/FreeRTOS/tasks.c **** 		}
2798:../src/FreeRTOS/tasks.c **** 		#endif
2799:../src/FreeRTOS/tasks.c **** 	}
2800:../src/FreeRTOS/tasks.c **** 
2801:../src/FreeRTOS/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
2802:../src/FreeRTOS/tasks.c **** 	{
2803:../src/FreeRTOS/tasks.c **** 		if( xYieldPending != pdFALSE )
2804:../src/FreeRTOS/tasks.c **** 		{
2805:../src/FreeRTOS/tasks.c **** 			xSwitchRequired = pdTRUE;
2806:../src/FreeRTOS/tasks.c **** 		}
2807:../src/FreeRTOS/tasks.c **** 		else
2808:../src/FreeRTOS/tasks.c **** 		{
2809:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2810:../src/FreeRTOS/tasks.c **** 		}
2811:../src/FreeRTOS/tasks.c **** 	}
2812:../src/FreeRTOS/tasks.c **** 	#endif /* configUSE_PREEMPTION */
2813:../src/FreeRTOS/tasks.c **** 
2814:../src/FreeRTOS/tasks.c **** 	return xSwitchRequired;
2815:../src/FreeRTOS/tasks.c **** }
2816:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2817:../src/FreeRTOS/tasks.c **** 
2818:../src/FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2819:../src/FreeRTOS/tasks.c **** 
2820:../src/FreeRTOS/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2821:../src/FreeRTOS/tasks.c **** 	{
2822:../src/FreeRTOS/tasks.c **** 	TCB_t *xTCB;
2823:../src/FreeRTOS/tasks.c **** 
2824:../src/FreeRTOS/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2825:../src/FreeRTOS/tasks.c **** 		getting set. */
2826:../src/FreeRTOS/tasks.c **** 		if( xTask == NULL )
2827:../src/FreeRTOS/tasks.c **** 		{
2828:../src/FreeRTOS/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2829:../src/FreeRTOS/tasks.c **** 		}
2830:../src/FreeRTOS/tasks.c **** 		else
2831:../src/FreeRTOS/tasks.c **** 		{
2832:../src/FreeRTOS/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2833:../src/FreeRTOS/tasks.c **** 		}
2834:../src/FreeRTOS/tasks.c **** 
2835:../src/FreeRTOS/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2836:../src/FreeRTOS/tasks.c **** 		the value can be accessed from an interrupt. */
2837:../src/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
2838:../src/FreeRTOS/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2839:../src/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
2840:../src/FreeRTOS/tasks.c **** 	}
2841:../src/FreeRTOS/tasks.c **** 
2842:../src/FreeRTOS/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2843:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2844:../src/FreeRTOS/tasks.c **** 
2845:../src/FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2846:../src/FreeRTOS/tasks.c **** 
2847:../src/FreeRTOS/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2848:../src/FreeRTOS/tasks.c **** 	{
2849:../src/FreeRTOS/tasks.c **** 	TCB_t *xTCB;
2850:../src/FreeRTOS/tasks.c **** 	TaskHookFunction_t xReturn;
2851:../src/FreeRTOS/tasks.c **** 
2852:../src/FreeRTOS/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
2853:../src/FreeRTOS/tasks.c **** 		if( xTask == NULL )
2854:../src/FreeRTOS/tasks.c **** 		{
2855:../src/FreeRTOS/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2856:../src/FreeRTOS/tasks.c **** 		}
2857:../src/FreeRTOS/tasks.c **** 		else
2858:../src/FreeRTOS/tasks.c **** 		{
2859:../src/FreeRTOS/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2860:../src/FreeRTOS/tasks.c **** 		}
2861:../src/FreeRTOS/tasks.c **** 
2862:../src/FreeRTOS/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2863:../src/FreeRTOS/tasks.c **** 		the value can be accessed from an interrupt. */
2864:../src/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
2865:../src/FreeRTOS/tasks.c **** 		{
2866:../src/FreeRTOS/tasks.c **** 			xReturn = xTCB->pxTaskTag;
2867:../src/FreeRTOS/tasks.c **** 		}
2868:../src/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
2869:../src/FreeRTOS/tasks.c **** 
2870:../src/FreeRTOS/tasks.c **** 		return xReturn;
2871:../src/FreeRTOS/tasks.c **** 	}
2872:../src/FreeRTOS/tasks.c **** 
2873:../src/FreeRTOS/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2874:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2875:../src/FreeRTOS/tasks.c **** 
2876:../src/FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2877:../src/FreeRTOS/tasks.c **** 
2878:../src/FreeRTOS/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2879:../src/FreeRTOS/tasks.c **** 	{
2880:../src/FreeRTOS/tasks.c **** 	TCB_t *xTCB;
2881:../src/FreeRTOS/tasks.c **** 	BaseType_t xReturn;
2882:../src/FreeRTOS/tasks.c **** 
2883:../src/FreeRTOS/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2884:../src/FreeRTOS/tasks.c **** 		if( xTask == NULL )
2885:../src/FreeRTOS/tasks.c **** 		{
2886:../src/FreeRTOS/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2887:../src/FreeRTOS/tasks.c **** 		}
2888:../src/FreeRTOS/tasks.c **** 		else
2889:../src/FreeRTOS/tasks.c **** 		{
2890:../src/FreeRTOS/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2891:../src/FreeRTOS/tasks.c **** 		}
2892:../src/FreeRTOS/tasks.c **** 
2893:../src/FreeRTOS/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2894:../src/FreeRTOS/tasks.c **** 		{
2895:../src/FreeRTOS/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2896:../src/FreeRTOS/tasks.c **** 		}
2897:../src/FreeRTOS/tasks.c **** 		else
2898:../src/FreeRTOS/tasks.c **** 		{
2899:../src/FreeRTOS/tasks.c **** 			xReturn = pdFAIL;
2900:../src/FreeRTOS/tasks.c **** 		}
2901:../src/FreeRTOS/tasks.c **** 
2902:../src/FreeRTOS/tasks.c **** 		return xReturn;
2903:../src/FreeRTOS/tasks.c **** 	}
2904:../src/FreeRTOS/tasks.c **** 
2905:../src/FreeRTOS/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2906:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2907:../src/FreeRTOS/tasks.c **** 
2908:../src/FreeRTOS/tasks.c **** void vTaskSwitchContext( void )
2909:../src/FreeRTOS/tasks.c **** {
2910:../src/FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
2911:../src/FreeRTOS/tasks.c **** 	{
2912:../src/FreeRTOS/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2913:../src/FreeRTOS/tasks.c **** 		switch. */
2914:../src/FreeRTOS/tasks.c **** 		xYieldPending = pdTRUE;
2915:../src/FreeRTOS/tasks.c **** 	}
2916:../src/FreeRTOS/tasks.c **** 	else
2917:../src/FreeRTOS/tasks.c **** 	{
2918:../src/FreeRTOS/tasks.c **** 		xYieldPending = pdFALSE;
2919:../src/FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_OUT();
2920:../src/FreeRTOS/tasks.c **** 
2921:../src/FreeRTOS/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2922:../src/FreeRTOS/tasks.c **** 		{
2923:../src/FreeRTOS/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2924:../src/FreeRTOS/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2925:../src/FreeRTOS/tasks.c **** 				#else
2926:../src/FreeRTOS/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2927:../src/FreeRTOS/tasks.c **** 				#endif
2928:../src/FreeRTOS/tasks.c **** 
2929:../src/FreeRTOS/tasks.c **** 				/* Add the amount of time the task has been running to the
2930:../src/FreeRTOS/tasks.c **** 				accumulated time so far.  The time the task started running was
2931:../src/FreeRTOS/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2932:../src/FreeRTOS/tasks.c **** 				protection here so count values are only valid until the timer
2933:../src/FreeRTOS/tasks.c **** 				overflows.  The guard against negative values is to protect
2934:../src/FreeRTOS/tasks.c **** 				against suspect run time stat counter implementations - which
2935:../src/FreeRTOS/tasks.c **** 				are provided by the application, not the kernel. */
2936:../src/FreeRTOS/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
2937:../src/FreeRTOS/tasks.c **** 				{
2938:../src/FreeRTOS/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2939:../src/FreeRTOS/tasks.c **** 				}
2940:../src/FreeRTOS/tasks.c **** 				else
2941:../src/FreeRTOS/tasks.c **** 				{
2942:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2943:../src/FreeRTOS/tasks.c **** 				}
2944:../src/FreeRTOS/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
2945:../src/FreeRTOS/tasks.c **** 		}
2946:../src/FreeRTOS/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
2947:../src/FreeRTOS/tasks.c **** 
2948:../src/FreeRTOS/tasks.c **** 		/* Check for stack overflow, if configured. */
2949:../src/FreeRTOS/tasks.c **** 		taskCHECK_FOR_STACK_OVERFLOW();
2950:../src/FreeRTOS/tasks.c **** 
2951:../src/FreeRTOS/tasks.c **** 		/* Before the currently running task is switched out, save its errno. */
2952:../src/FreeRTOS/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
2953:../src/FreeRTOS/tasks.c **** 		{
2954:../src/FreeRTOS/tasks.c **** 			pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
2955:../src/FreeRTOS/tasks.c **** 		}
2956:../src/FreeRTOS/tasks.c **** 		#endif
2957:../src/FreeRTOS/tasks.c **** 
2958:../src/FreeRTOS/tasks.c **** 		/* Select a new task to run using either the generic C or port
2959:../src/FreeRTOS/tasks.c **** 		optimised asm code. */
2960:../src/FreeRTOS/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
2961:../src/FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_IN();
2962:../src/FreeRTOS/tasks.c **** 
2963:../src/FreeRTOS/tasks.c **** 		/* After the new task is switched in, update the global errno. */
2964:../src/FreeRTOS/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
2965:../src/FreeRTOS/tasks.c **** 		{
2966:../src/FreeRTOS/tasks.c **** 			FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
2967:../src/FreeRTOS/tasks.c **** 		}
2968:../src/FreeRTOS/tasks.c **** 		#endif
2969:../src/FreeRTOS/tasks.c **** 
2970:../src/FreeRTOS/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2971:../src/FreeRTOS/tasks.c **** 		{
2972:../src/FreeRTOS/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2973:../src/FreeRTOS/tasks.c **** 			structure specific to this task. */
2974:../src/FreeRTOS/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2975:../src/FreeRTOS/tasks.c **** 		}
2976:../src/FreeRTOS/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2977:../src/FreeRTOS/tasks.c **** 	}
2978:../src/FreeRTOS/tasks.c **** }
2979:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2980:../src/FreeRTOS/tasks.c **** 
2981:../src/FreeRTOS/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2982:../src/FreeRTOS/tasks.c **** {
2983:../src/FreeRTOS/tasks.c **** 	configASSERT( pxEventList );
2984:../src/FreeRTOS/tasks.c **** 
2985:../src/FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2986:../src/FreeRTOS/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2987:../src/FreeRTOS/tasks.c **** 
2988:../src/FreeRTOS/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
2989:../src/FreeRTOS/tasks.c **** 	This is placed in the list in priority order so the highest priority task
2990:../src/FreeRTOS/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
2991:../src/FreeRTOS/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
2992:../src/FreeRTOS/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2993:../src/FreeRTOS/tasks.c **** 
2994:../src/FreeRTOS/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
2995:../src/FreeRTOS/tasks.c **** }
2996:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2997:../src/FreeRTOS/tasks.c **** 
2998:../src/FreeRTOS/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
2999:../src/FreeRTOS/tasks.c **** {
3000:../src/FreeRTOS/tasks.c **** 	configASSERT( pxEventList );
3001:../src/FreeRTOS/tasks.c **** 
3002:../src/FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3003:../src/FreeRTOS/tasks.c **** 	the event groups implementation. */
3004:../src/FreeRTOS/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
3005:../src/FreeRTOS/tasks.c **** 
3006:../src/FreeRTOS/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
3007:../src/FreeRTOS/tasks.c **** 	event list item here as interrupts won't access the event list item of a
3008:../src/FreeRTOS/tasks.c **** 	task that is not in the Blocked state. */
3009:../src/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
3010:../src/FreeRTOS/tasks.c **** 
3011:../src/FreeRTOS/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
3012:../src/FreeRTOS/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
3013:../src/FreeRTOS/tasks.c **** 	event group implementation - and interrupts don't access event groups
3014:../src/FreeRTOS/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
3015:../src/FreeRTOS/tasks.c **** 	the task level). */
3016:../src/FreeRTOS/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3017:../src/FreeRTOS/tasks.c **** 
3018:../src/FreeRTOS/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
3019:../src/FreeRTOS/tasks.c **** }
3020:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3021:../src/FreeRTOS/tasks.c **** 
3022:../src/FreeRTOS/tasks.c **** #if( configUSE_TIMERS == 1 )
3023:../src/FreeRTOS/tasks.c **** 
3024:../src/FreeRTOS/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const B
3025:../src/FreeRTOS/tasks.c **** 	{
3026:../src/FreeRTOS/tasks.c **** 		configASSERT( pxEventList );
3027:../src/FreeRTOS/tasks.c **** 
3028:../src/FreeRTOS/tasks.c **** 		/* This function should not be called by application code hence the
3029:../src/FreeRTOS/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
3030:../src/FreeRTOS/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
3031:../src/FreeRTOS/tasks.c **** 		it should be called with the scheduler suspended. */
3032:../src/FreeRTOS/tasks.c **** 
3033:../src/FreeRTOS/tasks.c **** 
3034:../src/FreeRTOS/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
3035:../src/FreeRTOS/tasks.c **** 		In this case it is assume that this is the only task that is going to
3036:../src/FreeRTOS/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
3037:../src/FreeRTOS/tasks.c **** 		can be used in place of vListInsert. */
3038:../src/FreeRTOS/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3039:../src/FreeRTOS/tasks.c **** 
3040:../src/FreeRTOS/tasks.c **** 		/* If the task should block indefinitely then set the block time to a
3041:../src/FreeRTOS/tasks.c **** 		value that will be recognised as an indefinite delay inside the
3042:../src/FreeRTOS/tasks.c **** 		prvAddCurrentTaskToDelayedList() function. */
3043:../src/FreeRTOS/tasks.c **** 		if( xWaitIndefinitely != pdFALSE )
3044:../src/FreeRTOS/tasks.c **** 		{
3045:../src/FreeRTOS/tasks.c **** 			xTicksToWait = portMAX_DELAY;
3046:../src/FreeRTOS/tasks.c **** 		}
3047:../src/FreeRTOS/tasks.c **** 
3048:../src/FreeRTOS/tasks.c **** 		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
3049:../src/FreeRTOS/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
3050:../src/FreeRTOS/tasks.c **** 	}
3051:../src/FreeRTOS/tasks.c **** 
3052:../src/FreeRTOS/tasks.c **** #endif /* configUSE_TIMERS */
3053:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3054:../src/FreeRTOS/tasks.c **** 
3055:../src/FreeRTOS/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
3056:../src/FreeRTOS/tasks.c **** {
3057:../src/FreeRTOS/tasks.c **** TCB_t *pxUnblockedTCB;
3058:../src/FreeRTOS/tasks.c **** BaseType_t xReturn;
3059:../src/FreeRTOS/tasks.c **** 
3060:../src/FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
3061:../src/FreeRTOS/tasks.c **** 	called from a critical section within an ISR. */
3062:../src/FreeRTOS/tasks.c **** 
3063:../src/FreeRTOS/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
3064:../src/FreeRTOS/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
3065:../src/FreeRTOS/tasks.c **** 	the delayed list, and add it to the ready list.
3066:../src/FreeRTOS/tasks.c **** 
3067:../src/FreeRTOS/tasks.c **** 	If an event is for a queue that is locked then this function will never
3068:../src/FreeRTOS/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
3069:../src/FreeRTOS/tasks.c **** 	means exclusive access to the event list is guaranteed here.
3070:../src/FreeRTOS/tasks.c **** 
3071:../src/FreeRTOS/tasks.c **** 	This function assumes that a check has already been made to ensure that
3072:../src/FreeRTOS/tasks.c **** 	pxEventList is not empty. */
3073:../src/FreeRTOS/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
3074:../src/FreeRTOS/tasks.c **** 	configASSERT( pxUnblockedTCB );
3075:../src/FreeRTOS/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
3076:../src/FreeRTOS/tasks.c **** 
3077:../src/FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3078:../src/FreeRTOS/tasks.c **** 	{
3079:../src/FreeRTOS/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3080:../src/FreeRTOS/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
3081:../src/FreeRTOS/tasks.c **** 	}
3082:../src/FreeRTOS/tasks.c **** 	else
3083:../src/FreeRTOS/tasks.c **** 	{
3084:../src/FreeRTOS/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
3085:../src/FreeRTOS/tasks.c **** 		pending until the scheduler is resumed. */
3086:../src/FreeRTOS/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
3087:../src/FreeRTOS/tasks.c **** 	}
3088:../src/FreeRTOS/tasks.c **** 
3089:../src/FreeRTOS/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3090:../src/FreeRTOS/tasks.c **** 	{
3091:../src/FreeRTOS/tasks.c **** 		/* Return true if the task removed from the event list has a higher
3092:../src/FreeRTOS/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
3093:../src/FreeRTOS/tasks.c **** 		it should force a context switch now. */
3094:../src/FreeRTOS/tasks.c **** 		xReturn = pdTRUE;
3095:../src/FreeRTOS/tasks.c **** 
3096:../src/FreeRTOS/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
3097:../src/FreeRTOS/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
3098:../src/FreeRTOS/tasks.c **** 		xYieldPending = pdTRUE;
3099:../src/FreeRTOS/tasks.c **** 	}
3100:../src/FreeRTOS/tasks.c **** 	else
3101:../src/FreeRTOS/tasks.c **** 	{
3102:../src/FreeRTOS/tasks.c **** 		xReturn = pdFALSE;
3103:../src/FreeRTOS/tasks.c **** 	}
3104:../src/FreeRTOS/tasks.c **** 
3105:../src/FreeRTOS/tasks.c **** 	#if( configUSE_TICKLESS_IDLE != 0 )
3106:../src/FreeRTOS/tasks.c **** 	{
3107:../src/FreeRTOS/tasks.c **** 		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
3108:../src/FreeRTOS/tasks.c **** 		might be set to the blocked task's time out time.  If the task is
3109:../src/FreeRTOS/tasks.c **** 		unblocked for a reason other than a timeout xNextTaskUnblockTime is
3110:../src/FreeRTOS/tasks.c **** 		normally left unchanged, because it is automatically reset to a new
3111:../src/FreeRTOS/tasks.c **** 		value when the tick count equals xNextTaskUnblockTime.  However if
3112:../src/FreeRTOS/tasks.c **** 		tickless idling is used it might be more important to enter sleep mode
3113:../src/FreeRTOS/tasks.c **** 		at the earliest possible time - so reset xNextTaskUnblockTime here to
3114:../src/FreeRTOS/tasks.c **** 		ensure it is updated at the earliest possible time. */
3115:../src/FreeRTOS/tasks.c **** 		prvResetNextTaskUnblockTime();
3116:../src/FreeRTOS/tasks.c **** 	}
3117:../src/FreeRTOS/tasks.c **** 	#endif
3118:../src/FreeRTOS/tasks.c **** 
3119:../src/FreeRTOS/tasks.c **** 	return xReturn;
3120:../src/FreeRTOS/tasks.c **** }
3121:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3122:../src/FreeRTOS/tasks.c **** 
3123:../src/FreeRTOS/tasks.c **** void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
3124:../src/FreeRTOS/tasks.c **** {
3125:../src/FreeRTOS/tasks.c **** TCB_t *pxUnblockedTCB;
3126:../src/FreeRTOS/tasks.c **** 
3127:../src/FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3128:../src/FreeRTOS/tasks.c **** 	the event flags implementation. */
3129:../src/FreeRTOS/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
3130:../src/FreeRTOS/tasks.c **** 
3131:../src/FreeRTOS/tasks.c **** 	/* Store the new item value in the event list. */
3132:../src/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
3133:../src/FreeRTOS/tasks.c **** 
3134:../src/FreeRTOS/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
3135:../src/FreeRTOS/tasks.c **** 	event flags. */
3136:../src/FreeRTOS/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
3137:../src/FreeRTOS/tasks.c **** 	configASSERT( pxUnblockedTCB );
3138:../src/FreeRTOS/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
3139:../src/FreeRTOS/tasks.c **** 
3140:../src/FreeRTOS/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
3141:../src/FreeRTOS/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
3142:../src/FreeRTOS/tasks.c **** 	lists. */
3143:../src/FreeRTOS/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3144:../src/FreeRTOS/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
3145:../src/FreeRTOS/tasks.c **** 
3146:../src/FreeRTOS/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3147:../src/FreeRTOS/tasks.c **** 	{
3148:../src/FreeRTOS/tasks.c **** 		/* The unblocked task has a priority above that of the calling task, so
3149:../src/FreeRTOS/tasks.c **** 		a context switch is required.  This function is called with the
3150:../src/FreeRTOS/tasks.c **** 		scheduler suspended so xYieldPending is set so the context switch
3151:../src/FreeRTOS/tasks.c **** 		occurs immediately that the scheduler is resumed (unsuspended). */
3152:../src/FreeRTOS/tasks.c **** 		xYieldPending = pdTRUE;
3153:../src/FreeRTOS/tasks.c **** 	}
3154:../src/FreeRTOS/tasks.c **** }
3155:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3156:../src/FreeRTOS/tasks.c **** 
3157:../src/FreeRTOS/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3158:../src/FreeRTOS/tasks.c **** {
3159:../src/FreeRTOS/tasks.c **** 	configASSERT( pxTimeOut );
3160:../src/FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
3161:../src/FreeRTOS/tasks.c **** 	{
3162:../src/FreeRTOS/tasks.c **** 		pxTimeOut->xOverflowCount = xNumOfOverflows;
3163:../src/FreeRTOS/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
3164:../src/FreeRTOS/tasks.c **** 	}
3165:../src/FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
3166:../src/FreeRTOS/tasks.c **** }
3167:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3168:../src/FreeRTOS/tasks.c **** 
3169:../src/FreeRTOS/tasks.c **** void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
3170:../src/FreeRTOS/tasks.c **** {
3171:../src/FreeRTOS/tasks.c **** 	/* For internal use only as it does not use a critical section. */
3172:../src/FreeRTOS/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
3173:../src/FreeRTOS/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
3174:../src/FreeRTOS/tasks.c **** }
3175:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3176:../src/FreeRTOS/tasks.c **** 
3177:../src/FreeRTOS/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
3178:../src/FreeRTOS/tasks.c **** {
3179:../src/FreeRTOS/tasks.c **** BaseType_t xReturn;
3180:../src/FreeRTOS/tasks.c **** 
3181:../src/FreeRTOS/tasks.c **** 	configASSERT( pxTimeOut );
3182:../src/FreeRTOS/tasks.c **** 	configASSERT( pxTicksToWait );
3183:../src/FreeRTOS/tasks.c **** 
3184:../src/FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
3185:../src/FreeRTOS/tasks.c **** 	{
3186:../src/FreeRTOS/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
3187:../src/FreeRTOS/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
3188:../src/FreeRTOS/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
3189:../src/FreeRTOS/tasks.c **** 
3190:../src/FreeRTOS/tasks.c **** 		#if( INCLUDE_xTaskAbortDelay == 1 )
3191:../src/FreeRTOS/tasks.c **** 			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
3192:../src/FreeRTOS/tasks.c **** 			{
3193:../src/FreeRTOS/tasks.c **** 				/* The delay was aborted, which is not the same as a time out,
3194:../src/FreeRTOS/tasks.c **** 				but has the same result. */
3195:../src/FreeRTOS/tasks.c **** 				pxCurrentTCB->ucDelayAborted = pdFALSE;
3196:../src/FreeRTOS/tasks.c **** 				xReturn = pdTRUE;
3197:../src/FreeRTOS/tasks.c **** 			}
3198:../src/FreeRTOS/tasks.c **** 			else
3199:../src/FreeRTOS/tasks.c **** 		#endif
3200:../src/FreeRTOS/tasks.c **** 
3201:../src/FreeRTOS/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
3202:../src/FreeRTOS/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
3203:../src/FreeRTOS/tasks.c **** 			{
3204:../src/FreeRTOS/tasks.c **** 				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
3205:../src/FreeRTOS/tasks.c **** 				specified is the maximum block time then the task should block
3206:../src/FreeRTOS/tasks.c **** 				indefinitely, and therefore never time out. */
3207:../src/FreeRTOS/tasks.c **** 				xReturn = pdFALSE;
3208:../src/FreeRTOS/tasks.c **** 			}
3209:../src/FreeRTOS/tasks.c **** 			else
3210:../src/FreeRTOS/tasks.c **** 		#endif
3211:../src/FreeRTOS/tasks.c **** 
3212:../src/FreeRTOS/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
3213:../src/FreeRTOS/tasks.c **** 		{
3214:../src/FreeRTOS/tasks.c **** 			/* The tick count is greater than the time at which
3215:../src/FreeRTOS/tasks.c **** 			vTaskSetTimeout() was called, but has also overflowed since
3216:../src/FreeRTOS/tasks.c **** 			vTaskSetTimeOut() was called.  It must have wrapped all the way
3217:../src/FreeRTOS/tasks.c **** 			around and gone past again. This passed since vTaskSetTimeout()
3218:../src/FreeRTOS/tasks.c **** 			was called. */
3219:../src/FreeRTOS/tasks.c **** 			xReturn = pdTRUE;
3220:../src/FreeRTOS/tasks.c **** 		}
3221:../src/FreeRTOS/tasks.c **** 		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with som
3222:../src/FreeRTOS/tasks.c **** 		{
3223:../src/FreeRTOS/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
3224:../src/FreeRTOS/tasks.c **** 			*pxTicksToWait -= xElapsedTime;
3225:../src/FreeRTOS/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
3226:../src/FreeRTOS/tasks.c **** 			xReturn = pdFALSE;
3227:../src/FreeRTOS/tasks.c **** 		}
3228:../src/FreeRTOS/tasks.c **** 		else
3229:../src/FreeRTOS/tasks.c **** 		{
3230:../src/FreeRTOS/tasks.c **** 			*pxTicksToWait = 0;
3231:../src/FreeRTOS/tasks.c **** 			xReturn = pdTRUE;
3232:../src/FreeRTOS/tasks.c **** 		}
3233:../src/FreeRTOS/tasks.c **** 	}
3234:../src/FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
3235:../src/FreeRTOS/tasks.c **** 
3236:../src/FreeRTOS/tasks.c **** 	return xReturn;
3237:../src/FreeRTOS/tasks.c **** }
3238:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3239:../src/FreeRTOS/tasks.c **** 
3240:../src/FreeRTOS/tasks.c **** void vTaskMissedYield( void )
3241:../src/FreeRTOS/tasks.c **** {
3242:../src/FreeRTOS/tasks.c **** 	xYieldPending = pdTRUE;
3243:../src/FreeRTOS/tasks.c **** }
3244:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3245:../src/FreeRTOS/tasks.c **** 
3246:../src/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3247:../src/FreeRTOS/tasks.c **** 
3248:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3249:../src/FreeRTOS/tasks.c **** 	{
3250:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxReturn;
3251:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
3252:../src/FreeRTOS/tasks.c **** 
3253:../src/FreeRTOS/tasks.c **** 		if( xTask != NULL )
3254:../src/FreeRTOS/tasks.c **** 		{
3255:../src/FreeRTOS/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
3256:../src/FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
3257:../src/FreeRTOS/tasks.c **** 		}
3258:../src/FreeRTOS/tasks.c **** 		else
3259:../src/FreeRTOS/tasks.c **** 		{
3260:../src/FreeRTOS/tasks.c **** 			uxReturn = 0U;
3261:../src/FreeRTOS/tasks.c **** 		}
3262:../src/FreeRTOS/tasks.c **** 
3263:../src/FreeRTOS/tasks.c **** 		return uxReturn;
3264:../src/FreeRTOS/tasks.c **** 	}
3265:../src/FreeRTOS/tasks.c **** 
3266:../src/FreeRTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3267:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3268:../src/FreeRTOS/tasks.c **** 
3269:../src/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3270:../src/FreeRTOS/tasks.c **** 
3271:../src/FreeRTOS/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
3272:../src/FreeRTOS/tasks.c **** 	{
3273:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
3274:../src/FreeRTOS/tasks.c **** 
3275:../src/FreeRTOS/tasks.c **** 		if( xTask != NULL )
3276:../src/FreeRTOS/tasks.c **** 		{
3277:../src/FreeRTOS/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
3278:../src/FreeRTOS/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
3279:../src/FreeRTOS/tasks.c **** 		}
3280:../src/FreeRTOS/tasks.c **** 	}
3281:../src/FreeRTOS/tasks.c **** 
3282:../src/FreeRTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3283:../src/FreeRTOS/tasks.c **** 
3284:../src/FreeRTOS/tasks.c **** /*
3285:../src/FreeRTOS/tasks.c ****  * -----------------------------------------------------------
3286:../src/FreeRTOS/tasks.c ****  * The Idle task.
3287:../src/FreeRTOS/tasks.c ****  * ----------------------------------------------------------
3288:../src/FreeRTOS/tasks.c ****  *
3289:../src/FreeRTOS/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3290:../src/FreeRTOS/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
3291:../src/FreeRTOS/tasks.c ****  *
3292:../src/FreeRTOS/tasks.c ****  * void prvIdleTask( void *pvParameters );
3293:../src/FreeRTOS/tasks.c ****  *
3294:../src/FreeRTOS/tasks.c ****  */
3295:../src/FreeRTOS/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
3296:../src/FreeRTOS/tasks.c **** {
3297:../src/FreeRTOS/tasks.c **** 	/* Stop warnings. */
3298:../src/FreeRTOS/tasks.c **** 	( void ) pvParameters;
3299:../src/FreeRTOS/tasks.c **** 
3300:../src/FreeRTOS/tasks.c **** 	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3301:../src/FreeRTOS/tasks.c **** 	SCHEDULER IS STARTED. **/
3302:../src/FreeRTOS/tasks.c **** 
3303:../src/FreeRTOS/tasks.c **** 	/* In case a task that has a secure context deletes itself, in which case
3304:../src/FreeRTOS/tasks.c **** 	the idle task is responsible for deleting the task's secure context, if
3305:../src/FreeRTOS/tasks.c **** 	any. */
3306:../src/FreeRTOS/tasks.c **** 	portTASK_CALLS_SECURE_FUNCTIONS();
3307:../src/FreeRTOS/tasks.c **** 
3308:../src/FreeRTOS/tasks.c **** 	for( ;; )
3309:../src/FreeRTOS/tasks.c **** 	{
3310:../src/FreeRTOS/tasks.c **** 		/* See if any tasks have deleted themselves - if so then the idle task
3311:../src/FreeRTOS/tasks.c **** 		is responsible for freeing the deleted task's TCB and stack. */
3312:../src/FreeRTOS/tasks.c **** 		prvCheckTasksWaitingTermination();
3313:../src/FreeRTOS/tasks.c **** 
3314:../src/FreeRTOS/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
3315:../src/FreeRTOS/tasks.c **** 		{
3316:../src/FreeRTOS/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
3317:../src/FreeRTOS/tasks.c **** 			see if any other task has become available.  If we are using
3318:../src/FreeRTOS/tasks.c **** 			preemption we don't need to do this as any task becoming available
3319:../src/FreeRTOS/tasks.c **** 			will automatically get the processor anyway. */
3320:../src/FreeRTOS/tasks.c **** 			taskYIELD();
3321:../src/FreeRTOS/tasks.c **** 		}
3322:../src/FreeRTOS/tasks.c **** 		#endif /* configUSE_PREEMPTION */
3323:../src/FreeRTOS/tasks.c **** 
3324:../src/FreeRTOS/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3325:../src/FreeRTOS/tasks.c **** 		{
3326:../src/FreeRTOS/tasks.c **** 			/* When using preemption tasks of equal priority will be
3327:../src/FreeRTOS/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
3328:../src/FreeRTOS/tasks.c **** 			to run then the idle task should yield before the end of the
3329:../src/FreeRTOS/tasks.c **** 			timeslice.
3330:../src/FreeRTOS/tasks.c **** 
3331:../src/FreeRTOS/tasks.c **** 			A critical region is not required here as we are just reading from
3332:../src/FreeRTOS/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
3333:../src/FreeRTOS/tasks.c **** 			the ready list at the idle priority contains more than one task
3334:../src/FreeRTOS/tasks.c **** 			then a task other than the idle task is ready to execute. */
3335:../src/FreeRTOS/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
3336:../src/FreeRTOS/tasks.c **** 			{
3337:../src/FreeRTOS/tasks.c **** 				taskYIELD();
3338:../src/FreeRTOS/tasks.c **** 			}
3339:../src/FreeRTOS/tasks.c **** 			else
3340:../src/FreeRTOS/tasks.c **** 			{
3341:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3342:../src/FreeRTOS/tasks.c **** 			}
3343:../src/FreeRTOS/tasks.c **** 		}
3344:../src/FreeRTOS/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3345:../src/FreeRTOS/tasks.c **** 
3346:../src/FreeRTOS/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
3347:../src/FreeRTOS/tasks.c **** 		{
3348:../src/FreeRTOS/tasks.c **** 			extern void vApplicationIdleHook( void );
3349:../src/FreeRTOS/tasks.c **** 
3350:../src/FreeRTOS/tasks.c **** 			/* Call the user defined function from within the idle task.  This
3351:../src/FreeRTOS/tasks.c **** 			allows the application designer to add background functionality
3352:../src/FreeRTOS/tasks.c **** 			without the overhead of a separate task.
3353:../src/FreeRTOS/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3354:../src/FreeRTOS/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
3355:../src/FreeRTOS/tasks.c **** 			vApplicationIdleHook();
3356:../src/FreeRTOS/tasks.c **** 		}
3357:../src/FreeRTOS/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
3358:../src/FreeRTOS/tasks.c **** 
3359:../src/FreeRTOS/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
3360:../src/FreeRTOS/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3361:../src/FreeRTOS/tasks.c **** 		user defined low power mode	implementations require
3362:../src/FreeRTOS/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3363:../src/FreeRTOS/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
3364:../src/FreeRTOS/tasks.c **** 		{
3365:../src/FreeRTOS/tasks.c **** 		TickType_t xExpectedIdleTime;
3366:../src/FreeRTOS/tasks.c **** 
3367:../src/FreeRTOS/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
3368:../src/FreeRTOS/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
3369:../src/FreeRTOS/tasks.c **** 			test of the expected idle time is performed without the
3370:../src/FreeRTOS/tasks.c **** 			scheduler suspended.  The result here is not necessarily
3371:../src/FreeRTOS/tasks.c **** 			valid. */
3372:../src/FreeRTOS/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
3373:../src/FreeRTOS/tasks.c **** 
3374:../src/FreeRTOS/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3375:../src/FreeRTOS/tasks.c **** 			{
3376:../src/FreeRTOS/tasks.c **** 				vTaskSuspendAll();
3377:../src/FreeRTOS/tasks.c **** 				{
3378:../src/FreeRTOS/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
3379:../src/FreeRTOS/tasks.c **** 					time can be sampled again, and this time its value can
3380:../src/FreeRTOS/tasks.c **** 					be used. */
3381:../src/FreeRTOS/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
3382:../src/FreeRTOS/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
3383:../src/FreeRTOS/tasks.c **** 
3384:../src/FreeRTOS/tasks.c **** 					/* Define the following macro to set xExpectedIdleTime to 0
3385:../src/FreeRTOS/tasks.c **** 					if the application does not want
3386:../src/FreeRTOS/tasks.c **** 					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
3387:../src/FreeRTOS/tasks.c **** 					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
3388:../src/FreeRTOS/tasks.c **** 
3389:../src/FreeRTOS/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3390:../src/FreeRTOS/tasks.c **** 					{
3391:../src/FreeRTOS/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
3392:../src/FreeRTOS/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3393:../src/FreeRTOS/tasks.c **** 						traceLOW_POWER_IDLE_END();
3394:../src/FreeRTOS/tasks.c **** 					}
3395:../src/FreeRTOS/tasks.c **** 					else
3396:../src/FreeRTOS/tasks.c **** 					{
3397:../src/FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3398:../src/FreeRTOS/tasks.c **** 					}
3399:../src/FreeRTOS/tasks.c **** 				}
3400:../src/FreeRTOS/tasks.c **** 				( void ) xTaskResumeAll();
3401:../src/FreeRTOS/tasks.c **** 			}
3402:../src/FreeRTOS/tasks.c **** 			else
3403:../src/FreeRTOS/tasks.c **** 			{
3404:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3405:../src/FreeRTOS/tasks.c **** 			}
3406:../src/FreeRTOS/tasks.c **** 		}
3407:../src/FreeRTOS/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
3408:../src/FreeRTOS/tasks.c **** 	}
3409:../src/FreeRTOS/tasks.c **** }
3410:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3411:../src/FreeRTOS/tasks.c **** 
3412:../src/FreeRTOS/tasks.c **** #if( configUSE_TICKLESS_IDLE != 0 )
3413:../src/FreeRTOS/tasks.c **** 
3414:../src/FreeRTOS/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3415:../src/FreeRTOS/tasks.c **** 	{
3416:../src/FreeRTOS/tasks.c **** 	/* The idle task exists in addition to the application tasks. */
3417:../src/FreeRTOS/tasks.c **** 	const UBaseType_t uxNonApplicationTasks = 1;
3418:../src/FreeRTOS/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
3419:../src/FreeRTOS/tasks.c **** 
3420:../src/FreeRTOS/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3421:../src/FreeRTOS/tasks.c **** 		{
3422:../src/FreeRTOS/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
3423:../src/FreeRTOS/tasks.c **** 			eReturn = eAbortSleep;
3424:../src/FreeRTOS/tasks.c **** 		}
3425:../src/FreeRTOS/tasks.c **** 		else if( xYieldPending != pdFALSE )
3426:../src/FreeRTOS/tasks.c **** 		{
3427:../src/FreeRTOS/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
3428:../src/FreeRTOS/tasks.c **** 			eReturn = eAbortSleep;
3429:../src/FreeRTOS/tasks.c **** 		}
3430:../src/FreeRTOS/tasks.c **** 		else
3431:../src/FreeRTOS/tasks.c **** 		{
3432:../src/FreeRTOS/tasks.c **** 			/* If all the tasks are in the suspended list (which might mean they
3433:../src/FreeRTOS/tasks.c **** 			have an infinite block time rather than actually being suspended)
3434:../src/FreeRTOS/tasks.c **** 			then it is safe to turn all clocks off and just wait for external
3435:../src/FreeRTOS/tasks.c **** 			interrupts. */
3436:../src/FreeRTOS/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicatio
3437:../src/FreeRTOS/tasks.c **** 			{
3438:../src/FreeRTOS/tasks.c **** 				eReturn = eNoTasksWaitingTimeout;
3439:../src/FreeRTOS/tasks.c **** 			}
3440:../src/FreeRTOS/tasks.c **** 			else
3441:../src/FreeRTOS/tasks.c **** 			{
3442:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3443:../src/FreeRTOS/tasks.c **** 			}
3444:../src/FreeRTOS/tasks.c **** 		}
3445:../src/FreeRTOS/tasks.c **** 
3446:../src/FreeRTOS/tasks.c **** 		return eReturn;
3447:../src/FreeRTOS/tasks.c **** 	}
3448:../src/FreeRTOS/tasks.c **** 
3449:../src/FreeRTOS/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
3450:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3451:../src/FreeRTOS/tasks.c **** 
3452:../src/FreeRTOS/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3453:../src/FreeRTOS/tasks.c **** 
3454:../src/FreeRTOS/tasks.c **** 	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue 
3455:../src/FreeRTOS/tasks.c **** 	{
3456:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
3457:../src/FreeRTOS/tasks.c **** 
3458:../src/FreeRTOS/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3459:../src/FreeRTOS/tasks.c **** 		{
3460:../src/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSet );
3461:../src/FreeRTOS/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3462:../src/FreeRTOS/tasks.c **** 		}
3463:../src/FreeRTOS/tasks.c **** 	}
3464:../src/FreeRTOS/tasks.c **** 
3465:../src/FreeRTOS/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3466:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3467:../src/FreeRTOS/tasks.c **** 
3468:../src/FreeRTOS/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3469:../src/FreeRTOS/tasks.c **** 
3470:../src/FreeRTOS/tasks.c **** 	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
3471:../src/FreeRTOS/tasks.c **** 	{
3472:../src/FreeRTOS/tasks.c **** 	void *pvReturn = NULL;
3473:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
3474:../src/FreeRTOS/tasks.c **** 
3475:../src/FreeRTOS/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3476:../src/FreeRTOS/tasks.c **** 		{
3477:../src/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3478:../src/FreeRTOS/tasks.c **** 			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3479:../src/FreeRTOS/tasks.c **** 		}
3480:../src/FreeRTOS/tasks.c **** 		else
3481:../src/FreeRTOS/tasks.c **** 		{
3482:../src/FreeRTOS/tasks.c **** 			pvReturn = NULL;
3483:../src/FreeRTOS/tasks.c **** 		}
3484:../src/FreeRTOS/tasks.c **** 
3485:../src/FreeRTOS/tasks.c **** 		return pvReturn;
3486:../src/FreeRTOS/tasks.c **** 	}
3487:../src/FreeRTOS/tasks.c **** 
3488:../src/FreeRTOS/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3489:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3490:../src/FreeRTOS/tasks.c **** 
3491:../src/FreeRTOS/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
3492:../src/FreeRTOS/tasks.c **** 
3493:../src/FreeRTOS/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
3494:../src/FreeRTOS/tasks.c **** 	{
3495:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
3496:../src/FreeRTOS/tasks.c **** 
3497:../src/FreeRTOS/tasks.c **** 		/* If null is passed in here then we are modifying the MPU settings of
3498:../src/FreeRTOS/tasks.c **** 		the calling task. */
3499:../src/FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
3500:../src/FreeRTOS/tasks.c **** 
3501:../src/FreeRTOS/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3502:../src/FreeRTOS/tasks.c **** 	}
3503:../src/FreeRTOS/tasks.c **** 
3504:../src/FreeRTOS/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
3505:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3506:../src/FreeRTOS/tasks.c **** 
3507:../src/FreeRTOS/tasks.c **** static void prvInitialiseTaskLists( void )
3508:../src/FreeRTOS/tasks.c **** {
3509:../src/FreeRTOS/tasks.c **** UBaseType_t uxPriority;
3510:../src/FreeRTOS/tasks.c **** 
3511:../src/FreeRTOS/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
3512:../src/FreeRTOS/tasks.c **** 	{
3513:../src/FreeRTOS/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
3514:../src/FreeRTOS/tasks.c **** 	}
3515:../src/FreeRTOS/tasks.c **** 
3516:../src/FreeRTOS/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
3517:../src/FreeRTOS/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
3518:../src/FreeRTOS/tasks.c **** 	vListInitialise( &xPendingReadyList );
3519:../src/FreeRTOS/tasks.c **** 
3520:../src/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3521:../src/FreeRTOS/tasks.c **** 	{
3522:../src/FreeRTOS/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
3523:../src/FreeRTOS/tasks.c **** 	}
3524:../src/FreeRTOS/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3525:../src/FreeRTOS/tasks.c **** 
3526:../src/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
3527:../src/FreeRTOS/tasks.c **** 	{
3528:../src/FreeRTOS/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
3529:../src/FreeRTOS/tasks.c **** 	}
3530:../src/FreeRTOS/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
3531:../src/FreeRTOS/tasks.c **** 
3532:../src/FreeRTOS/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3533:../src/FreeRTOS/tasks.c **** 	using list2. */
3534:../src/FreeRTOS/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
3535:../src/FreeRTOS/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
3536:../src/FreeRTOS/tasks.c **** }
3537:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3538:../src/FreeRTOS/tasks.c **** 
3539:../src/FreeRTOS/tasks.c **** static void prvCheckTasksWaitingTermination( void )
3540:../src/FreeRTOS/tasks.c **** {
3541:../src/FreeRTOS/tasks.c **** 
3542:../src/FreeRTOS/tasks.c **** 	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3543:../src/FreeRTOS/tasks.c **** 
3544:../src/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3545:../src/FreeRTOS/tasks.c **** 	{
3546:../src/FreeRTOS/tasks.c **** 		TCB_t *pxTCB;
3547:../src/FreeRTOS/tasks.c **** 
3548:../src/FreeRTOS/tasks.c **** 		/* uxDeletedTasksWaitingCleanUp is used to prevent vTaskSuspendAll()
3549:../src/FreeRTOS/tasks.c **** 		being called too often in the idle task. */
3550:../src/FreeRTOS/tasks.c **** 		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
3551:../src/FreeRTOS/tasks.c **** 		{
3552:../src/FreeRTOS/tasks.c **** 			taskENTER_CRITICAL();
3553:../src/FreeRTOS/tasks.c **** 			{
3554:../src/FreeRTOS/tasks.c **** 				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
3555:../src/FreeRTOS/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
3556:../src/FreeRTOS/tasks.c **** 				--uxCurrentNumberOfTasks;
3557:../src/FreeRTOS/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
3558:../src/FreeRTOS/tasks.c **** 			}
3559:../src/FreeRTOS/tasks.c **** 			taskEXIT_CRITICAL();
3560:../src/FreeRTOS/tasks.c **** 
3561:../src/FreeRTOS/tasks.c **** 			prvDeleteTCB( pxTCB );
3562:../src/FreeRTOS/tasks.c **** 		}
3563:../src/FreeRTOS/tasks.c **** 	}
3564:../src/FreeRTOS/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3565:../src/FreeRTOS/tasks.c **** }
3566:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3567:../src/FreeRTOS/tasks.c **** 
3568:../src/FreeRTOS/tasks.c **** #if( configUSE_TRACE_FACILITY == 1 )
3569:../src/FreeRTOS/tasks.c **** 
3570:../src/FreeRTOS/tasks.c **** 	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, 
3571:../src/FreeRTOS/tasks.c **** 	{
3572:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
3573:../src/FreeRTOS/tasks.c **** 
3574:../src/FreeRTOS/tasks.c **** 		/* xTask is NULL then get the state of the calling task. */
3575:../src/FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3576:../src/FreeRTOS/tasks.c **** 
3577:../src/FreeRTOS/tasks.c **** 		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3578:../src/FreeRTOS/tasks.c **** 		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
3579:../src/FreeRTOS/tasks.c **** 		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3580:../src/FreeRTOS/tasks.c **** 		pxTaskStatus->pxStackBase = pxTCB->pxStack;
3581:../src/FreeRTOS/tasks.c **** 		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3582:../src/FreeRTOS/tasks.c **** 
3583:../src/FreeRTOS/tasks.c **** 		#if ( configUSE_MUTEXES == 1 )
3584:../src/FreeRTOS/tasks.c **** 		{
3585:../src/FreeRTOS/tasks.c **** 			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3586:../src/FreeRTOS/tasks.c **** 		}
3587:../src/FreeRTOS/tasks.c **** 		#else
3588:../src/FreeRTOS/tasks.c **** 		{
3589:../src/FreeRTOS/tasks.c **** 			pxTaskStatus->uxBasePriority = 0;
3590:../src/FreeRTOS/tasks.c **** 		}
3591:../src/FreeRTOS/tasks.c **** 		#endif
3592:../src/FreeRTOS/tasks.c **** 
3593:../src/FreeRTOS/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3594:../src/FreeRTOS/tasks.c **** 		{
3595:../src/FreeRTOS/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3596:../src/FreeRTOS/tasks.c **** 		}
3597:../src/FreeRTOS/tasks.c **** 		#else
3598:../src/FreeRTOS/tasks.c **** 		{
3599:../src/FreeRTOS/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = 0;
3600:../src/FreeRTOS/tasks.c **** 		}
3601:../src/FreeRTOS/tasks.c **** 		#endif
3602:../src/FreeRTOS/tasks.c **** 
3603:../src/FreeRTOS/tasks.c **** 		/* Obtaining the task state is a little fiddly, so is only done if the
3604:../src/FreeRTOS/tasks.c **** 		value of eState passed into this function is eInvalid - otherwise the
3605:../src/FreeRTOS/tasks.c **** 		state is just set to whatever is passed in. */
3606:../src/FreeRTOS/tasks.c **** 		if( eState != eInvalid )
3607:../src/FreeRTOS/tasks.c **** 		{
3608:../src/FreeRTOS/tasks.c **** 			if( pxTCB == pxCurrentTCB )
3609:../src/FreeRTOS/tasks.c **** 			{
3610:../src/FreeRTOS/tasks.c **** 				pxTaskStatus->eCurrentState = eRunning;
3611:../src/FreeRTOS/tasks.c **** 			}
3612:../src/FreeRTOS/tasks.c **** 			else
3613:../src/FreeRTOS/tasks.c **** 			{
3614:../src/FreeRTOS/tasks.c **** 				pxTaskStatus->eCurrentState = eState;
3615:../src/FreeRTOS/tasks.c **** 
3616:../src/FreeRTOS/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
3617:../src/FreeRTOS/tasks.c **** 				{
3618:../src/FreeRTOS/tasks.c **** 					/* If the task is in the suspended list then there is a
3619:../src/FreeRTOS/tasks.c **** 					chance it is actually just blocked indefinitely - so really
3620:../src/FreeRTOS/tasks.c **** 					it should be reported as being in the Blocked state. */
3621:../src/FreeRTOS/tasks.c **** 					if( eState == eSuspended )
3622:../src/FreeRTOS/tasks.c **** 					{
3623:../src/FreeRTOS/tasks.c **** 						vTaskSuspendAll();
3624:../src/FreeRTOS/tasks.c **** 						{
3625:../src/FreeRTOS/tasks.c **** 							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3626:../src/FreeRTOS/tasks.c **** 							{
3627:../src/FreeRTOS/tasks.c **** 								pxTaskStatus->eCurrentState = eBlocked;
3628:../src/FreeRTOS/tasks.c **** 							}
3629:../src/FreeRTOS/tasks.c **** 						}
3630:../src/FreeRTOS/tasks.c **** 						( void ) xTaskResumeAll();
3631:../src/FreeRTOS/tasks.c **** 					}
3632:../src/FreeRTOS/tasks.c **** 				}
3633:../src/FreeRTOS/tasks.c **** 				#endif /* INCLUDE_vTaskSuspend */
3634:../src/FreeRTOS/tasks.c **** 			}
3635:../src/FreeRTOS/tasks.c **** 		}
3636:../src/FreeRTOS/tasks.c **** 		else
3637:../src/FreeRTOS/tasks.c **** 		{
3638:../src/FreeRTOS/tasks.c **** 			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
3639:../src/FreeRTOS/tasks.c **** 		}
3640:../src/FreeRTOS/tasks.c **** 
3641:../src/FreeRTOS/tasks.c **** 		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3642:../src/FreeRTOS/tasks.c **** 		parameter is provided to allow it to be skipped. */
3643:../src/FreeRTOS/tasks.c **** 		if( xGetFreeStackSpace != pdFALSE )
3644:../src/FreeRTOS/tasks.c **** 		{
3645:../src/FreeRTOS/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
3646:../src/FreeRTOS/tasks.c **** 			{
3647:../src/FreeRTOS/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfSt
3648:../src/FreeRTOS/tasks.c **** 			}
3649:../src/FreeRTOS/tasks.c **** 			#else
3650:../src/FreeRTOS/tasks.c **** 			{
3651:../src/FreeRTOS/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack )
3652:../src/FreeRTOS/tasks.c **** 			}
3653:../src/FreeRTOS/tasks.c **** 			#endif
3654:../src/FreeRTOS/tasks.c **** 		}
3655:../src/FreeRTOS/tasks.c **** 		else
3656:../src/FreeRTOS/tasks.c **** 		{
3657:../src/FreeRTOS/tasks.c **** 			pxTaskStatus->usStackHighWaterMark = 0;
3658:../src/FreeRTOS/tasks.c **** 		}
3659:../src/FreeRTOS/tasks.c **** 	}
3660:../src/FreeRTOS/tasks.c **** 
3661:../src/FreeRTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3662:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3663:../src/FreeRTOS/tasks.c **** 
3664:../src/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3665:../src/FreeRTOS/tasks.c **** 
3666:../src/FreeRTOS/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
3667:../src/FreeRTOS/tasks.c **** 	{
3668:../src/FreeRTOS/tasks.c **** 	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
3669:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxTask = 0;
3670:../src/FreeRTOS/tasks.c **** 
3671:../src/FreeRTOS/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3672:../src/FreeRTOS/tasks.c **** 		{
3673:../src/FreeRTOS/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
3674:../src/FreeRTOS/tasks.c **** 
3675:../src/FreeRTOS/tasks.c **** 			/* Populate an TaskStatus_t structure within the
3676:../src/FreeRTOS/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
3677:../src/FreeRTOS/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
3678:../src/FreeRTOS/tasks.c **** 			meaning of each TaskStatus_t structure member. */
3679:../src/FreeRTOS/tasks.c **** 			do
3680:../src/FreeRTOS/tasks.c **** 			{
3681:../src/FreeRTOS/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
3682:../src/FreeRTOS/tasks.c **** 				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
3683:../src/FreeRTOS/tasks.c **** 				uxTask++;
3684:../src/FreeRTOS/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
3685:../src/FreeRTOS/tasks.c **** 		}
3686:../src/FreeRTOS/tasks.c **** 		else
3687:../src/FreeRTOS/tasks.c **** 		{
3688:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3689:../src/FreeRTOS/tasks.c **** 		}
3690:../src/FreeRTOS/tasks.c **** 
3691:../src/FreeRTOS/tasks.c **** 		return uxTask;
3692:../src/FreeRTOS/tasks.c **** 	}
3693:../src/FreeRTOS/tasks.c **** 
3694:../src/FreeRTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3695:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3696:../src/FreeRTOS/tasks.c **** 
3697:../src/FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3698:../src/FreeRTOS/tasks.c **** 
3699:../src/FreeRTOS/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3700:../src/FreeRTOS/tasks.c **** 	{
  25              		.loc 1 3700 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29              		@ link register save eliminated.
  30              	.LVL0:
3701:../src/FreeRTOS/tasks.c **** 	uint32_t ulCount = 0U;
  31              		.loc 1 3701 0
  32 0000 0030A0E3 		mov	r3, #0
3702:../src/FreeRTOS/tasks.c **** 
3703:../src/FreeRTOS/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
  33              		.loc 1 3703 0
  34 0004 010000EA 		b	.L2
  35              	.LVL1:
  36              	.L3:
3704:../src/FreeRTOS/tasks.c **** 		{
3705:../src/FreeRTOS/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
  37              		.loc 1 3705 0
  38 0008 010080E2 		add	r0, r0, #1
  39              	.LVL2:
3706:../src/FreeRTOS/tasks.c **** 			ulCount++;
  40              		.loc 1 3706 0
  41 000c 013083E2 		add	r3, r3, #1
  42              	.LVL3:
  43              	.L2:
3703:../src/FreeRTOS/tasks.c **** 		{
  44              		.loc 1 3703 0
  45 0010 0020D0E5 		ldrb	r2, [r0]	@ zero_extendqisi2
  46 0014 A50052E3 		cmp	r2, #165
  47 0018 FAFFFF0A 		beq	.L3
  48              	.LVL4:
3707:../src/FreeRTOS/tasks.c **** 		}
3708:../src/FreeRTOS/tasks.c **** 
3709:../src/FreeRTOS/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
3710:../src/FreeRTOS/tasks.c **** 
3711:../src/FreeRTOS/tasks.c **** 		return ( uint16_t ) ulCount;
3712:../src/FreeRTOS/tasks.c **** 	}
  49              		.loc 1 3712 0
  50 001c 5301EFE7 		ubfx	r0, r3, #2, #16
  51              	.LVL5:
  52 0020 1EFF2FE1 		bx	lr
  53              		.cfi_endproc
  54              	.LFE47:
  56              		.section	.text.prvResetNextTaskUnblockTime,"ax",%progbits
  57              		.align	2
  58              		.syntax unified
  59              		.arm
  60              		.fpu neon
  62              	prvResetNextTaskUnblockTime:
  63              	.LFB50:
3713:../src/FreeRTOS/tasks.c **** 
3714:../src/FreeRTOS/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3715:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3716:../src/FreeRTOS/tasks.c **** 
3717:../src/FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3718:../src/FreeRTOS/tasks.c **** 
3719:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3720:../src/FreeRTOS/tasks.c **** 	{
3721:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
3722:../src/FreeRTOS/tasks.c **** 	uint8_t *pucEndOfStack;
3723:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxReturn;
3724:../src/FreeRTOS/tasks.c **** 
3725:../src/FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3726:../src/FreeRTOS/tasks.c **** 
3727:../src/FreeRTOS/tasks.c **** 		#if portSTACK_GROWTH < 0
3728:../src/FreeRTOS/tasks.c **** 		{
3729:../src/FreeRTOS/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3730:../src/FreeRTOS/tasks.c **** 		}
3731:../src/FreeRTOS/tasks.c **** 		#else
3732:../src/FreeRTOS/tasks.c **** 		{
3733:../src/FreeRTOS/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3734:../src/FreeRTOS/tasks.c **** 		}
3735:../src/FreeRTOS/tasks.c **** 		#endif
3736:../src/FreeRTOS/tasks.c **** 
3737:../src/FreeRTOS/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3738:../src/FreeRTOS/tasks.c **** 
3739:../src/FreeRTOS/tasks.c **** 		return uxReturn;
3740:../src/FreeRTOS/tasks.c **** 	}
3741:../src/FreeRTOS/tasks.c **** 
3742:../src/FreeRTOS/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3743:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3744:../src/FreeRTOS/tasks.c **** 
3745:../src/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3746:../src/FreeRTOS/tasks.c **** 
3747:../src/FreeRTOS/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3748:../src/FreeRTOS/tasks.c **** 	{
3749:../src/FreeRTOS/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3750:../src/FreeRTOS/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3751:../src/FreeRTOS/tasks.c **** 		want to allocate and clean RAM statically. */
3752:../src/FreeRTOS/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3753:../src/FreeRTOS/tasks.c **** 
3754:../src/FreeRTOS/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3755:../src/FreeRTOS/tasks.c **** 		to the task to free any memory allocated at the application level. */
3756:../src/FreeRTOS/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3757:../src/FreeRTOS/tasks.c **** 		{
3758:../src/FreeRTOS/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3759:../src/FreeRTOS/tasks.c **** 		}
3760:../src/FreeRTOS/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3761:../src/FreeRTOS/tasks.c **** 
3762:../src/FreeRTOS/tasks.c **** 		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( p
3763:../src/FreeRTOS/tasks.c **** 		{
3764:../src/FreeRTOS/tasks.c **** 			/* The task can only have been allocated dynamically - free both
3765:../src/FreeRTOS/tasks.c **** 			the stack and TCB. */
3766:../src/FreeRTOS/tasks.c **** 			vPortFree( pxTCB->pxStack );
3767:../src/FreeRTOS/tasks.c **** 			vPortFree( pxTCB );
3768:../src/FreeRTOS/tasks.c **** 		}
3769:../src/FreeRTOS/tasks.c **** 		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated 
3770:../src/FreeRTOS/tasks.c **** 		{
3771:../src/FreeRTOS/tasks.c **** 			/* The task could have been allocated statically or dynamically, so
3772:../src/FreeRTOS/tasks.c **** 			check what was statically allocated before trying to free the
3773:../src/FreeRTOS/tasks.c **** 			memory. */
3774:../src/FreeRTOS/tasks.c **** 			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
3775:../src/FreeRTOS/tasks.c **** 			{
3776:../src/FreeRTOS/tasks.c **** 				/* Both the stack and TCB were allocated dynamically, so both
3777:../src/FreeRTOS/tasks.c **** 				must be freed. */
3778:../src/FreeRTOS/tasks.c **** 				vPortFree( pxTCB->pxStack );
3779:../src/FreeRTOS/tasks.c **** 				vPortFree( pxTCB );
3780:../src/FreeRTOS/tasks.c **** 			}
3781:../src/FreeRTOS/tasks.c **** 			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
3782:../src/FreeRTOS/tasks.c **** 			{
3783:../src/FreeRTOS/tasks.c **** 				/* Only the stack was statically allocated, so the TCB is the
3784:../src/FreeRTOS/tasks.c **** 				only memory that must be freed. */
3785:../src/FreeRTOS/tasks.c **** 				vPortFree( pxTCB );
3786:../src/FreeRTOS/tasks.c **** 			}
3787:../src/FreeRTOS/tasks.c **** 			else
3788:../src/FreeRTOS/tasks.c **** 			{
3789:../src/FreeRTOS/tasks.c **** 				/* Neither the stack nor the TCB were allocated dynamically, so
3790:../src/FreeRTOS/tasks.c **** 				nothing needs to be freed. */
3791:../src/FreeRTOS/tasks.c **** 				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
3792:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3793:../src/FreeRTOS/tasks.c **** 			}
3794:../src/FreeRTOS/tasks.c **** 		}
3795:../src/FreeRTOS/tasks.c **** 		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3796:../src/FreeRTOS/tasks.c **** 	}
3797:../src/FreeRTOS/tasks.c **** 
3798:../src/FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3799:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3800:../src/FreeRTOS/tasks.c **** 
3801:../src/FreeRTOS/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3802:../src/FreeRTOS/tasks.c **** {
  64              		.loc 1 3802 0
  65              		.cfi_startproc
  66              		@ args = 0, pretend = 0, frame = 0
  67              		@ frame_needed = 0, uses_anonymous_args = 0
  68              		@ link register save eliminated.
3803:../src/FreeRTOS/tasks.c **** TCB_t *pxTCB;
3804:../src/FreeRTOS/tasks.c **** 
3805:../src/FreeRTOS/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  69              		.loc 1 3805 0
  70 0000 003000E3 		movw	r3, #:lower16:.LANCHOR0
  71 0004 003040E3 		movt	r3, #:upper16:.LANCHOR0
  72 0008 003093E5 		ldr	r3, [r3]
  73 000c 003093E5 		ldr	r3, [r3]
  74 0010 000053E3 		cmp	r3, #0
  75 0014 0C00001A 		bne	.L8
  76 0018 0130A0E3 		mov	r3, #1
  77              	.L5:
  78              		.loc 1 3805 0 is_stmt 0 discriminator 4
  79 001c 000053E3 		cmp	r3, #0
  80 0020 0B00001A 		bne	.L9
3806:../src/FreeRTOS/tasks.c **** 	{
3807:../src/FreeRTOS/tasks.c **** 		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3808:../src/FreeRTOS/tasks.c **** 		the maximum possible value so it is	extremely unlikely that the
3809:../src/FreeRTOS/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3810:../src/FreeRTOS/tasks.c **** 		there is an item in the delayed list. */
3811:../src/FreeRTOS/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
3812:../src/FreeRTOS/tasks.c **** 	}
3813:../src/FreeRTOS/tasks.c **** 	else
3814:../src/FreeRTOS/tasks.c **** 	{
3815:../src/FreeRTOS/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3816:../src/FreeRTOS/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3817:../src/FreeRTOS/tasks.c **** 		which the task at the head of the delayed list should be removed
3818:../src/FreeRTOS/tasks.c **** 		from the Blocked state. */
3819:../src/FreeRTOS/tasks.c **** 		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  81              		.loc 1 3819 0 is_stmt 1
  82 0024 003000E3 		movw	r3, #:lower16:.LANCHOR0
  83 0028 003040E3 		movt	r3, #:upper16:.LANCHOR0
  84 002c 003093E5 		ldr	r3, [r3]
  85 0030 0C3093E5 		ldr	r3, [r3, #12]
  86 0034 0C3093E5 		ldr	r3, [r3, #12]
  87              	.LVL6:
3820:../src/FreeRTOS/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
  88              		.loc 1 3820 0
  89 0038 042093E5 		ldr	r2, [r3, #4]
  90 003c 003000E3 		movw	r3, #:lower16:.LANCHOR1
  91              	.LVL7:
  92 0040 003040E3 		movt	r3, #:upper16:.LANCHOR1
  93 0044 002083E5 		str	r2, [r3]
  94 0048 1EFF2FE1 		bx	lr
  95              	.L8:
3805:../src/FreeRTOS/tasks.c **** 	{
  96              		.loc 1 3805 0
  97 004c 0030A0E3 		mov	r3, #0
  98 0050 F1FFFFEA 		b	.L5
  99              	.L9:
3811:../src/FreeRTOS/tasks.c **** 	}
 100              		.loc 1 3811 0
 101 0054 003000E3 		movw	r3, #:lower16:.LANCHOR1
 102 0058 003040E3 		movt	r3, #:upper16:.LANCHOR1
 103 005c 0020E0E3 		mvn	r2, #0
 104 0060 002083E5 		str	r2, [r3]
 105 0064 1EFF2FE1 		bx	lr
 106              		.cfi_endproc
 107              	.LFE50:
 109              		.section	.text.prvDeleteTCB,"ax",%progbits
 110              		.align	2
 111              		.syntax unified
 112              		.arm
 113              		.fpu neon
 115              	prvDeleteTCB:
 116              	.LFB49:
3748:../src/FreeRTOS/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
 117              		.loc 1 3748 0
 118              		.cfi_startproc
 119              		@ args = 0, pretend = 0, frame = 0
 120              		@ frame_needed = 0, uses_anonymous_args = 0
 121              	.LVL8:
 122 0000 10402DE9 		push	{r4, lr}
 123              		.cfi_def_cfa_offset 8
 124              		.cfi_offset 4, -8
 125              		.cfi_offset 14, -4
 126 0004 0040A0E1 		mov	r4, r0
3766:../src/FreeRTOS/tasks.c **** 			vPortFree( pxTCB );
 127              		.loc 1 3766 0
 128 0008 300090E5 		ldr	r0, [r0, #48]
 129              	.LVL9:
 130 000c FEFFFFEB 		bl	vPortFree
 131              	.LVL10:
3767:../src/FreeRTOS/tasks.c **** 		}
 132              		.loc 1 3767 0
 133 0010 0400A0E1 		mov	r0, r4
 134 0014 FEFFFFEB 		bl	vPortFree
 135              	.LVL11:
 136 0018 1080BDE8 		pop	{r4, pc}
 137              		.cfi_endproc
 138              	.LFE49:
 140              		.section	.text.prvTaskIsTaskSuspended,"ax",%progbits
 141              		.align	2
 142              		.syntax unified
 143              		.arm
 144              		.fpu neon
 146              	prvTaskIsTaskSuspended:
 147              	.LFB12:
1743:../src/FreeRTOS/tasks.c **** 	BaseType_t xReturn = pdFALSE;
 148              		.loc 1 1743 0
 149              		.cfi_startproc
 150              		@ args = 0, pretend = 0, frame = 0
 151              		@ frame_needed = 0, uses_anonymous_args = 0
 152              	.LVL12:
 153 0000 10402DE9 		push	{r4, lr}
 154              		.cfi_def_cfa_offset 8
 155              		.cfi_offset 4, -8
 156              		.cfi_offset 14, -4
 157              	.LVL13:
1751:../src/FreeRTOS/tasks.c **** 
 158              		.loc 1 1751 0
 159 0004 004050E2 		subs	r4, r0, #0
 160 0008 1200000A 		beq	.L23
 161              	.LVL14:
 162              	.L13:
1754:../src/FreeRTOS/tasks.c **** 		{
 163              		.loc 1 1754 0
 164 000c 142094E5 		ldr	r2, [r4, #20]
 165 0010 003000E3 		movw	r3, #:lower16:.LANCHOR2
 166 0014 003040E3 		movt	r3, #:upper16:.LANCHOR2
 167 0018 030052E1 		cmp	r2, r3
 168 001c 1200000A 		beq	.L24
 169 0020 0030A0E3 		mov	r3, #0
 170              	.L14:
1754:../src/FreeRTOS/tasks.c **** 		{
 171              		.loc 1 1754 0 is_stmt 0 discriminator 4
 172 0024 000053E3 		cmp	r3, #0
 173 0028 1300000A 		beq	.L18
1757:../src/FreeRTOS/tasks.c **** 			{
 174              		.loc 1 1757 0 is_stmt 1
 175 002c 281094E5 		ldr	r1, [r4, #40]
 176 0030 002000E3 		movw	r2, #:lower16:.LANCHOR3
 177 0034 002040E3 		movt	r2, #:upper16:.LANCHOR3
 178 0038 020051E1 		cmp	r1, r2
 179 003c 1000000A 		beq	.L19
1761:../src/FreeRTOS/tasks.c **** 				{
 180              		.loc 1 1761 0
 181 0040 000051E3 		cmp	r1, #0
 182 0044 0030A013 		movne	r3, #0
 183              	.L16:
1761:../src/FreeRTOS/tasks.c **** 				{
 184              		.loc 1 1761 0 is_stmt 0 discriminator 4
 185 0048 000053E3 		cmp	r3, #0
 186 004c 0800000A 		beq	.L25
1763:../src/FreeRTOS/tasks.c **** 				}
 187              		.loc 1 1763 0 is_stmt 1
 188 0050 0100A0E3 		mov	r0, #1
 189              	.LVL15:
1781:../src/FreeRTOS/tasks.c **** 
 190              		.loc 1 1781 0
 191 0054 1080BDE8 		pop	{r4, pc}
 192              	.LVL16:
 193              	.L23:
1751:../src/FreeRTOS/tasks.c **** 
 194              		.loc 1 1751 0 discriminator 1
 195 0058 D71600E3 		movw	r1, #1751
 196 005c 000000E3 		movw	r0, #:lower16:.LC0
 197              	.LVL17:
 198 0060 000040E3 		movt	r0, #:upper16:.LC0
 199 0064 FEFFFFEB 		bl	R_OS_AssertCalled
 200              	.LVL18:
 201 0068 E7FFFFEA 		b	.L13
 202              	.L24:
1754:../src/FreeRTOS/tasks.c **** 		{
 203              		.loc 1 1754 0
 204 006c 0130A0E3 		mov	r3, #1
 205 0070 EBFFFFEA 		b	.L14
 206              	.L25:
1744:../src/FreeRTOS/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 207              		.loc 1 1744 0
 208 0074 0000A0E3 		mov	r0, #0
 209 0078 1080BDE8 		pop	{r4, pc}
 210              	.L18:
 211 007c 0000A0E3 		mov	r0, #0
 212 0080 1080BDE8 		pop	{r4, pc}
 213              	.L19:
 214 0084 0000A0E3 		mov	r0, #0
 215 0088 1080BDE8 		pop	{r4, pc}
 216              		.cfi_endproc
 217              	.LFE12:
 219              		.section	.text.prvInitialiseNewTask,"ax",%progbits
 220              		.align	2
 221              		.syntax unified
 222              		.arm
 223              		.fpu neon
 225              	prvInitialiseNewTask:
 226              	.LFB2:
 842:../src/FreeRTOS/tasks.c **** StackType_t *pxTopOfStack;
 227              		.loc 1 842 0
 228              		.cfi_startproc
 229              		@ args = 16, pretend = 0, frame = 0
 230              		@ frame_needed = 0, uses_anonymous_args = 0
 231              	.LVL19:
 232 0000 F84F2DE9 		push	{r3, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 233              		.cfi_def_cfa_offset 40
 234              		.cfi_offset 3, -40
 235              		.cfi_offset 4, -36
 236              		.cfi_offset 5, -32
 237              		.cfi_offset 6, -28
 238              		.cfi_offset 7, -24
 239              		.cfi_offset 8, -20
 240              		.cfi_offset 9, -16
 241              		.cfi_offset 10, -12
 242              		.cfi_offset 11, -8
 243              		.cfi_offset 14, -4
 244 0004 0090A0E1 		mov	r9, r0
 245 0008 0150A0E1 		mov	r5, r1
 246 000c 02B0A0E1 		mov	fp, r2
 247 0010 03A0A0E1 		mov	r10, r3
 248 0014 28609DE5 		ldr	r6, [sp, #40]
 249 0018 2C809DE5 		ldr	r8, [sp, #44]
 250 001c 30409DE5 		ldr	r4, [sp, #48]
 864:../src/FreeRTOS/tasks.c **** 	}
 251              		.loc 1 864 0
 252 0020 0221A0E1 		lsl	r2, r2, #2
 253              	.LVL20:
 254 0024 A510A0E3 		mov	r1, #165
 255              	.LVL21:
 256 0028 300094E5 		ldr	r0, [r4, #48]
 257              	.LVL22:
 258 002c FEFFFFEB 		bl	memset
 259              	.LVL23:
 874:../src/FreeRTOS/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 260              		.loc 1 874 0
 261 0030 307094E5 		ldr	r7, [r4, #48]
 262 0034 07B14BE2 		sub	fp, fp, #-1073741823
 263              	.LVL24:
 264 0038 0BB187E0 		add	fp, r7, fp, lsl #2
 265              	.LVL25:
 875:../src/FreeRTOS/tasks.c **** 
 266              		.loc 1 875 0
 267 003c 07B0CBE3 		bic	fp, fp, #7
 268              	.LVL26:
 884:../src/FreeRTOS/tasks.c **** 		}
 269              		.loc 1 884 0
 270 0040 4CB084E5 		str	fp, [r4, #76]
 271              	.LVL27:
 902:../src/FreeRTOS/tasks.c **** 	{
 272              		.loc 1 902 0
 273 0044 0030A0E3 		mov	r3, #0
 274              	.LVL28:
 275              	.L27:
 902:../src/FreeRTOS/tasks.c **** 	{
 276              		.loc 1 902 0 is_stmt 0 discriminator 1
 277 0048 170053E3 		cmp	r3, #23
 278 004c 0600008A 		bhi	.L28
 904:../src/FreeRTOS/tasks.c **** 
 279              		.loc 1 904 0 is_stmt 1
 280 0050 0310D5E7 		ldrb	r1, [r5, r3]	@ zero_extendqisi2
 281 0054 032084E0 		add	r2, r4, r3
 282 0058 3410C2E5 		strb	r1, [r2, #52]
 909:../src/FreeRTOS/tasks.c **** 		{
 283              		.loc 1 909 0
 284 005c 0320D5E7 		ldrb	r2, [r5, r3]	@ zero_extendqisi2
 285 0060 000052E3 		cmp	r2, #0
 902:../src/FreeRTOS/tasks.c **** 	{
 286              		.loc 1 902 0 discriminator 2
 287 0064 01308312 		addne	r3, r3, #1
 288              	.LVL29:
 289 0068 F6FFFF1A 		bne	.L27
 290              	.L28:
 921:../src/FreeRTOS/tasks.c **** 
 291              		.loc 1 921 0
 292 006c 0030A0E3 		mov	r3, #0
 293              	.LVL30:
 294 0070 4B30C4E5 		strb	r3, [r4, #75]
 925:../src/FreeRTOS/tasks.c **** 	{
 295              		.loc 1 925 0
 296 0074 130056E3 		cmp	r6, #19
 927:../src/FreeRTOS/tasks.c **** 	}
 297              		.loc 1 927 0
 298 0078 1360A083 		movhi	r6, #19
 299              	.L30:
 300              	.LVL31:
 934:../src/FreeRTOS/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 301              		.loc 1 934 0
 302 007c 2C6084E5 		str	r6, [r4, #44]
 937:../src/FreeRTOS/tasks.c **** 		pxNewTCB->uxMutexesHeld = 0;
 303              		.loc 1 937 0
 304 0080 586084E5 		str	r6, [r4, #88]
 938:../src/FreeRTOS/tasks.c **** 	}
 305              		.loc 1 938 0
 306 0084 0050A0E3 		mov	r5, #0
 307              	.LVL32:
 308 0088 5C5084E5 		str	r5, [r4, #92]
 942:../src/FreeRTOS/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 309              		.loc 1 942 0
 310 008c 040084E2 		add	r0, r4, #4
 311 0090 FEFFFFEB 		bl	vListInitialiseItem
 312              	.LVL33:
 943:../src/FreeRTOS/tasks.c **** 
 313              		.loc 1 943 0
 314 0094 180084E2 		add	r0, r4, #24
 315 0098 FEFFFFEB 		bl	vListInitialiseItem
 316              	.LVL34:
 947:../src/FreeRTOS/tasks.c **** 
 317              		.loc 1 947 0
 318 009c 104084E5 		str	r4, [r4, #16]
 950:../src/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 319              		.loc 1 950 0
 320 00a0 146066E2 		rsb	r6, r6, #20
 321              	.LVL35:
 322 00a4 186084E5 		str	r6, [r4, #24]
 951:../src/FreeRTOS/tasks.c **** 
 323              		.loc 1 951 0
 324 00a8 244084E5 		str	r4, [r4, #36]
 967:../src/FreeRTOS/tasks.c **** 	}
 325              		.loc 1 967 0
 326 00ac 6C5084E5 		str	r5, [r4, #108]
 327              	.LVL36:
 984:../src/FreeRTOS/tasks.c **** 		{
 328              		.loc 1 984 0
 329 00b0 0530A0E1 		mov	r3, r5
 330 00b4 030000EA 		b	.L31
 331              	.LVL37:
 332              	.L32:
 986:../src/FreeRTOS/tasks.c **** 		}
 333              		.loc 1 986 0 discriminator 3
 334 00b8 182083E2 		add	r2, r3, #24
 335 00bc 0010A0E3 		mov	r1, #0
 336 00c0 021184E7 		str	r1, [r4, r2, lsl #2]
 984:../src/FreeRTOS/tasks.c **** 		{
 337              		.loc 1 984 0 discriminator 3
 338 00c4 013083E2 		add	r3, r3, #1
 339              	.LVL38:
 340              	.L31:
 984:../src/FreeRTOS/tasks.c **** 		{
 341              		.loc 1 984 0 is_stmt 0 discriminator 1
 342 00c8 020053E3 		cmp	r3, #2
 343 00cc F9FFFF9A 		bls	.L32
 993:../src/FreeRTOS/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 344              		.loc 1 993 0 is_stmt 1
 345 00d0 0030A0E3 		mov	r3, #0
 346              	.LVL39:
 347 00d4 703084E5 		str	r3, [r4, #112]
 994:../src/FreeRTOS/tasks.c **** 	}
 348              		.loc 1 994 0
 349 00d8 7430C4E5 		strb	r3, [r4, #116]
1007:../src/FreeRTOS/tasks.c **** 	}
 350              		.loc 1 1007 0
 351 00dc 7530C4E5 		strb	r3, [r4, #117]
1021:../src/FreeRTOS/tasks.c **** 	}
 352              		.loc 1 1021 0
 353 00e0 0A20A0E1 		mov	r2, r10
 354 00e4 0910A0E1 		mov	r1, r9
 355 00e8 0B00A0E1 		mov	r0, fp
 356 00ec FEFFFFEB 		bl	pxPortInitialiseStack
 357              	.LVL40:
 358 00f0 000084E5 		str	r0, [r4]
1025:../src/FreeRTOS/tasks.c **** 	{
 359              		.loc 1 1025 0
 360 00f4 000058E3 		cmp	r8, #0
1029:../src/FreeRTOS/tasks.c **** 	}
 361              		.loc 1 1029 0
 362 00f8 00408815 		strne	r4, [r8]
 363 00fc F88FBDE8 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 364              		.cfi_endproc
 365              	.LFE2:
 367              		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 368              		.align	2
 369              		.syntax unified
 370              		.arm
 371              		.fpu neon
 373              	prvInitialiseTaskLists:
 374              	.LFB43:
3508:../src/FreeRTOS/tasks.c **** UBaseType_t uxPriority;
 375              		.loc 1 3508 0
 376              		.cfi_startproc
 377              		@ args = 0, pretend = 0, frame = 0
 378              		@ frame_needed = 0, uses_anonymous_args = 0
 379 0000 70402DE9 		push	{r4, r5, r6, lr}
 380              		.cfi_def_cfa_offset 16
 381              		.cfi_offset 4, -16
 382              		.cfi_offset 5, -12
 383              		.cfi_offset 6, -8
 384              		.cfi_offset 14, -4
 385              	.LVL41:
3511:../src/FreeRTOS/tasks.c **** 	{
 386              		.loc 1 3511 0
 387 0004 0040A0E3 		mov	r4, #0
 388 0008 060000EA 		b	.L37
 389              	.LVL42:
 390              	.L38:
3513:../src/FreeRTOS/tasks.c **** 	}
 391              		.loc 1 3513 0 discriminator 3
 392 000c 003000E3 		movw	r3, #:lower16:.LANCHOR4
 393 0010 003040E3 		movt	r3, #:upper16:.LANCHOR4
 394 0014 042184E0 		add	r2, r4, r4, lsl #2
 395 0018 0201A0E1 		lsl	r0, r2, #2
 396 001c 000083E0 		add	r0, r3, r0
 397 0020 FEFFFFEB 		bl	vListInitialise
 398              	.LVL43:
3511:../src/FreeRTOS/tasks.c **** 	{
 399              		.loc 1 3511 0 discriminator 3
 400 0024 014084E2 		add	r4, r4, #1
 401              	.LVL44:
 402              	.L37:
3511:../src/FreeRTOS/tasks.c **** 	{
 403              		.loc 1 3511 0 is_stmt 0 discriminator 1
 404 0028 130054E3 		cmp	r4, #19
 405 002c F6FFFF9A 		bls	.L38
3516:../src/FreeRTOS/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 406              		.loc 1 3516 0 is_stmt 1
 407 0030 005000E3 		movw	r5, #:lower16:.LANCHOR5
 408 0034 005040E3 		movt	r5, #:upper16:.LANCHOR5
 409 0038 0500A0E1 		mov	r0, r5
 410 003c FEFFFFEB 		bl	vListInitialise
 411              	.LVL45:
3517:../src/FreeRTOS/tasks.c **** 	vListInitialise( &xPendingReadyList );
 412              		.loc 1 3517 0
 413 0040 004000E3 		movw	r4, #:lower16:.LANCHOR6
 414              	.LVL46:
 415 0044 004040E3 		movt	r4, #:upper16:.LANCHOR6
 416 0048 0400A0E1 		mov	r0, r4
 417 004c FEFFFFEB 		bl	vListInitialise
 418              	.LVL47:
3518:../src/FreeRTOS/tasks.c **** 
 419              		.loc 1 3518 0
 420 0050 000000E3 		movw	r0, #:lower16:.LANCHOR3
 421 0054 000040E3 		movt	r0, #:upper16:.LANCHOR3
 422 0058 FEFFFFEB 		bl	vListInitialise
 423              	.LVL48:
3522:../src/FreeRTOS/tasks.c **** 	}
 424              		.loc 1 3522 0
 425 005c 000000E3 		movw	r0, #:lower16:.LANCHOR7
 426 0060 000040E3 		movt	r0, #:upper16:.LANCHOR7
 427 0064 FEFFFFEB 		bl	vListInitialise
 428              	.LVL49:
3528:../src/FreeRTOS/tasks.c **** 	}
 429              		.loc 1 3528 0
 430 0068 000000E3 		movw	r0, #:lower16:.LANCHOR2
 431 006c 000040E3 		movt	r0, #:upper16:.LANCHOR2
 432 0070 FEFFFFEB 		bl	vListInitialise
 433              	.LVL50:
3534:../src/FreeRTOS/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 434              		.loc 1 3534 0
 435 0074 003000E3 		movw	r3, #:lower16:.LANCHOR0
 436 0078 003040E3 		movt	r3, #:upper16:.LANCHOR0
 437 007c 005083E5 		str	r5, [r3]
3535:../src/FreeRTOS/tasks.c **** }
 438              		.loc 1 3535 0
 439 0080 003000E3 		movw	r3, #:lower16:.LANCHOR8
 440 0084 003040E3 		movt	r3, #:upper16:.LANCHOR8
 441 0088 004083E5 		str	r4, [r3]
 442 008c 7080BDE8 		pop	{r4, r5, r6, pc}
 443              		.cfi_endproc
 444              	.LFE43:
 446              		.section	.text.prvAddNewTaskToReadyList,"ax",%progbits
 447              		.align	2
 448              		.syntax unified
 449              		.arm
 450              		.fpu neon
 452              	prvAddNewTaskToReadyList:
 453              	.LFB3:
1039:../src/FreeRTOS/tasks.c **** 	/* Ensure interrupts don't access the task lists while the lists are being
 454              		.loc 1 1039 0
 455              		.cfi_startproc
 456              		@ args = 0, pretend = 0, frame = 0
 457              		@ frame_needed = 0, uses_anonymous_args = 0
 458              	.LVL51:
 459 0000 10402DE9 		push	{r4, lr}
 460              		.cfi_def_cfa_offset 8
 461              		.cfi_offset 4, -8
 462              		.cfi_offset 14, -4
 463 0004 0040A0E1 		mov	r4, r0
1042:../src/FreeRTOS/tasks.c **** 	{
 464              		.loc 1 1042 0
 465 0008 FEFFFFEB 		bl	vPortEnterCritical
 466              	.LVL52:
1044:../src/FreeRTOS/tasks.c **** 		if( pxCurrentTCB == NULL )
 467              		.loc 1 1044 0
 468 000c 003000E3 		movw	r3, #:lower16:.LANCHOR9
 469 0010 003040E3 		movt	r3, #:upper16:.LANCHOR9
 470 0014 002093E5 		ldr	r2, [r3]
 471 0018 012082E2 		add	r2, r2, #1
 472 001c 002083E5 		str	r2, [r3]
1045:../src/FreeRTOS/tasks.c **** 		{
 473              		.loc 1 1045 0
 474 0020 003000E3 		movw	r3, #:lower16:.LANCHOR10
 475 0024 003040E3 		movt	r3, #:upper16:.LANCHOR10
 476 0028 003093E5 		ldr	r3, [r3]
 477 002c 000053E3 		cmp	r3, #0
 478 0030 3100000A 		beq	.L46
1068:../src/FreeRTOS/tasks.c **** 			{
 479              		.loc 1 1068 0
 480 0034 003000E3 		movw	r3, #:lower16:.LANCHOR11
 481 0038 003040E3 		movt	r3, #:upper16:.LANCHOR11
 482 003c 003093E5 		ldr	r3, [r3]
 483 0040 000053E3 		cmp	r3, #0
 484 0044 0800001A 		bne	.L42
1070:../src/FreeRTOS/tasks.c **** 				{
 485              		.loc 1 1070 0
 486 0048 003000E3 		movw	r3, #:lower16:.LANCHOR10
 487 004c 003040E3 		movt	r3, #:upper16:.LANCHOR10
 488 0050 003093E5 		ldr	r3, [r3]
 489 0054 2C2093E5 		ldr	r2, [r3, #44]
 490 0058 2C3094E5 		ldr	r3, [r4, #44]
 491 005c 030052E1 		cmp	r2, r3
1072:../src/FreeRTOS/tasks.c **** 				}
 492              		.loc 1 1072 0
 493 0060 00300093 		movwls	r3, #:lower16:.LANCHOR10
 494 0064 00304093 		movtls	r3, #:upper16:.LANCHOR10
 495 0068 00408395 		strls	r4, [r3]
 496              	.L42:
1085:../src/FreeRTOS/tasks.c **** 
 497              		.loc 1 1085 0
 498 006c 002000E3 		movw	r2, #:lower16:.LANCHOR12
 499 0070 002040E3 		movt	r2, #:upper16:.LANCHOR12
 500 0074 003092E5 		ldr	r3, [r2]
 501 0078 013083E2 		add	r3, r3, #1
 502 007c 003082E5 		str	r3, [r2]
1090:../src/FreeRTOS/tasks.c **** 		}
 503              		.loc 1 1090 0
 504 0080 503084E5 		str	r3, [r4, #80]
1095:../src/FreeRTOS/tasks.c **** 
 505              		.loc 1 1095 0
 506 0084 2C3094E5 		ldr	r3, [r4, #44]
 507 0088 002000E3 		movw	r2, #:lower16:.LANCHOR13
 508 008c 002040E3 		movt	r2, #:upper16:.LANCHOR13
 509 0090 002092E5 		ldr	r2, [r2]
 510 0094 020053E1 		cmp	r3, r2
1095:../src/FreeRTOS/tasks.c **** 
 511              		.loc 1 1095 0 is_stmt 0 discriminator 1
 512 0098 00200083 		movwhi	r2, #:lower16:.LANCHOR13
 513 009c 00204083 		movthi	r2, #:upper16:.LANCHOR13
 514 00a0 00308285 		strhi	r3, [r2]
 515              	.L43:
1095:../src/FreeRTOS/tasks.c **** 
 516              		.loc 1 1095 0 discriminator 3
 517 00a4 002000E3 		movw	r2, #:lower16:.LANCHOR4
 518 00a8 002040E3 		movt	r2, #:upper16:.LANCHOR4
 519 00ac 033183E0 		add	r3, r3, r3, lsl #2
 520 00b0 0301A0E1 		lsl	r0, r3, #2
 521 00b4 041084E2 		add	r1, r4, #4
 522 00b8 000082E0 		add	r0, r2, r0
 523 00bc FEFFFFEB 		bl	vListInsertEnd
 524              	.LVL53:
1099:../src/FreeRTOS/tasks.c **** 
 525              		.loc 1 1099 0 is_stmt 1 discriminator 3
 526 00c0 FEFFFFEB 		bl	vPortExitCritical
 527              	.LVL54:
1101:../src/FreeRTOS/tasks.c **** 	{
 528              		.loc 1 1101 0 discriminator 3
 529 00c4 003000E3 		movw	r3, #:lower16:.LANCHOR11
 530 00c8 003040E3 		movt	r3, #:upper16:.LANCHOR11
 531 00cc 003093E5 		ldr	r3, [r3]
 532 00d0 000053E3 		cmp	r3, #0
 533 00d4 1080BD08 		popeq	{r4, pc}
1105:../src/FreeRTOS/tasks.c **** 		{
 534              		.loc 1 1105 0
 535 00d8 003000E3 		movw	r3, #:lower16:.LANCHOR10
 536 00dc 003040E3 		movt	r3, #:upper16:.LANCHOR10
 537 00e0 003093E5 		ldr	r3, [r3]
 538 00e4 2C2093E5 		ldr	r2, [r3, #44]
 539 00e8 2C3094E5 		ldr	r3, [r4, #44]
 540 00ec 030052E1 		cmp	r2, r3
 541 00f0 1080BD28 		popcs	{r4, pc}
1107:../src/FreeRTOS/tasks.c **** 		}
 542              		.loc 1 1107 0
 543              		.syntax divided
 544              	@ 1107 "../src/FreeRTOS/tasks.c" 1
 545 00f4 000000EF 		SWI 0
 546              	@ 0 "" 2
 547              		.arm
 548              		.syntax unified
 549 00f8 1080BDE8 		pop	{r4, pc}
 550              	.L46:
1049:../src/FreeRTOS/tasks.c **** 
 551              		.loc 1 1049 0
 552 00fc 003000E3 		movw	r3, #:lower16:.LANCHOR10
 553 0100 003040E3 		movt	r3, #:upper16:.LANCHOR10
 554 0104 004083E5 		str	r4, [r3]
1051:../src/FreeRTOS/tasks.c **** 			{
 555              		.loc 1 1051 0
 556 0108 003000E3 		movw	r3, #:lower16:.LANCHOR9
 557 010c 003040E3 		movt	r3, #:upper16:.LANCHOR9
 558 0110 003093E5 		ldr	r3, [r3]
 559 0114 010053E3 		cmp	r3, #1
 560 0118 D3FFFF1A 		bne	.L42
1056:../src/FreeRTOS/tasks.c **** 			}
 561              		.loc 1 1056 0
 562 011c FEFFFFEB 		bl	prvInitialiseTaskLists
 563              	.LVL55:
 564 0120 D1FFFFEA 		b	.L42
 565              		.cfi_endproc
 566              	.LFE3:
 568              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 569              		.align	2
 570              		.syntax unified
 571              		.arm
 572              		.fpu neon
 574              	prvCheckTasksWaitingTermination:
 575              	.LFB44:
3540:../src/FreeRTOS/tasks.c **** 
 576              		.loc 1 3540 0
 577              		.cfi_startproc
 578              		@ args = 0, pretend = 0, frame = 0
 579              		@ frame_needed = 0, uses_anonymous_args = 0
 580 0000 10402DE9 		push	{r4, lr}
 581              		.cfi_def_cfa_offset 8
 582              		.cfi_offset 4, -8
 583              		.cfi_offset 14, -4
 584              	.LBB2:
3550:../src/FreeRTOS/tasks.c **** 		{
 585              		.loc 1 3550 0
 586 0004 130000EA 		b	.L48
 587              	.L49:
3552:../src/FreeRTOS/tasks.c **** 			{
 588              		.loc 1 3552 0
 589 0008 FEFFFFEB 		bl	vPortEnterCritical
 590              	.LVL56:
3554:../src/FreeRTOS/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 591              		.loc 1 3554 0
 592 000c 003000E3 		movw	r3, #:lower16:.LANCHOR7
 593 0010 003040E3 		movt	r3, #:upper16:.LANCHOR7
 594 0014 0C3093E5 		ldr	r3, [r3, #12]
 595 0018 0C4093E5 		ldr	r4, [r3, #12]
 596              	.LVL57:
3555:../src/FreeRTOS/tasks.c **** 				--uxCurrentNumberOfTasks;
 597              		.loc 1 3555 0
 598 001c 040084E2 		add	r0, r4, #4
 599 0020 FEFFFFEB 		bl	uxListRemove
 600              	.LVL58:
3556:../src/FreeRTOS/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
 601              		.loc 1 3556 0
 602 0024 003000E3 		movw	r3, #:lower16:.LANCHOR9
 603 0028 003040E3 		movt	r3, #:upper16:.LANCHOR9
 604 002c 002093E5 		ldr	r2, [r3]
 605 0030 012042E2 		sub	r2, r2, #1
 606 0034 002083E5 		str	r2, [r3]
3557:../src/FreeRTOS/tasks.c **** 			}
 607              		.loc 1 3557 0
 608 0038 003000E3 		movw	r3, #:lower16:.LANCHOR14
 609 003c 003040E3 		movt	r3, #:upper16:.LANCHOR14
 610 0040 002093E5 		ldr	r2, [r3]
 611 0044 012042E2 		sub	r2, r2, #1
 612 0048 002083E5 		str	r2, [r3]
3559:../src/FreeRTOS/tasks.c **** 
 613              		.loc 1 3559 0
 614 004c FEFFFFEB 		bl	vPortExitCritical
 615              	.LVL59:
3561:../src/FreeRTOS/tasks.c **** 		}
 616              		.loc 1 3561 0
 617 0050 0400A0E1 		mov	r0, r4
 618 0054 FEFFFFEB 		bl	prvDeleteTCB
 619              	.LVL60:
 620              	.L48:
3550:../src/FreeRTOS/tasks.c **** 		{
 621              		.loc 1 3550 0
 622 0058 003000E3 		movw	r3, #:lower16:.LANCHOR14
 623 005c 003040E3 		movt	r3, #:upper16:.LANCHOR14
 624 0060 003093E5 		ldr	r3, [r3]
 625 0064 000053E3 		cmp	r3, #0
 626 0068 E6FFFF1A 		bne	.L49
 627              	.LBE2:
3565:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 628              		.loc 1 3565 0
 629 006c 1080BDE8 		pop	{r4, pc}
 630              		.cfi_endproc
 631              	.LFE44:
 633              		.section	.text.prvIdleTask,"ax",%progbits
 634              		.align	2
 635              		.syntax unified
 636              		.arm
 637              		.fpu neon
 639              	prvIdleTask:
 640              	.LFB40:
3296:../src/FreeRTOS/tasks.c **** 	/* Stop warnings. */
 641              		.loc 1 3296 0
 642              		.cfi_startproc
 643              		@ Volatile: function does not return.
 644              		@ args = 0, pretend = 0, frame = 0
 645              		@ frame_needed = 0, uses_anonymous_args = 0
 646              	.LVL61:
 647 0000 10402DE9 		push	{r4, lr}
 648              		.cfi_def_cfa_offset 8
 649              		.cfi_offset 4, -8
 650              		.cfi_offset 14, -4
 651              	.LVL62:
 652              	.L52:
3312:../src/FreeRTOS/tasks.c **** 
 653              		.loc 1 3312 0
 654 0004 FEFFFFEB 		bl	prvCheckTasksWaitingTermination
 655              	.LVL63:
3335:../src/FreeRTOS/tasks.c **** 			{
 656              		.loc 1 3335 0
 657 0008 003000E3 		movw	r3, #:lower16:.LANCHOR4
 658 000c 003040E3 		movt	r3, #:upper16:.LANCHOR4
 659 0010 003093E5 		ldr	r3, [r3]
 660 0014 010053E3 		cmp	r3, #1
 661 0018 F9FFFF9A 		bls	.L52
3337:../src/FreeRTOS/tasks.c **** 			}
 662              		.loc 1 3337 0
 663              		.syntax divided
 664              	@ 3337 "../src/FreeRTOS/tasks.c" 1
 665 001c 000000EF 		SWI 0
 666              	@ 0 "" 2
 667              		.arm
 668              		.syntax unified
 669 0020 F7FFFFEA 		b	.L52
 670              		.cfi_endproc
 671              	.LFE40:
 673              		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 674              		.align	2
 675              		.syntax unified
 676              		.arm
 677              		.fpu neon
 679              	prvAddCurrentTaskToDelayedList:
 680              	.LFB67:
3821:../src/FreeRTOS/tasks.c **** 	}
3822:../src/FreeRTOS/tasks.c **** }
3823:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3824:../src/FreeRTOS/tasks.c **** 
3825:../src/FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3826:../src/FreeRTOS/tasks.c **** 
3827:../src/FreeRTOS/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3828:../src/FreeRTOS/tasks.c **** 	{
3829:../src/FreeRTOS/tasks.c **** 	TaskHandle_t xReturn;
3830:../src/FreeRTOS/tasks.c **** 
3831:../src/FreeRTOS/tasks.c **** 		/* A critical section is not required as this is not called from
3832:../src/FreeRTOS/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3833:../src/FreeRTOS/tasks.c **** 		individual execution thread. */
3834:../src/FreeRTOS/tasks.c **** 		xReturn = pxCurrentTCB;
3835:../src/FreeRTOS/tasks.c **** 
3836:../src/FreeRTOS/tasks.c **** 		return xReturn;
3837:../src/FreeRTOS/tasks.c **** 	}
3838:../src/FreeRTOS/tasks.c **** 
3839:../src/FreeRTOS/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3840:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3841:../src/FreeRTOS/tasks.c **** 
3842:../src/FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3843:../src/FreeRTOS/tasks.c **** 
3844:../src/FreeRTOS/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3845:../src/FreeRTOS/tasks.c **** 	{
3846:../src/FreeRTOS/tasks.c **** 	BaseType_t xReturn;
3847:../src/FreeRTOS/tasks.c **** 
3848:../src/FreeRTOS/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
3849:../src/FreeRTOS/tasks.c **** 		{
3850:../src/FreeRTOS/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
3851:../src/FreeRTOS/tasks.c **** 		}
3852:../src/FreeRTOS/tasks.c **** 		else
3853:../src/FreeRTOS/tasks.c **** 		{
3854:../src/FreeRTOS/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3855:../src/FreeRTOS/tasks.c **** 			{
3856:../src/FreeRTOS/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
3857:../src/FreeRTOS/tasks.c **** 			}
3858:../src/FreeRTOS/tasks.c **** 			else
3859:../src/FreeRTOS/tasks.c **** 			{
3860:../src/FreeRTOS/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
3861:../src/FreeRTOS/tasks.c **** 			}
3862:../src/FreeRTOS/tasks.c **** 		}
3863:../src/FreeRTOS/tasks.c **** 
3864:../src/FreeRTOS/tasks.c **** 		return xReturn;
3865:../src/FreeRTOS/tasks.c **** 	}
3866:../src/FreeRTOS/tasks.c **** 
3867:../src/FreeRTOS/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3868:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3869:../src/FreeRTOS/tasks.c **** 
3870:../src/FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3871:../src/FreeRTOS/tasks.c **** 
3872:../src/FreeRTOS/tasks.c **** 	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3873:../src/FreeRTOS/tasks.c **** 	{
3874:../src/FreeRTOS/tasks.c **** 	TCB_t * const pxMutexHolderTCB = ( TCB_t * ) pxMutexHolder;
3875:../src/FreeRTOS/tasks.c **** 	BaseType_t xReturn = pdFALSE;
3876:../src/FreeRTOS/tasks.c **** 
3877:../src/FreeRTOS/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
3878:../src/FreeRTOS/tasks.c **** 		locked then the mutex holder might now be NULL.  _RB_ Is this still
3879:../src/FreeRTOS/tasks.c **** 		needed as interrupts can no longer use mutexes? */
3880:../src/FreeRTOS/tasks.c **** 		if( pxMutexHolder != NULL )
3881:../src/FreeRTOS/tasks.c **** 		{
3882:../src/FreeRTOS/tasks.c **** 			/* If the holder of the mutex has a priority below the priority of
3883:../src/FreeRTOS/tasks.c **** 			the task attempting to obtain the mutex then it will temporarily
3884:../src/FreeRTOS/tasks.c **** 			inherit the priority of the task attempting to obtain the mutex. */
3885:../src/FreeRTOS/tasks.c **** 			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
3886:../src/FreeRTOS/tasks.c **** 			{
3887:../src/FreeRTOS/tasks.c **** 				/* Adjust the mutex holder state to account for its new
3888:../src/FreeRTOS/tasks.c **** 				priority.  Only reset the event list item value if the value is
3889:../src/FreeRTOS/tasks.c **** 				not being used for anything else. */
3890:../src/FreeRTOS/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VA
3891:../src/FreeRTOS/tasks.c **** 				{
3892:../src/FreeRTOS/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIOR
3893:../src/FreeRTOS/tasks.c **** 				}
3894:../src/FreeRTOS/tasks.c **** 				else
3895:../src/FreeRTOS/tasks.c **** 				{
3896:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3897:../src/FreeRTOS/tasks.c **** 				}
3898:../src/FreeRTOS/tasks.c **** 
3899:../src/FreeRTOS/tasks.c **** 				/* If the task being modified is in the ready state it will need
3900:../src/FreeRTOS/tasks.c **** 				to be moved into a new list. */
3901:../src/FreeRTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutex
3902:../src/FreeRTOS/tasks.c **** 				{
3903:../src/FreeRTOS/tasks.c **** 					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3904:../src/FreeRTOS/tasks.c **** 					{
3905:../src/FreeRTOS/tasks.c **** 						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
3906:../src/FreeRTOS/tasks.c **** 					}
3907:../src/FreeRTOS/tasks.c **** 					else
3908:../src/FreeRTOS/tasks.c **** 					{
3909:../src/FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3910:../src/FreeRTOS/tasks.c **** 					}
3911:../src/FreeRTOS/tasks.c **** 
3912:../src/FreeRTOS/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
3913:../src/FreeRTOS/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
3914:../src/FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxMutexHolderTCB );
3915:../src/FreeRTOS/tasks.c **** 				}
3916:../src/FreeRTOS/tasks.c **** 				else
3917:../src/FreeRTOS/tasks.c **** 				{
3918:../src/FreeRTOS/tasks.c **** 					/* Just inherit the priority. */
3919:../src/FreeRTOS/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
3920:../src/FreeRTOS/tasks.c **** 				}
3921:../src/FreeRTOS/tasks.c **** 
3922:../src/FreeRTOS/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
3923:../src/FreeRTOS/tasks.c **** 
3924:../src/FreeRTOS/tasks.c **** 				/* Inheritance occurred. */
3925:../src/FreeRTOS/tasks.c **** 				xReturn = pdTRUE;
3926:../src/FreeRTOS/tasks.c **** 			}
3927:../src/FreeRTOS/tasks.c **** 			else
3928:../src/FreeRTOS/tasks.c **** 			{
3929:../src/FreeRTOS/tasks.c **** 				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
3930:../src/FreeRTOS/tasks.c **** 				{
3931:../src/FreeRTOS/tasks.c **** 					/* The base priority of the mutex holder is lower than the
3932:../src/FreeRTOS/tasks.c **** 					priority of the task attempting to take the mutex, but the
3933:../src/FreeRTOS/tasks.c **** 					current priority of the mutex holder is not lower than the
3934:../src/FreeRTOS/tasks.c **** 					priority of the task attempting to take the mutex.
3935:../src/FreeRTOS/tasks.c **** 					Therefore the mutex holder must have already inherited a
3936:../src/FreeRTOS/tasks.c **** 					priority, but inheritance would have occurred if that had
3937:../src/FreeRTOS/tasks.c **** 					not been the case. */
3938:../src/FreeRTOS/tasks.c **** 					xReturn = pdTRUE;
3939:../src/FreeRTOS/tasks.c **** 				}
3940:../src/FreeRTOS/tasks.c **** 				else
3941:../src/FreeRTOS/tasks.c **** 				{
3942:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3943:../src/FreeRTOS/tasks.c **** 				}
3944:../src/FreeRTOS/tasks.c **** 			}
3945:../src/FreeRTOS/tasks.c **** 		}
3946:../src/FreeRTOS/tasks.c **** 		else
3947:../src/FreeRTOS/tasks.c **** 		{
3948:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3949:../src/FreeRTOS/tasks.c **** 		}
3950:../src/FreeRTOS/tasks.c **** 
3951:../src/FreeRTOS/tasks.c **** 		return xReturn;
3952:../src/FreeRTOS/tasks.c **** 	}
3953:../src/FreeRTOS/tasks.c **** 
3954:../src/FreeRTOS/tasks.c **** #endif /* configUSE_MUTEXES */
3955:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3956:../src/FreeRTOS/tasks.c **** 
3957:../src/FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3958:../src/FreeRTOS/tasks.c **** 
3959:../src/FreeRTOS/tasks.c **** 	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3960:../src/FreeRTOS/tasks.c **** 	{
3961:../src/FreeRTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
3962:../src/FreeRTOS/tasks.c **** 	BaseType_t xReturn = pdFALSE;
3963:../src/FreeRTOS/tasks.c **** 
3964:../src/FreeRTOS/tasks.c **** 		if( pxMutexHolder != NULL )
3965:../src/FreeRTOS/tasks.c **** 		{
3966:../src/FreeRTOS/tasks.c **** 			/* A task can only have an inherited priority if it holds the mutex.
3967:../src/FreeRTOS/tasks.c **** 			If the mutex is held by a task then it cannot be given from an
3968:../src/FreeRTOS/tasks.c **** 			interrupt, and if a mutex is given by the holding task then it must
3969:../src/FreeRTOS/tasks.c **** 			be the running state task. */
3970:../src/FreeRTOS/tasks.c **** 			configASSERT( pxTCB == pxCurrentTCB );
3971:../src/FreeRTOS/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
3972:../src/FreeRTOS/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
3973:../src/FreeRTOS/tasks.c **** 
3974:../src/FreeRTOS/tasks.c **** 			/* Has the holder of the mutex inherited the priority of another
3975:../src/FreeRTOS/tasks.c **** 			task? */
3976:../src/FreeRTOS/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
3977:../src/FreeRTOS/tasks.c **** 			{
3978:../src/FreeRTOS/tasks.c **** 				/* Only disinherit if no other mutexes are held. */
3979:../src/FreeRTOS/tasks.c **** 				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
3980:../src/FreeRTOS/tasks.c **** 				{
3981:../src/FreeRTOS/tasks.c **** 					/* A task can only have an inherited priority if it holds
3982:../src/FreeRTOS/tasks.c **** 					the mutex.  If the mutex is held by a task then it cannot be
3983:../src/FreeRTOS/tasks.c **** 					given from an interrupt, and if a mutex is given by the
3984:../src/FreeRTOS/tasks.c **** 					holding task then it must be the running state task.  Remove
3985:../src/FreeRTOS/tasks.c **** 					the holding task from the ready list. */
3986:../src/FreeRTOS/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3987:../src/FreeRTOS/tasks.c **** 					{
3988:../src/FreeRTOS/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3989:../src/FreeRTOS/tasks.c **** 					}
3990:../src/FreeRTOS/tasks.c **** 					else
3991:../src/FreeRTOS/tasks.c **** 					{
3992:../src/FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3993:../src/FreeRTOS/tasks.c **** 					}
3994:../src/FreeRTOS/tasks.c **** 
3995:../src/FreeRTOS/tasks.c **** 					/* Disinherit the priority before adding the task into the
3996:../src/FreeRTOS/tasks.c **** 					new	ready list. */
3997:../src/FreeRTOS/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3998:../src/FreeRTOS/tasks.c **** 					pxTCB->uxPriority = pxTCB->uxBasePriority;
3999:../src/FreeRTOS/tasks.c **** 
4000:../src/FreeRTOS/tasks.c **** 					/* Reset the event list item value.  It cannot be in use for
4001:../src/FreeRTOS/tasks.c **** 					any other purpose if this task is running, and it must be
4002:../src/FreeRTOS/tasks.c **** 					running to give back the mutex. */
4003:../src/FreeRTOS/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
4004:../src/FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4005:../src/FreeRTOS/tasks.c **** 
4006:../src/FreeRTOS/tasks.c **** 					/* Return true to indicate that a context switch is required.
4007:../src/FreeRTOS/tasks.c **** 					This is only actually required in the corner case whereby
4008:../src/FreeRTOS/tasks.c **** 					multiple mutexes were held and the mutexes were given back
4009:../src/FreeRTOS/tasks.c **** 					in an order different to that in which they were taken.
4010:../src/FreeRTOS/tasks.c **** 					If a context switch did not occur when the first mutex was
4011:../src/FreeRTOS/tasks.c **** 					returned, even if a task was waiting on it, then a context
4012:../src/FreeRTOS/tasks.c **** 					switch should occur when the last mutex is returned whether
4013:../src/FreeRTOS/tasks.c **** 					a task is waiting on it or not. */
4014:../src/FreeRTOS/tasks.c **** 					xReturn = pdTRUE;
4015:../src/FreeRTOS/tasks.c **** 				}
4016:../src/FreeRTOS/tasks.c **** 				else
4017:../src/FreeRTOS/tasks.c **** 				{
4018:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4019:../src/FreeRTOS/tasks.c **** 				}
4020:../src/FreeRTOS/tasks.c **** 			}
4021:../src/FreeRTOS/tasks.c **** 			else
4022:../src/FreeRTOS/tasks.c **** 			{
4023:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4024:../src/FreeRTOS/tasks.c **** 			}
4025:../src/FreeRTOS/tasks.c **** 		}
4026:../src/FreeRTOS/tasks.c **** 		else
4027:../src/FreeRTOS/tasks.c **** 		{
4028:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4029:../src/FreeRTOS/tasks.c **** 		}
4030:../src/FreeRTOS/tasks.c **** 
4031:../src/FreeRTOS/tasks.c **** 		return xReturn;
4032:../src/FreeRTOS/tasks.c **** 	}
4033:../src/FreeRTOS/tasks.c **** 
4034:../src/FreeRTOS/tasks.c **** #endif /* configUSE_MUTEXES */
4035:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4036:../src/FreeRTOS/tasks.c **** 
4037:../src/FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4038:../src/FreeRTOS/tasks.c **** 
4039:../src/FreeRTOS/tasks.c **** 	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestP
4040:../src/FreeRTOS/tasks.c **** 	{
4041:../src/FreeRTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
4042:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
4043:../src/FreeRTOS/tasks.c **** 	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
4044:../src/FreeRTOS/tasks.c **** 
4045:../src/FreeRTOS/tasks.c **** 		if( pxMutexHolder != NULL )
4046:../src/FreeRTOS/tasks.c **** 		{
4047:../src/FreeRTOS/tasks.c **** 			/* If pxMutexHolder is not NULL then the holder must hold at least
4048:../src/FreeRTOS/tasks.c **** 			one mutex. */
4049:../src/FreeRTOS/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
4050:../src/FreeRTOS/tasks.c **** 
4051:../src/FreeRTOS/tasks.c **** 			/* Determine the priority to which the priority of the task that
4052:../src/FreeRTOS/tasks.c **** 			holds the mutex should be set.  This will be the greater of the
4053:../src/FreeRTOS/tasks.c **** 			holding task's base priority and the priority of the highest
4054:../src/FreeRTOS/tasks.c **** 			priority task that is waiting to obtain the mutex. */
4055:../src/FreeRTOS/tasks.c **** 			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
4056:../src/FreeRTOS/tasks.c **** 			{
4057:../src/FreeRTOS/tasks.c **** 				uxPriorityToUse = uxHighestPriorityWaitingTask;
4058:../src/FreeRTOS/tasks.c **** 			}
4059:../src/FreeRTOS/tasks.c **** 			else
4060:../src/FreeRTOS/tasks.c **** 			{
4061:../src/FreeRTOS/tasks.c **** 				uxPriorityToUse = pxTCB->uxBasePriority;
4062:../src/FreeRTOS/tasks.c **** 			}
4063:../src/FreeRTOS/tasks.c **** 
4064:../src/FreeRTOS/tasks.c **** 			/* Does the priority need to change? */
4065:../src/FreeRTOS/tasks.c **** 			if( pxTCB->uxPriority != uxPriorityToUse )
4066:../src/FreeRTOS/tasks.c **** 			{
4067:../src/FreeRTOS/tasks.c **** 				/* Only disinherit if no other mutexes are held.  This is a
4068:../src/FreeRTOS/tasks.c **** 				simplification in the priority inheritance implementation.  If
4069:../src/FreeRTOS/tasks.c **** 				the task that holds the mutex is also holding other mutexes then
4070:../src/FreeRTOS/tasks.c **** 				the other mutexes may have caused the priority inheritance. */
4071:../src/FreeRTOS/tasks.c **** 				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
4072:../src/FreeRTOS/tasks.c **** 				{
4073:../src/FreeRTOS/tasks.c **** 					/* If a task has timed out because it already holds the
4074:../src/FreeRTOS/tasks.c **** 					mutex it was trying to obtain then it cannot of inherited
4075:../src/FreeRTOS/tasks.c **** 					its own priority. */
4076:../src/FreeRTOS/tasks.c **** 					configASSERT( pxTCB != pxCurrentTCB );
4077:../src/FreeRTOS/tasks.c **** 
4078:../src/FreeRTOS/tasks.c **** 					/* Disinherit the priority, remembering the previous
4079:../src/FreeRTOS/tasks.c **** 					priority to facilitate determining the subject task's
4080:../src/FreeRTOS/tasks.c **** 					state. */
4081:../src/FreeRTOS/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
4082:../src/FreeRTOS/tasks.c **** 					uxPriorityUsedOnEntry = pxTCB->uxPriority;
4083:../src/FreeRTOS/tasks.c **** 					pxTCB->uxPriority = uxPriorityToUse;
4084:../src/FreeRTOS/tasks.c **** 
4085:../src/FreeRTOS/tasks.c **** 					/* Only reset the event list item value if the value is not
4086:../src/FreeRTOS/tasks.c **** 					being used for anything else. */
4087:../src/FreeRTOS/tasks.c **** 					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE
4088:../src/FreeRTOS/tasks.c **** 					{
4089:../src/FreeRTOS/tasks.c **** 						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( 
4090:../src/FreeRTOS/tasks.c **** 					}
4091:../src/FreeRTOS/tasks.c **** 					else
4092:../src/FreeRTOS/tasks.c **** 					{
4093:../src/FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4094:../src/FreeRTOS/tasks.c **** 					}
4095:../src/FreeRTOS/tasks.c **** 
4096:../src/FreeRTOS/tasks.c **** 					/* If the running task is not the task that holds the mutex
4097:../src/FreeRTOS/tasks.c **** 					then the task that holds the mutex could be in either the
4098:../src/FreeRTOS/tasks.c **** 					Ready, Blocked or Suspended states.  Only remove the task
4099:../src/FreeRTOS/tasks.c **** 					from its current state list if it is in the Ready state as
4100:../src/FreeRTOS/tasks.c **** 					the task's priority is going to change and there is one
4101:../src/FreeRTOS/tasks.c **** 					Ready list per priority. */
4102:../src/FreeRTOS/tasks.c **** 					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xState
4103:../src/FreeRTOS/tasks.c **** 					{
4104:../src/FreeRTOS/tasks.c **** 						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4105:../src/FreeRTOS/tasks.c **** 						{
4106:../src/FreeRTOS/tasks.c **** 							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
4107:../src/FreeRTOS/tasks.c **** 						}
4108:../src/FreeRTOS/tasks.c **** 						else
4109:../src/FreeRTOS/tasks.c **** 						{
4110:../src/FreeRTOS/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
4111:../src/FreeRTOS/tasks.c **** 						}
4112:../src/FreeRTOS/tasks.c **** 
4113:../src/FreeRTOS/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
4114:../src/FreeRTOS/tasks.c **** 					}
4115:../src/FreeRTOS/tasks.c **** 					else
4116:../src/FreeRTOS/tasks.c **** 					{
4117:../src/FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4118:../src/FreeRTOS/tasks.c **** 					}
4119:../src/FreeRTOS/tasks.c **** 				}
4120:../src/FreeRTOS/tasks.c **** 				else
4121:../src/FreeRTOS/tasks.c **** 				{
4122:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4123:../src/FreeRTOS/tasks.c **** 				}
4124:../src/FreeRTOS/tasks.c **** 			}
4125:../src/FreeRTOS/tasks.c **** 			else
4126:../src/FreeRTOS/tasks.c **** 			{
4127:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4128:../src/FreeRTOS/tasks.c **** 			}
4129:../src/FreeRTOS/tasks.c **** 		}
4130:../src/FreeRTOS/tasks.c **** 		else
4131:../src/FreeRTOS/tasks.c **** 		{
4132:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4133:../src/FreeRTOS/tasks.c **** 		}
4134:../src/FreeRTOS/tasks.c **** 	}
4135:../src/FreeRTOS/tasks.c **** 
4136:../src/FreeRTOS/tasks.c **** #endif /* configUSE_MUTEXES */
4137:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4138:../src/FreeRTOS/tasks.c **** 
4139:../src/FreeRTOS/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4140:../src/FreeRTOS/tasks.c **** 
4141:../src/FreeRTOS/tasks.c **** 	void vTaskEnterCritical( void )
4142:../src/FreeRTOS/tasks.c **** 	{
4143:../src/FreeRTOS/tasks.c **** 		portDISABLE_INTERRUPTS();
4144:../src/FreeRTOS/tasks.c **** 
4145:../src/FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4146:../src/FreeRTOS/tasks.c **** 		{
4147:../src/FreeRTOS/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
4148:../src/FreeRTOS/tasks.c **** 
4149:../src/FreeRTOS/tasks.c **** 			/* This is not the interrupt safe version of the enter critical
4150:../src/FreeRTOS/tasks.c **** 			function so	assert() if it is being called from an interrupt
4151:../src/FreeRTOS/tasks.c **** 			context.  Only API functions that end in "FromISR" can be used in an
4152:../src/FreeRTOS/tasks.c **** 			interrupt.  Only assert if the critical nesting count is 1 to
4153:../src/FreeRTOS/tasks.c **** 			protect against recursive calls if the assert function also uses a
4154:../src/FreeRTOS/tasks.c **** 			critical section. */
4155:../src/FreeRTOS/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting == 1 )
4156:../src/FreeRTOS/tasks.c **** 			{
4157:../src/FreeRTOS/tasks.c **** 				portASSERT_IF_IN_ISR();
4158:../src/FreeRTOS/tasks.c **** 			}
4159:../src/FreeRTOS/tasks.c **** 		}
4160:../src/FreeRTOS/tasks.c **** 		else
4161:../src/FreeRTOS/tasks.c **** 		{
4162:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4163:../src/FreeRTOS/tasks.c **** 		}
4164:../src/FreeRTOS/tasks.c **** 	}
4165:../src/FreeRTOS/tasks.c **** 
4166:../src/FreeRTOS/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4167:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4168:../src/FreeRTOS/tasks.c **** 
4169:../src/FreeRTOS/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4170:../src/FreeRTOS/tasks.c **** 
4171:../src/FreeRTOS/tasks.c **** 	void vTaskExitCritical( void )
4172:../src/FreeRTOS/tasks.c **** 	{
4173:../src/FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4174:../src/FreeRTOS/tasks.c **** 		{
4175:../src/FreeRTOS/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
4176:../src/FreeRTOS/tasks.c **** 			{
4177:../src/FreeRTOS/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
4178:../src/FreeRTOS/tasks.c **** 
4179:../src/FreeRTOS/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
4180:../src/FreeRTOS/tasks.c **** 				{
4181:../src/FreeRTOS/tasks.c **** 					portENABLE_INTERRUPTS();
4182:../src/FreeRTOS/tasks.c **** 				}
4183:../src/FreeRTOS/tasks.c **** 				else
4184:../src/FreeRTOS/tasks.c **** 				{
4185:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4186:../src/FreeRTOS/tasks.c **** 				}
4187:../src/FreeRTOS/tasks.c **** 			}
4188:../src/FreeRTOS/tasks.c **** 			else
4189:../src/FreeRTOS/tasks.c **** 			{
4190:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4191:../src/FreeRTOS/tasks.c **** 			}
4192:../src/FreeRTOS/tasks.c **** 		}
4193:../src/FreeRTOS/tasks.c **** 		else
4194:../src/FreeRTOS/tasks.c **** 		{
4195:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4196:../src/FreeRTOS/tasks.c **** 		}
4197:../src/FreeRTOS/tasks.c **** 	}
4198:../src/FreeRTOS/tasks.c **** 
4199:../src/FreeRTOS/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4200:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4201:../src/FreeRTOS/tasks.c **** 
4202:../src/FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4203:../src/FreeRTOS/tasks.c **** 
4204:../src/FreeRTOS/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
4205:../src/FreeRTOS/tasks.c **** 	{
4206:../src/FreeRTOS/tasks.c **** 	size_t x;
4207:../src/FreeRTOS/tasks.c **** 
4208:../src/FreeRTOS/tasks.c **** 		/* Start by copying the entire string. */
4209:../src/FreeRTOS/tasks.c **** 		strcpy( pcBuffer, pcTaskName );
4210:../src/FreeRTOS/tasks.c **** 
4211:../src/FreeRTOS/tasks.c **** 		/* Pad the end of the string with spaces to ensure columns line up when
4212:../src/FreeRTOS/tasks.c **** 		printed out. */
4213:../src/FreeRTOS/tasks.c **** 		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
4214:../src/FreeRTOS/tasks.c **** 		{
4215:../src/FreeRTOS/tasks.c **** 			pcBuffer[ x ] = ' ';
4216:../src/FreeRTOS/tasks.c **** 		}
4217:../src/FreeRTOS/tasks.c **** 
4218:../src/FreeRTOS/tasks.c **** 		/* Terminate. */
4219:../src/FreeRTOS/tasks.c **** 		pcBuffer[ x ] = 0x00;
4220:../src/FreeRTOS/tasks.c **** 
4221:../src/FreeRTOS/tasks.c **** 		/* Return the new end of string. */
4222:../src/FreeRTOS/tasks.c **** 		return &( pcBuffer[ x ] );
4223:../src/FreeRTOS/tasks.c **** 	}
4224:../src/FreeRTOS/tasks.c **** 
4225:../src/FreeRTOS/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
4226:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4227:../src/FreeRTOS/tasks.c **** 
4228:../src/FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( config
4229:../src/FreeRTOS/tasks.c **** 
4230:../src/FreeRTOS/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
4231:../src/FreeRTOS/tasks.c **** 	{
4232:../src/FreeRTOS/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4233:../src/FreeRTOS/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
4234:../src/FreeRTOS/tasks.c **** 	char cStatus;
4235:../src/FreeRTOS/tasks.c **** 
4236:../src/FreeRTOS/tasks.c **** 		/*
4237:../src/FreeRTOS/tasks.c **** 		 * PLEASE NOTE:
4238:../src/FreeRTOS/tasks.c **** 		 *
4239:../src/FreeRTOS/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4240:../src/FreeRTOS/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4241:../src/FreeRTOS/tasks.c **** 		 * scheduler.
4242:../src/FreeRTOS/tasks.c **** 		 *
4243:../src/FreeRTOS/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
4244:../src/FreeRTOS/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
4245:../src/FreeRTOS/tasks.c **** 		 * displays task names, states and stack usage.
4246:../src/FreeRTOS/tasks.c **** 		 *
4247:../src/FreeRTOS/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
4248:../src/FreeRTOS/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
4249:../src/FreeRTOS/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
4250:../src/FreeRTOS/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
4251:../src/FreeRTOS/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
4252:../src/FreeRTOS/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
4253:../src/FreeRTOS/tasks.c **** 		 * snprintf() implementation!).
4254:../src/FreeRTOS/tasks.c **** 		 *
4255:../src/FreeRTOS/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4256:../src/FreeRTOS/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4257:../src/FreeRTOS/tasks.c **** 		 * through a call to vTaskList().
4258:../src/FreeRTOS/tasks.c **** 		 */
4259:../src/FreeRTOS/tasks.c **** 
4260:../src/FreeRTOS/tasks.c **** 
4261:../src/FreeRTOS/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4262:../src/FreeRTOS/tasks.c **** 		*pcWriteBuffer = 0x00;
4263:../src/FreeRTOS/tasks.c **** 
4264:../src/FreeRTOS/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4265:../src/FreeRTOS/tasks.c **** 		function is executing. */
4266:../src/FreeRTOS/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4267:../src/FreeRTOS/tasks.c **** 
4268:../src/FreeRTOS/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  if
4269:../src/FreeRTOS/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4270:../src/FreeRTOS/tasks.c **** 		equate to NULL. */
4271:../src/FreeRTOS/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
4272:../src/FreeRTOS/tasks.c **** 
4273:../src/FreeRTOS/tasks.c **** 		if( pxTaskStatusArray != NULL )
4274:../src/FreeRTOS/tasks.c **** 		{
4275:../src/FreeRTOS/tasks.c **** 			/* Generate the (binary) data. */
4276:../src/FreeRTOS/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
4277:../src/FreeRTOS/tasks.c **** 
4278:../src/FreeRTOS/tasks.c **** 			/* Create a human readable table from the binary data. */
4279:../src/FreeRTOS/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
4280:../src/FreeRTOS/tasks.c **** 			{
4281:../src/FreeRTOS/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
4282:../src/FreeRTOS/tasks.c **** 				{
4283:../src/FreeRTOS/tasks.c **** 					case eRunning:		cStatus = tskRUNNING_CHAR;
4284:../src/FreeRTOS/tasks.c **** 										break;
4285:../src/FreeRTOS/tasks.c **** 
4286:../src/FreeRTOS/tasks.c **** 					case eReady:		cStatus = tskREADY_CHAR;
4287:../src/FreeRTOS/tasks.c **** 										break;
4288:../src/FreeRTOS/tasks.c **** 
4289:../src/FreeRTOS/tasks.c **** 					case eBlocked:		cStatus = tskBLOCKED_CHAR;
4290:../src/FreeRTOS/tasks.c **** 										break;
4291:../src/FreeRTOS/tasks.c **** 
4292:../src/FreeRTOS/tasks.c **** 					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
4293:../src/FreeRTOS/tasks.c **** 										break;
4294:../src/FreeRTOS/tasks.c **** 
4295:../src/FreeRTOS/tasks.c **** 					case eDeleted:		cStatus = tskDELETED_CHAR;
4296:../src/FreeRTOS/tasks.c **** 										break;
4297:../src/FreeRTOS/tasks.c **** 
4298:../src/FreeRTOS/tasks.c **** 					default:			/* Should not get here, but it is included
4299:../src/FreeRTOS/tasks.c **** 										to prevent static checking errors. */
4300:../src/FreeRTOS/tasks.c **** 										cStatus = 0x00;
4301:../src/FreeRTOS/tasks.c **** 										break;
4302:../src/FreeRTOS/tasks.c **** 				}
4303:../src/FreeRTOS/tasks.c **** 
4304:../src/FreeRTOS/tasks.c **** 				/* Write the task name to the string, padding with spaces so it
4305:../src/FreeRTOS/tasks.c **** 				can be printed in tabular form more easily. */
4306:../src/FreeRTOS/tasks.c **** 				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4307:../src/FreeRTOS/tasks.c **** 
4308:../src/FreeRTOS/tasks.c **** 				/* Write the rest of the string. */
4309:../src/FreeRTOS/tasks.c **** 				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x 
4310:../src/FreeRTOS/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer );
4311:../src/FreeRTOS/tasks.c **** 			}
4312:../src/FreeRTOS/tasks.c **** 
4313:../src/FreeRTOS/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4314:../src/FreeRTOS/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4315:../src/FreeRTOS/tasks.c **** 			vPortFree( pxTaskStatusArray );
4316:../src/FreeRTOS/tasks.c **** 		}
4317:../src/FreeRTOS/tasks.c **** 		else
4318:../src/FreeRTOS/tasks.c **** 		{
4319:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4320:../src/FreeRTOS/tasks.c **** 		}
4321:../src/FreeRTOS/tasks.c **** 	}
4322:../src/FreeRTOS/tasks.c **** 
4323:../src/FreeRTOS/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( 
4324:../src/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
4325:../src/FreeRTOS/tasks.c **** 
4326:../src/FreeRTOS/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( c
4327:../src/FreeRTOS/tasks.c **** 
4328:../src/FreeRTOS/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
4329:../src/FreeRTOS/tasks.c **** 	{
4330:../src/FreeRTOS/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4331:../src/FreeRTOS/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
4332:../src/FreeRTOS/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
4333:../src/FreeRTOS/tasks.c **** 
4334:../src/FreeRTOS/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
4335:../src/FreeRTOS/tasks.c **** 		{
4336:../src/FreeRTOS/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
4337:../src/FreeRTOS/tasks.c **** 		}
4338:../src/FreeRTOS/tasks.c **** 		#endif
4339:../src/FreeRTOS/tasks.c **** 
4340:../src/FreeRTOS/tasks.c **** 		/*
4341:../src/FreeRTOS/tasks.c **** 		 * PLEASE NOTE:
4342:../src/FreeRTOS/tasks.c **** 		 *
4343:../src/FreeRTOS/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4344:../src/FreeRTOS/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4345:../src/FreeRTOS/tasks.c **** 		 * scheduler.
4346:../src/FreeRTOS/tasks.c **** 		 *
4347:../src/FreeRTOS/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4348:../src/FreeRTOS/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
4349:../src/FreeRTOS/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
4350:../src/FreeRTOS/tasks.c **** 		 * in both absolute and percentage terms.
4351:../src/FreeRTOS/tasks.c **** 		 *
4352:../src/FreeRTOS/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4353:../src/FreeRTOS/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
4354:../src/FreeRTOS/tasks.c **** 		 * provide different results on different platforms.  An alternative,
4355:../src/FreeRTOS/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
4356:../src/FreeRTOS/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4357:../src/FreeRTOS/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4358:../src/FreeRTOS/tasks.c **** 		 * a full snprintf() implementation!).
4359:../src/FreeRTOS/tasks.c **** 		 *
4360:../src/FreeRTOS/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4361:../src/FreeRTOS/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4362:../src/FreeRTOS/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
4363:../src/FreeRTOS/tasks.c **** 		 */
4364:../src/FreeRTOS/tasks.c **** 
4365:../src/FreeRTOS/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4366:../src/FreeRTOS/tasks.c **** 		*pcWriteBuffer = 0x00;
4367:../src/FreeRTOS/tasks.c **** 
4368:../src/FreeRTOS/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4369:../src/FreeRTOS/tasks.c **** 		function is executing. */
4370:../src/FreeRTOS/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4371:../src/FreeRTOS/tasks.c **** 
4372:../src/FreeRTOS/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  If
4373:../src/FreeRTOS/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4374:../src/FreeRTOS/tasks.c **** 		equate to NULL. */
4375:../src/FreeRTOS/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
4376:../src/FreeRTOS/tasks.c **** 
4377:../src/FreeRTOS/tasks.c **** 		if( pxTaskStatusArray != NULL )
4378:../src/FreeRTOS/tasks.c **** 		{
4379:../src/FreeRTOS/tasks.c **** 			/* Generate the (binary) data. */
4380:../src/FreeRTOS/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
4381:../src/FreeRTOS/tasks.c **** 
4382:../src/FreeRTOS/tasks.c **** 			/* For percentage calculations. */
4383:../src/FreeRTOS/tasks.c **** 			ulTotalTime /= 100UL;
4384:../src/FreeRTOS/tasks.c **** 
4385:../src/FreeRTOS/tasks.c **** 			/* Avoid divide by zero errors. */
4386:../src/FreeRTOS/tasks.c **** 			if( ulTotalTime > 0 )
4387:../src/FreeRTOS/tasks.c **** 			{
4388:../src/FreeRTOS/tasks.c **** 				/* Create a human readable table from the binary data. */
4389:../src/FreeRTOS/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
4390:../src/FreeRTOS/tasks.c **** 				{
4391:../src/FreeRTOS/tasks.c **** 					/* What percentage of the total run time has the task used?
4392:../src/FreeRTOS/tasks.c **** 					This will always be rounded down to the nearest integer.
4393:../src/FreeRTOS/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
4394:../src/FreeRTOS/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4395:../src/FreeRTOS/tasks.c **** 
4396:../src/FreeRTOS/tasks.c **** 					/* Write the task name to the string, padding with
4397:../src/FreeRTOS/tasks.c **** 					spaces so it can be printed in tabular form more
4398:../src/FreeRTOS/tasks.c **** 					easily. */
4399:../src/FreeRTOS/tasks.c **** 					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4400:../src/FreeRTOS/tasks.c **** 
4401:../src/FreeRTOS/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
4402:../src/FreeRTOS/tasks.c **** 					{
4403:../src/FreeRTOS/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4404:../src/FreeRTOS/tasks.c **** 						{
4405:../src/FreeRTOS/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulSta
4406:../src/FreeRTOS/tasks.c **** 						}
4407:../src/FreeRTOS/tasks.c **** 						#else
4408:../src/FreeRTOS/tasks.c **** 						{
4409:../src/FreeRTOS/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4410:../src/FreeRTOS/tasks.c **** 							printf() library can be used. */
4411:../src/FreeRTOS/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4412:../src/FreeRTOS/tasks.c **** 						}
4413:../src/FreeRTOS/tasks.c **** 						#endif
4414:../src/FreeRTOS/tasks.c **** 					}
4415:../src/FreeRTOS/tasks.c **** 					else
4416:../src/FreeRTOS/tasks.c **** 					{
4417:../src/FreeRTOS/tasks.c **** 						/* If the percentage is zero here then the task has
4418:../src/FreeRTOS/tasks.c **** 						consumed less than 1% of the total run time. */
4419:../src/FreeRTOS/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4420:../src/FreeRTOS/tasks.c **** 						{
4421:../src/FreeRTOS/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
4422:../src/FreeRTOS/tasks.c **** 						}
4423:../src/FreeRTOS/tasks.c **** 						#else
4424:../src/FreeRTOS/tasks.c **** 						{
4425:../src/FreeRTOS/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4426:../src/FreeRTOS/tasks.c **** 							printf() library can be used. */
4427:../src/FreeRTOS/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4428:../src/FreeRTOS/tasks.c **** 						}
4429:../src/FreeRTOS/tasks.c **** 						#endif
4430:../src/FreeRTOS/tasks.c **** 					}
4431:../src/FreeRTOS/tasks.c **** 
4432:../src/FreeRTOS/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer );
4433:../src/FreeRTOS/tasks.c **** 				}
4434:../src/FreeRTOS/tasks.c **** 			}
4435:../src/FreeRTOS/tasks.c **** 			else
4436:../src/FreeRTOS/tasks.c **** 			{
4437:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4438:../src/FreeRTOS/tasks.c **** 			}
4439:../src/FreeRTOS/tasks.c **** 
4440:../src/FreeRTOS/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4441:../src/FreeRTOS/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4442:../src/FreeRTOS/tasks.c **** 			vPortFree( pxTaskStatusArray );
4443:../src/FreeRTOS/tasks.c **** 		}
4444:../src/FreeRTOS/tasks.c **** 		else
4445:../src/FreeRTOS/tasks.c **** 		{
4446:../src/FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4447:../src/FreeRTOS/tasks.c **** 		}
4448:../src/FreeRTOS/tasks.c **** 	}
4449:../src/FreeRTOS/tasks.c **** 
4450:../src/FreeRTOS/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
4451:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4452:../src/FreeRTOS/tasks.c **** 
4453:../src/FreeRTOS/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
4454:../src/FreeRTOS/tasks.c **** {
4455:../src/FreeRTOS/tasks.c **** TickType_t uxReturn;
4456:../src/FreeRTOS/tasks.c **** 
4457:../src/FreeRTOS/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
4458:../src/FreeRTOS/tasks.c **** 
4459:../src/FreeRTOS/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
4460:../src/FreeRTOS/tasks.c **** 	queues and semaphores. */
4461:../src/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
4462:../src/FreeRTOS/tasks.c **** 
4463:../src/FreeRTOS/tasks.c **** 	return uxReturn;
4464:../src/FreeRTOS/tasks.c **** }
4465:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4466:../src/FreeRTOS/tasks.c **** 
4467:../src/FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4468:../src/FreeRTOS/tasks.c **** 
4469:../src/FreeRTOS/tasks.c **** 	void *pvTaskIncrementMutexHeldCount( void )
4470:../src/FreeRTOS/tasks.c **** 	{
4471:../src/FreeRTOS/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
4472:../src/FreeRTOS/tasks.c **** 		then pxCurrentTCB will be NULL. */
4473:../src/FreeRTOS/tasks.c **** 		if( pxCurrentTCB != NULL )
4474:../src/FreeRTOS/tasks.c **** 		{
4475:../src/FreeRTOS/tasks.c **** 			( pxCurrentTCB->uxMutexesHeld )++;
4476:../src/FreeRTOS/tasks.c **** 		}
4477:../src/FreeRTOS/tasks.c **** 
4478:../src/FreeRTOS/tasks.c **** 		return pxCurrentTCB;
4479:../src/FreeRTOS/tasks.c **** 	}
4480:../src/FreeRTOS/tasks.c **** 
4481:../src/FreeRTOS/tasks.c **** #endif /* configUSE_MUTEXES */
4482:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4483:../src/FreeRTOS/tasks.c **** 
4484:../src/FreeRTOS/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4485:../src/FreeRTOS/tasks.c **** 
4486:../src/FreeRTOS/tasks.c **** 	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
4487:../src/FreeRTOS/tasks.c **** 	{
4488:../src/FreeRTOS/tasks.c **** 	uint32_t ulReturn;
4489:../src/FreeRTOS/tasks.c **** 
4490:../src/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
4491:../src/FreeRTOS/tasks.c **** 		{
4492:../src/FreeRTOS/tasks.c **** 			/* Only block if the notification count is not already non-zero. */
4493:../src/FreeRTOS/tasks.c **** 			if( pxCurrentTCB->ulNotifiedValue == 0UL )
4494:../src/FreeRTOS/tasks.c **** 			{
4495:../src/FreeRTOS/tasks.c **** 				/* Mark this task as waiting for a notification. */
4496:../src/FreeRTOS/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4497:../src/FreeRTOS/tasks.c **** 
4498:../src/FreeRTOS/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
4499:../src/FreeRTOS/tasks.c **** 				{
4500:../src/FreeRTOS/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4501:../src/FreeRTOS/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
4502:../src/FreeRTOS/tasks.c **** 
4503:../src/FreeRTOS/tasks.c **** 					/* All ports are written to allow a yield in a critical
4504:../src/FreeRTOS/tasks.c **** 					section (some will yield immediately, others wait until the
4505:../src/FreeRTOS/tasks.c **** 					critical section exits) - but it is not something that
4506:../src/FreeRTOS/tasks.c **** 					application code should ever do. */
4507:../src/FreeRTOS/tasks.c **** 					portYIELD_WITHIN_API();
4508:../src/FreeRTOS/tasks.c **** 				}
4509:../src/FreeRTOS/tasks.c **** 				else
4510:../src/FreeRTOS/tasks.c **** 				{
4511:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4512:../src/FreeRTOS/tasks.c **** 				}
4513:../src/FreeRTOS/tasks.c **** 			}
4514:../src/FreeRTOS/tasks.c **** 			else
4515:../src/FreeRTOS/tasks.c **** 			{
4516:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4517:../src/FreeRTOS/tasks.c **** 			}
4518:../src/FreeRTOS/tasks.c **** 		}
4519:../src/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
4520:../src/FreeRTOS/tasks.c **** 
4521:../src/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
4522:../src/FreeRTOS/tasks.c **** 		{
4523:../src/FreeRTOS/tasks.c **** 			traceTASK_NOTIFY_TAKE();
4524:../src/FreeRTOS/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
4525:../src/FreeRTOS/tasks.c **** 
4526:../src/FreeRTOS/tasks.c **** 			if( ulReturn != 0UL )
4527:../src/FreeRTOS/tasks.c **** 			{
4528:../src/FreeRTOS/tasks.c **** 				if( xClearCountOnExit != pdFALSE )
4529:../src/FreeRTOS/tasks.c **** 				{
4530:../src/FreeRTOS/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = 0UL;
4531:../src/FreeRTOS/tasks.c **** 				}
4532:../src/FreeRTOS/tasks.c **** 				else
4533:../src/FreeRTOS/tasks.c **** 				{
4534:../src/FreeRTOS/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
4535:../src/FreeRTOS/tasks.c **** 				}
4536:../src/FreeRTOS/tasks.c **** 			}
4537:../src/FreeRTOS/tasks.c **** 			else
4538:../src/FreeRTOS/tasks.c **** 			{
4539:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4540:../src/FreeRTOS/tasks.c **** 			}
4541:../src/FreeRTOS/tasks.c **** 
4542:../src/FreeRTOS/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4543:../src/FreeRTOS/tasks.c **** 		}
4544:../src/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
4545:../src/FreeRTOS/tasks.c **** 
4546:../src/FreeRTOS/tasks.c **** 		return ulReturn;
4547:../src/FreeRTOS/tasks.c **** 	}
4548:../src/FreeRTOS/tasks.c **** 
4549:../src/FreeRTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4550:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4551:../src/FreeRTOS/tasks.c **** 
4552:../src/FreeRTOS/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4553:../src/FreeRTOS/tasks.c **** 
4554:../src/FreeRTOS/tasks.c **** 	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t 
4555:../src/FreeRTOS/tasks.c **** 	{
4556:../src/FreeRTOS/tasks.c **** 	BaseType_t xReturn;
4557:../src/FreeRTOS/tasks.c **** 
4558:../src/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
4559:../src/FreeRTOS/tasks.c **** 		{
4560:../src/FreeRTOS/tasks.c **** 			/* Only block if a notification is not already pending. */
4561:../src/FreeRTOS/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
4562:../src/FreeRTOS/tasks.c **** 			{
4563:../src/FreeRTOS/tasks.c **** 				/* Clear bits in the task's notification value as bits may get
4564:../src/FreeRTOS/tasks.c **** 				set	by the notifying task or interrupt.  This can be used to
4565:../src/FreeRTOS/tasks.c **** 				clear the value to zero. */
4566:../src/FreeRTOS/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
4567:../src/FreeRTOS/tasks.c **** 
4568:../src/FreeRTOS/tasks.c **** 				/* Mark this task as waiting for a notification. */
4569:../src/FreeRTOS/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4570:../src/FreeRTOS/tasks.c **** 
4571:../src/FreeRTOS/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
4572:../src/FreeRTOS/tasks.c **** 				{
4573:../src/FreeRTOS/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4574:../src/FreeRTOS/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
4575:../src/FreeRTOS/tasks.c **** 
4576:../src/FreeRTOS/tasks.c **** 					/* All ports are written to allow a yield in a critical
4577:../src/FreeRTOS/tasks.c **** 					section (some will yield immediately, others wait until the
4578:../src/FreeRTOS/tasks.c **** 					critical section exits) - but it is not something that
4579:../src/FreeRTOS/tasks.c **** 					application code should ever do. */
4580:../src/FreeRTOS/tasks.c **** 					portYIELD_WITHIN_API();
4581:../src/FreeRTOS/tasks.c **** 				}
4582:../src/FreeRTOS/tasks.c **** 				else
4583:../src/FreeRTOS/tasks.c **** 				{
4584:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4585:../src/FreeRTOS/tasks.c **** 				}
4586:../src/FreeRTOS/tasks.c **** 			}
4587:../src/FreeRTOS/tasks.c **** 			else
4588:../src/FreeRTOS/tasks.c **** 			{
4589:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4590:../src/FreeRTOS/tasks.c **** 			}
4591:../src/FreeRTOS/tasks.c **** 		}
4592:../src/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
4593:../src/FreeRTOS/tasks.c **** 
4594:../src/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
4595:../src/FreeRTOS/tasks.c **** 		{
4596:../src/FreeRTOS/tasks.c **** 			traceTASK_NOTIFY_WAIT();
4597:../src/FreeRTOS/tasks.c **** 
4598:../src/FreeRTOS/tasks.c **** 			if( pulNotificationValue != NULL )
4599:../src/FreeRTOS/tasks.c **** 			{
4600:../src/FreeRTOS/tasks.c **** 				/* Output the current notification value, which may or may not
4601:../src/FreeRTOS/tasks.c **** 				have changed. */
4602:../src/FreeRTOS/tasks.c **** 				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
4603:../src/FreeRTOS/tasks.c **** 			}
4604:../src/FreeRTOS/tasks.c **** 
4605:../src/FreeRTOS/tasks.c **** 			/* If ucNotifyValue is set then either the task never entered the
4606:../src/FreeRTOS/tasks.c **** 			blocked state (because a notification was already pending) or the
4607:../src/FreeRTOS/tasks.c **** 			task unblocked because of a notification.  Otherwise the task
4608:../src/FreeRTOS/tasks.c **** 			unblocked because of a timeout. */
4609:../src/FreeRTOS/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
4610:../src/FreeRTOS/tasks.c **** 			{
4611:../src/FreeRTOS/tasks.c **** 				/* A notification was not received. */
4612:../src/FreeRTOS/tasks.c **** 				xReturn = pdFALSE;
4613:../src/FreeRTOS/tasks.c **** 			}
4614:../src/FreeRTOS/tasks.c **** 			else
4615:../src/FreeRTOS/tasks.c **** 			{
4616:../src/FreeRTOS/tasks.c **** 				/* A notification was already pending or a notification was
4617:../src/FreeRTOS/tasks.c **** 				received while the task was waiting. */
4618:../src/FreeRTOS/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
4619:../src/FreeRTOS/tasks.c **** 				xReturn = pdTRUE;
4620:../src/FreeRTOS/tasks.c **** 			}
4621:../src/FreeRTOS/tasks.c **** 
4622:../src/FreeRTOS/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4623:../src/FreeRTOS/tasks.c **** 		}
4624:../src/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
4625:../src/FreeRTOS/tasks.c **** 
4626:../src/FreeRTOS/tasks.c **** 		return xReturn;
4627:../src/FreeRTOS/tasks.c **** 	}
4628:../src/FreeRTOS/tasks.c **** 
4629:../src/FreeRTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4630:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4631:../src/FreeRTOS/tasks.c **** 
4632:../src/FreeRTOS/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4633:../src/FreeRTOS/tasks.c **** 
4634:../src/FreeRTOS/tasks.c **** 	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction
4635:../src/FreeRTOS/tasks.c **** 	{
4636:../src/FreeRTOS/tasks.c **** 	TCB_t * pxTCB;
4637:../src/FreeRTOS/tasks.c **** 	BaseType_t xReturn = pdPASS;
4638:../src/FreeRTOS/tasks.c **** 	uint8_t ucOriginalNotifyState;
4639:../src/FreeRTOS/tasks.c **** 
4640:../src/FreeRTOS/tasks.c **** 		configASSERT( xTaskToNotify );
4641:../src/FreeRTOS/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
4642:../src/FreeRTOS/tasks.c **** 
4643:../src/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
4644:../src/FreeRTOS/tasks.c **** 		{
4645:../src/FreeRTOS/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
4646:../src/FreeRTOS/tasks.c **** 			{
4647:../src/FreeRTOS/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4648:../src/FreeRTOS/tasks.c **** 			}
4649:../src/FreeRTOS/tasks.c **** 
4650:../src/FreeRTOS/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4651:../src/FreeRTOS/tasks.c **** 
4652:../src/FreeRTOS/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4653:../src/FreeRTOS/tasks.c **** 
4654:../src/FreeRTOS/tasks.c **** 			switch( eAction )
4655:../src/FreeRTOS/tasks.c **** 			{
4656:../src/FreeRTOS/tasks.c **** 				case eSetBits	:
4657:../src/FreeRTOS/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4658:../src/FreeRTOS/tasks.c **** 					break;
4659:../src/FreeRTOS/tasks.c **** 
4660:../src/FreeRTOS/tasks.c **** 				case eIncrement	:
4661:../src/FreeRTOS/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4662:../src/FreeRTOS/tasks.c **** 					break;
4663:../src/FreeRTOS/tasks.c **** 
4664:../src/FreeRTOS/tasks.c **** 				case eSetValueWithOverwrite	:
4665:../src/FreeRTOS/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4666:../src/FreeRTOS/tasks.c **** 					break;
4667:../src/FreeRTOS/tasks.c **** 
4668:../src/FreeRTOS/tasks.c **** 				case eSetValueWithoutOverwrite :
4669:../src/FreeRTOS/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4670:../src/FreeRTOS/tasks.c **** 					{
4671:../src/FreeRTOS/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
4672:../src/FreeRTOS/tasks.c **** 					}
4673:../src/FreeRTOS/tasks.c **** 					else
4674:../src/FreeRTOS/tasks.c **** 					{
4675:../src/FreeRTOS/tasks.c **** 						/* The value could not be written to the task. */
4676:../src/FreeRTOS/tasks.c **** 						xReturn = pdFAIL;
4677:../src/FreeRTOS/tasks.c **** 					}
4678:../src/FreeRTOS/tasks.c **** 					break;
4679:../src/FreeRTOS/tasks.c **** 
4680:../src/FreeRTOS/tasks.c **** 				case eNoAction:
4681:../src/FreeRTOS/tasks.c **** 					/* The task is being notified without its notify value being
4682:../src/FreeRTOS/tasks.c **** 					updated. */
4683:../src/FreeRTOS/tasks.c **** 					break;
4684:../src/FreeRTOS/tasks.c **** 			}
4685:../src/FreeRTOS/tasks.c **** 
4686:../src/FreeRTOS/tasks.c **** 			traceTASK_NOTIFY();
4687:../src/FreeRTOS/tasks.c **** 
4688:../src/FreeRTOS/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4689:../src/FreeRTOS/tasks.c **** 			notification then unblock it now. */
4690:../src/FreeRTOS/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4691:../src/FreeRTOS/tasks.c **** 			{
4692:../src/FreeRTOS/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4693:../src/FreeRTOS/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
4694:../src/FreeRTOS/tasks.c **** 
4695:../src/FreeRTOS/tasks.c **** 				/* The task should not have been on an event list. */
4696:../src/FreeRTOS/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4697:../src/FreeRTOS/tasks.c **** 
4698:../src/FreeRTOS/tasks.c **** 				#if( configUSE_TICKLESS_IDLE != 0 )
4699:../src/FreeRTOS/tasks.c **** 				{
4700:../src/FreeRTOS/tasks.c **** 					/* If a task is blocked waiting for a notification then
4701:../src/FreeRTOS/tasks.c **** 					xNextTaskUnblockTime might be set to the blocked task's time
4702:../src/FreeRTOS/tasks.c **** 					out time.  If the task is unblocked for a reason other than
4703:../src/FreeRTOS/tasks.c **** 					a timeout xNextTaskUnblockTime is normally left unchanged,
4704:../src/FreeRTOS/tasks.c **** 					because it will automatically get reset to a new value when
4705:../src/FreeRTOS/tasks.c **** 					the tick count equals xNextTaskUnblockTime.  However if
4706:../src/FreeRTOS/tasks.c **** 					tickless idling is used it might be more important to enter
4707:../src/FreeRTOS/tasks.c **** 					sleep mode at the earliest possible time - so reset
4708:../src/FreeRTOS/tasks.c **** 					xNextTaskUnblockTime here to ensure it is updated at the
4709:../src/FreeRTOS/tasks.c **** 					earliest possible time. */
4710:../src/FreeRTOS/tasks.c **** 					prvResetNextTaskUnblockTime();
4711:../src/FreeRTOS/tasks.c **** 				}
4712:../src/FreeRTOS/tasks.c **** 				#endif
4713:../src/FreeRTOS/tasks.c **** 
4714:../src/FreeRTOS/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4715:../src/FreeRTOS/tasks.c **** 				{
4716:../src/FreeRTOS/tasks.c **** 					/* The notified task has a priority above the currently
4717:../src/FreeRTOS/tasks.c **** 					executing task so a yield is required. */
4718:../src/FreeRTOS/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
4719:../src/FreeRTOS/tasks.c **** 				}
4720:../src/FreeRTOS/tasks.c **** 				else
4721:../src/FreeRTOS/tasks.c **** 				{
4722:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4723:../src/FreeRTOS/tasks.c **** 				}
4724:../src/FreeRTOS/tasks.c **** 			}
4725:../src/FreeRTOS/tasks.c **** 			else
4726:../src/FreeRTOS/tasks.c **** 			{
4727:../src/FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4728:../src/FreeRTOS/tasks.c **** 			}
4729:../src/FreeRTOS/tasks.c **** 		}
4730:../src/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
4731:../src/FreeRTOS/tasks.c **** 
4732:../src/FreeRTOS/tasks.c **** 		return xReturn;
4733:../src/FreeRTOS/tasks.c **** 	}
4734:../src/FreeRTOS/tasks.c **** 
4735:../src/FreeRTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4736:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4737:../src/FreeRTOS/tasks.c **** 
4738:../src/FreeRTOS/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4739:../src/FreeRTOS/tasks.c **** 
4740:../src/FreeRTOS/tasks.c **** 	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction 
4741:../src/FreeRTOS/tasks.c **** 	{
4742:../src/FreeRTOS/tasks.c **** 	TCB_t * pxTCB;
4743:../src/FreeRTOS/tasks.c **** 	uint8_t ucOriginalNotifyState;
4744:../src/FreeRTOS/tasks.c **** 	BaseType_t xReturn = pdPASS;
4745:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4746:../src/FreeRTOS/tasks.c **** 
4747:../src/FreeRTOS/tasks.c **** 		configASSERT( xTaskToNotify );
4748:../src/FreeRTOS/tasks.c **** 
4749:../src/FreeRTOS/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4750:../src/FreeRTOS/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4751:../src/FreeRTOS/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4752:../src/FreeRTOS/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4753:../src/FreeRTOS/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4754:../src/FreeRTOS/tasks.c **** 		is defined in FreeRTOSConfig.h then
4755:../src/FreeRTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4756:../src/FreeRTOS/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4757:../src/FreeRTOS/tasks.c **** 		been assigned a priority above the configured maximum system call
4758:../src/FreeRTOS/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4759:../src/FreeRTOS/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4760:../src/FreeRTOS/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4761:../src/FreeRTOS/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4762:../src/FreeRTOS/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4763:../src/FreeRTOS/tasks.c **** 		provided on the following link:
4764:../src/FreeRTOS/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4765:../src/FreeRTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4766:../src/FreeRTOS/tasks.c **** 
4767:../src/FreeRTOS/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
4768:../src/FreeRTOS/tasks.c **** 
4769:../src/FreeRTOS/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4770:../src/FreeRTOS/tasks.c **** 		{
4771:../src/FreeRTOS/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
4772:../src/FreeRTOS/tasks.c **** 			{
4773:../src/FreeRTOS/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4774:../src/FreeRTOS/tasks.c **** 			}
4775:../src/FreeRTOS/tasks.c **** 
4776:../src/FreeRTOS/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4777:../src/FreeRTOS/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4778:../src/FreeRTOS/tasks.c **** 
4779:../src/FreeRTOS/tasks.c **** 			switch( eAction )
4780:../src/FreeRTOS/tasks.c **** 			{
4781:../src/FreeRTOS/tasks.c **** 				case eSetBits	:
4782:../src/FreeRTOS/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4783:../src/FreeRTOS/tasks.c **** 					break;
4784:../src/FreeRTOS/tasks.c **** 
4785:../src/FreeRTOS/tasks.c **** 				case eIncrement	:
4786:../src/FreeRTOS/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4787:../src/FreeRTOS/tasks.c **** 					break;
4788:../src/FreeRTOS/tasks.c **** 
4789:../src/FreeRTOS/tasks.c **** 				case eSetValueWithOverwrite	:
4790:../src/FreeRTOS/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4791:../src/FreeRTOS/tasks.c **** 					break;
4792:../src/FreeRTOS/tasks.c **** 
4793:../src/FreeRTOS/tasks.c **** 				case eSetValueWithoutOverwrite :
4794:../src/FreeRTOS/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4795:../src/FreeRTOS/tasks.c **** 					{
4796:../src/FreeRTOS/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
4797:../src/FreeRTOS/tasks.c **** 					}
4798:../src/FreeRTOS/tasks.c **** 					else
4799:../src/FreeRTOS/tasks.c **** 					{
4800:../src/FreeRTOS/tasks.c **** 						/* The value could not be written to the task. */
4801:../src/FreeRTOS/tasks.c **** 						xReturn = pdFAIL;
4802:../src/FreeRTOS/tasks.c **** 					}
4803:../src/FreeRTOS/tasks.c **** 					break;
4804:../src/FreeRTOS/tasks.c **** 
4805:../src/FreeRTOS/tasks.c **** 				case eNoAction :
4806:../src/FreeRTOS/tasks.c **** 					/* The task is being notified without its notify value being
4807:../src/FreeRTOS/tasks.c **** 					updated. */
4808:../src/FreeRTOS/tasks.c **** 					break;
4809:../src/FreeRTOS/tasks.c **** 			}
4810:../src/FreeRTOS/tasks.c **** 
4811:../src/FreeRTOS/tasks.c **** 			traceTASK_NOTIFY_FROM_ISR();
4812:../src/FreeRTOS/tasks.c **** 
4813:../src/FreeRTOS/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4814:../src/FreeRTOS/tasks.c **** 			notification then unblock it now. */
4815:../src/FreeRTOS/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4816:../src/FreeRTOS/tasks.c **** 			{
4817:../src/FreeRTOS/tasks.c **** 				/* The task should not have been on an event list. */
4818:../src/FreeRTOS/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4819:../src/FreeRTOS/tasks.c **** 
4820:../src/FreeRTOS/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4821:../src/FreeRTOS/tasks.c **** 				{
4822:../src/FreeRTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4823:../src/FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4824:../src/FreeRTOS/tasks.c **** 				}
4825:../src/FreeRTOS/tasks.c **** 				else
4826:../src/FreeRTOS/tasks.c **** 				{
4827:../src/FreeRTOS/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4828:../src/FreeRTOS/tasks.c **** 					this task pending until the scheduler is resumed. */
4829:../src/FreeRTOS/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
4830:../src/FreeRTOS/tasks.c **** 				}
4831:../src/FreeRTOS/tasks.c **** 
4832:../src/FreeRTOS/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4833:../src/FreeRTOS/tasks.c **** 				{
4834:../src/FreeRTOS/tasks.c **** 					/* The notified task has a priority above the currently
4835:../src/FreeRTOS/tasks.c **** 					executing task so a yield is required. */
4836:../src/FreeRTOS/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
4837:../src/FreeRTOS/tasks.c **** 					{
4838:../src/FreeRTOS/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
4839:../src/FreeRTOS/tasks.c **** 					}
4840:../src/FreeRTOS/tasks.c **** 					else
4841:../src/FreeRTOS/tasks.c **** 					{
4842:../src/FreeRTOS/tasks.c **** 						/* Mark that a yield is pending in case the user is not
4843:../src/FreeRTOS/tasks.c **** 						using the "xHigherPriorityTaskWoken" parameter to an ISR
4844:../src/FreeRTOS/tasks.c **** 						safe FreeRTOS function. */
4845:../src/FreeRTOS/tasks.c **** 						xYieldPending = pdTRUE;
4846:../src/FreeRTOS/tasks.c **** 					}
4847:../src/FreeRTOS/tasks.c **** 				}
4848:../src/FreeRTOS/tasks.c **** 				else
4849:../src/FreeRTOS/tasks.c **** 				{
4850:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4851:../src/FreeRTOS/tasks.c **** 				}
4852:../src/FreeRTOS/tasks.c **** 			}
4853:../src/FreeRTOS/tasks.c **** 		}
4854:../src/FreeRTOS/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4855:../src/FreeRTOS/tasks.c **** 
4856:../src/FreeRTOS/tasks.c **** 		return xReturn;
4857:../src/FreeRTOS/tasks.c **** 	}
4858:../src/FreeRTOS/tasks.c **** 
4859:../src/FreeRTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4860:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4861:../src/FreeRTOS/tasks.c **** 
4862:../src/FreeRTOS/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4863:../src/FreeRTOS/tasks.c **** 
4864:../src/FreeRTOS/tasks.c **** 	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4865:../src/FreeRTOS/tasks.c **** 	{
4866:../src/FreeRTOS/tasks.c **** 	TCB_t * pxTCB;
4867:../src/FreeRTOS/tasks.c **** 	uint8_t ucOriginalNotifyState;
4868:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4869:../src/FreeRTOS/tasks.c **** 
4870:../src/FreeRTOS/tasks.c **** 		configASSERT( xTaskToNotify );
4871:../src/FreeRTOS/tasks.c **** 
4872:../src/FreeRTOS/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4873:../src/FreeRTOS/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4874:../src/FreeRTOS/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4875:../src/FreeRTOS/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4876:../src/FreeRTOS/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4877:../src/FreeRTOS/tasks.c **** 		is defined in FreeRTOSConfig.h then
4878:../src/FreeRTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4879:../src/FreeRTOS/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4880:../src/FreeRTOS/tasks.c **** 		been assigned a priority above the configured maximum system call
4881:../src/FreeRTOS/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4882:../src/FreeRTOS/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4883:../src/FreeRTOS/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4884:../src/FreeRTOS/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4885:../src/FreeRTOS/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4886:../src/FreeRTOS/tasks.c **** 		provided on the following link:
4887:../src/FreeRTOS/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4888:../src/FreeRTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4889:../src/FreeRTOS/tasks.c **** 
4890:../src/FreeRTOS/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
4891:../src/FreeRTOS/tasks.c **** 
4892:../src/FreeRTOS/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4893:../src/FreeRTOS/tasks.c **** 		{
4894:../src/FreeRTOS/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4895:../src/FreeRTOS/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4896:../src/FreeRTOS/tasks.c **** 
4897:../src/FreeRTOS/tasks.c **** 			/* 'Giving' is equivalent to incrementing a count in a counting
4898:../src/FreeRTOS/tasks.c **** 			semaphore. */
4899:../src/FreeRTOS/tasks.c **** 			( pxTCB->ulNotifiedValue )++;
4900:../src/FreeRTOS/tasks.c **** 
4901:../src/FreeRTOS/tasks.c **** 			traceTASK_NOTIFY_GIVE_FROM_ISR();
4902:../src/FreeRTOS/tasks.c **** 
4903:../src/FreeRTOS/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4904:../src/FreeRTOS/tasks.c **** 			notification then unblock it now. */
4905:../src/FreeRTOS/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4906:../src/FreeRTOS/tasks.c **** 			{
4907:../src/FreeRTOS/tasks.c **** 				/* The task should not have been on an event list. */
4908:../src/FreeRTOS/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4909:../src/FreeRTOS/tasks.c **** 
4910:../src/FreeRTOS/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4911:../src/FreeRTOS/tasks.c **** 				{
4912:../src/FreeRTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4913:../src/FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4914:../src/FreeRTOS/tasks.c **** 				}
4915:../src/FreeRTOS/tasks.c **** 				else
4916:../src/FreeRTOS/tasks.c **** 				{
4917:../src/FreeRTOS/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4918:../src/FreeRTOS/tasks.c **** 					this task pending until the scheduler is resumed. */
4919:../src/FreeRTOS/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
4920:../src/FreeRTOS/tasks.c **** 				}
4921:../src/FreeRTOS/tasks.c **** 
4922:../src/FreeRTOS/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4923:../src/FreeRTOS/tasks.c **** 				{
4924:../src/FreeRTOS/tasks.c **** 					/* The notified task has a priority above the currently
4925:../src/FreeRTOS/tasks.c **** 					executing task so a yield is required. */
4926:../src/FreeRTOS/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
4927:../src/FreeRTOS/tasks.c **** 					{
4928:../src/FreeRTOS/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
4929:../src/FreeRTOS/tasks.c **** 					}
4930:../src/FreeRTOS/tasks.c **** 					else
4931:../src/FreeRTOS/tasks.c **** 					{
4932:../src/FreeRTOS/tasks.c **** 						/* Mark that a yield is pending in case the user is not
4933:../src/FreeRTOS/tasks.c **** 						using the "xHigherPriorityTaskWoken" parameter in an ISR
4934:../src/FreeRTOS/tasks.c **** 						safe FreeRTOS function. */
4935:../src/FreeRTOS/tasks.c **** 						xYieldPending = pdTRUE;
4936:../src/FreeRTOS/tasks.c **** 					}
4937:../src/FreeRTOS/tasks.c **** 				}
4938:../src/FreeRTOS/tasks.c **** 				else
4939:../src/FreeRTOS/tasks.c **** 				{
4940:../src/FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4941:../src/FreeRTOS/tasks.c **** 				}
4942:../src/FreeRTOS/tasks.c **** 			}
4943:../src/FreeRTOS/tasks.c **** 		}
4944:../src/FreeRTOS/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4945:../src/FreeRTOS/tasks.c **** 	}
4946:../src/FreeRTOS/tasks.c **** 
4947:../src/FreeRTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4948:../src/FreeRTOS/tasks.c **** 
4949:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4950:../src/FreeRTOS/tasks.c **** 
4951:../src/FreeRTOS/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4952:../src/FreeRTOS/tasks.c **** 
4953:../src/FreeRTOS/tasks.c **** 	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
4954:../src/FreeRTOS/tasks.c **** 	{
4955:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
4956:../src/FreeRTOS/tasks.c **** 	BaseType_t xReturn;
4957:../src/FreeRTOS/tasks.c **** 
4958:../src/FreeRTOS/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
4959:../src/FreeRTOS/tasks.c **** 		its notification state cleared. */
4960:../src/FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
4961:../src/FreeRTOS/tasks.c **** 
4962:../src/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
4963:../src/FreeRTOS/tasks.c **** 		{
4964:../src/FreeRTOS/tasks.c **** 			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
4965:../src/FreeRTOS/tasks.c **** 			{
4966:../src/FreeRTOS/tasks.c **** 				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4967:../src/FreeRTOS/tasks.c **** 				xReturn = pdPASS;
4968:../src/FreeRTOS/tasks.c **** 			}
4969:../src/FreeRTOS/tasks.c **** 			else
4970:../src/FreeRTOS/tasks.c **** 			{
4971:../src/FreeRTOS/tasks.c **** 				xReturn = pdFAIL;
4972:../src/FreeRTOS/tasks.c **** 			}
4973:../src/FreeRTOS/tasks.c **** 		}
4974:../src/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
4975:../src/FreeRTOS/tasks.c **** 
4976:../src/FreeRTOS/tasks.c **** 		return xReturn;
4977:../src/FreeRTOS/tasks.c **** 	}
4978:../src/FreeRTOS/tasks.c **** 
4979:../src/FreeRTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4980:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4981:../src/FreeRTOS/tasks.c **** 
4982:../src/FreeRTOS/tasks.c **** 
4983:../src/FreeRTOS/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
4984:../src/FreeRTOS/tasks.c **** {
 681              		.loc 1 4984 0
 682              		.cfi_startproc
 683              		@ args = 0, pretend = 0, frame = 0
 684              		@ frame_needed = 0, uses_anonymous_args = 0
 685              	.LVL64:
 686 0000 70402DE9 		push	{r4, r5, r6, lr}
 687              		.cfi_def_cfa_offset 16
 688              		.cfi_offset 4, -16
 689              		.cfi_offset 5, -12
 690              		.cfi_offset 6, -8
 691              		.cfi_offset 14, -4
 692 0004 0050A0E1 		mov	r5, r0
 693 0008 0140A0E1 		mov	r4, r1
4985:../src/FreeRTOS/tasks.c **** TickType_t xTimeToWake;
4986:../src/FreeRTOS/tasks.c **** const TickType_t xConstTickCount = xTickCount;
 694              		.loc 1 4986 0
 695 000c 003000E3 		movw	r3, #:lower16:.LANCHOR15
 696 0010 003040E3 		movt	r3, #:upper16:.LANCHOR15
 697 0014 006093E5 		ldr	r6, [r3]
 698              	.LVL65:
4987:../src/FreeRTOS/tasks.c **** 
4988:../src/FreeRTOS/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
4989:../src/FreeRTOS/tasks.c **** 	{
4990:../src/FreeRTOS/tasks.c **** 		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
4991:../src/FreeRTOS/tasks.c **** 		reset to pdFALSE so it can be detected as having been set to pdTRUE
4992:../src/FreeRTOS/tasks.c **** 		when the task leaves the Blocked state. */
4993:../src/FreeRTOS/tasks.c **** 		pxCurrentTCB->ucDelayAborted = pdFALSE;
 699              		.loc 1 4993 0
 700 0018 003000E3 		movw	r3, #:lower16:.LANCHOR10
 701 001c 003040E3 		movt	r3, #:upper16:.LANCHOR10
 702 0020 002093E5 		ldr	r2, [r3]
 703 0024 0010A0E3 		mov	r1, #0
 704              	.LVL66:
 705 0028 7510C2E5 		strb	r1, [r2, #117]
4994:../src/FreeRTOS/tasks.c **** 	}
4995:../src/FreeRTOS/tasks.c **** 	#endif
4996:../src/FreeRTOS/tasks.c **** 
4997:../src/FreeRTOS/tasks.c **** 	/* Remove the task from the ready list before adding it to the blocked list
4998:../src/FreeRTOS/tasks.c **** 	as the same list item is used for both lists. */
4999:../src/FreeRTOS/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 706              		.loc 1 4999 0
 707 002c 000093E5 		ldr	r0, [r3]
 708              	.LVL67:
 709 0030 040080E2 		add	r0, r0, #4
 710 0034 FEFFFFEB 		bl	uxListRemove
 711              	.LVL68:
5000:../src/FreeRTOS/tasks.c **** 	{
5001:../src/FreeRTOS/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
5002:../src/FreeRTOS/tasks.c **** 		check, and the port reset macro can be called directly. */
5003:../src/FreeRTOS/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
5004:../src/FreeRTOS/tasks.c **** 	}
5005:../src/FreeRTOS/tasks.c **** 	else
5006:../src/FreeRTOS/tasks.c **** 	{
5007:../src/FreeRTOS/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
5008:../src/FreeRTOS/tasks.c **** 	}
5009:../src/FreeRTOS/tasks.c **** 
5010:../src/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
5011:../src/FreeRTOS/tasks.c **** 	{
5012:../src/FreeRTOS/tasks.c **** 		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 712              		.loc 1 5012 0
 713 0038 004094E2 		adds	r4, r4, #0
 714 003c 0140A013 		movne	r4, #1
 715              	.LVL69:
 716 0040 010075E3 		cmn	r5, #1
 717 0044 0040A013 		movne	r4, #0
 718 0048 000054E3 		cmp	r4, #0
 719 004c 1600001A 		bne	.L60
5013:../src/FreeRTOS/tasks.c **** 		{
5014:../src/FreeRTOS/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
5015:../src/FreeRTOS/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
5016:../src/FreeRTOS/tasks.c **** 			indefinitely. */
5017:../src/FreeRTOS/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
5018:../src/FreeRTOS/tasks.c **** 		}
5019:../src/FreeRTOS/tasks.c **** 		else
5020:../src/FreeRTOS/tasks.c **** 		{
5021:../src/FreeRTOS/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
5022:../src/FreeRTOS/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
5023:../src/FreeRTOS/tasks.c **** 			kernel will manage it correctly. */
5024:../src/FreeRTOS/tasks.c **** 			xTimeToWake = xConstTickCount + xTicksToWait;
 720              		.loc 1 5024 0
 721 0050 055086E0 		add	r5, r6, r5
 722              	.LVL70:
5025:../src/FreeRTOS/tasks.c **** 
5026:../src/FreeRTOS/tasks.c **** 			/* The list item will be inserted in wake time order. */
5027:../src/FreeRTOS/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 723              		.loc 1 5027 0
 724 0054 003000E3 		movw	r3, #:lower16:.LANCHOR10
 725 0058 003040E3 		movt	r3, #:upper16:.LANCHOR10
 726 005c 003093E5 		ldr	r3, [r3]
 727 0060 045083E5 		str	r5, [r3, #4]
5028:../src/FreeRTOS/tasks.c **** 
5029:../src/FreeRTOS/tasks.c **** 			if( xTimeToWake < xConstTickCount )
 728              		.loc 1 5029 0
 729 0064 050056E1 		cmp	r6, r5
 730 0068 1700008A 		bhi	.L61
5030:../src/FreeRTOS/tasks.c **** 			{
5031:../src/FreeRTOS/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow
5032:../src/FreeRTOS/tasks.c **** 				list. */
5033:../src/FreeRTOS/tasks.c **** 				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5034:../src/FreeRTOS/tasks.c **** 			}
5035:../src/FreeRTOS/tasks.c **** 			else
5036:../src/FreeRTOS/tasks.c **** 			{
5037:../src/FreeRTOS/tasks.c **** 				/* The wake time has not overflowed, so the current block list
5038:../src/FreeRTOS/tasks.c **** 				is used. */
5039:../src/FreeRTOS/tasks.c **** 				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 731              		.loc 1 5039 0
 732 006c 003000E3 		movw	r3, #:lower16:.LANCHOR0
 733 0070 003040E3 		movt	r3, #:upper16:.LANCHOR0
 734 0074 000093E5 		ldr	r0, [r3]
 735 0078 003000E3 		movw	r3, #:lower16:.LANCHOR10
 736 007c 003040E3 		movt	r3, #:upper16:.LANCHOR10
 737 0080 001093E5 		ldr	r1, [r3]
 738 0084 041081E2 		add	r1, r1, #4
 739 0088 FEFFFFEB 		bl	vListInsert
 740              	.LVL71:
5040:../src/FreeRTOS/tasks.c **** 
5041:../src/FreeRTOS/tasks.c **** 				/* If the task entering the blocked state was placed at the
5042:../src/FreeRTOS/tasks.c **** 				head of the list of blocked tasks then xNextTaskUnblockTime
5043:../src/FreeRTOS/tasks.c **** 				needs to be updated too. */
5044:../src/FreeRTOS/tasks.c **** 				if( xTimeToWake < xNextTaskUnblockTime )
 741              		.loc 1 5044 0
 742 008c 003000E3 		movw	r3, #:lower16:.LANCHOR1
 743 0090 003040E3 		movt	r3, #:upper16:.LANCHOR1
 744 0094 003093E5 		ldr	r3, [r3]
 745 0098 030055E1 		cmp	r5, r3
5045:../src/FreeRTOS/tasks.c **** 				{
5046:../src/FreeRTOS/tasks.c **** 					xNextTaskUnblockTime = xTimeToWake;
 746              		.loc 1 5046 0
 747 009c 00300033 		movwcc	r3, #:lower16:.LANCHOR1
 748 00a0 00304033 		movtcc	r3, #:upper16:.LANCHOR1
 749 00a4 00508335 		strcc	r5, [r3]
 750 00a8 7080BDE8 		pop	{r4, r5, r6, pc}
 751              	.LVL72:
 752              	.L60:
5017:../src/FreeRTOS/tasks.c **** 		}
 753              		.loc 1 5017 0
 754 00ac 003000E3 		movw	r3, #:lower16:.LANCHOR10
 755 00b0 003040E3 		movt	r3, #:upper16:.LANCHOR10
 756 00b4 001093E5 		ldr	r1, [r3]
 757 00b8 041081E2 		add	r1, r1, #4
 758 00bc 000000E3 		movw	r0, #:lower16:.LANCHOR2
 759 00c0 000040E3 		movt	r0, #:upper16:.LANCHOR2
 760 00c4 FEFFFFEB 		bl	vListInsertEnd
 761              	.LVL73:
 762 00c8 7080BDE8 		pop	{r4, r5, r6, pc}
 763              	.LVL74:
 764              	.L61:
5033:../src/FreeRTOS/tasks.c **** 			}
 765              		.loc 1 5033 0
 766 00cc 003000E3 		movw	r3, #:lower16:.LANCHOR8
 767 00d0 003040E3 		movt	r3, #:upper16:.LANCHOR8
 768 00d4 000093E5 		ldr	r0, [r3]
 769 00d8 003000E3 		movw	r3, #:lower16:.LANCHOR10
 770 00dc 003040E3 		movt	r3, #:upper16:.LANCHOR10
 771 00e0 001093E5 		ldr	r1, [r3]
 772 00e4 041081E2 		add	r1, r1, #4
 773 00e8 FEFFFFEB 		bl	vListInsert
 774              	.LVL75:
 775 00ec 7080BDE8 		pop	{r4, r5, r6, pc}
 776              		.cfi_endproc
 777              	.LFE67:
 779              		.section	.text.prvWriteNameToBuffer,"ax",%progbits
 780              		.align	2
 781              		.syntax unified
 782              		.arm
 783              		.fpu neon
 785              	prvWriteNameToBuffer:
 786              	.LFB56:
4205:../src/FreeRTOS/tasks.c **** 	size_t x;
 787              		.loc 1 4205 0
 788              		.cfi_startproc
 789              		@ args = 0, pretend = 0, frame = 0
 790              		@ frame_needed = 0, uses_anonymous_args = 0
 791              	.LVL76:
 792 0000 10402DE9 		push	{r4, lr}
 793              		.cfi_def_cfa_offset 8
 794              		.cfi_offset 4, -8
 795              		.cfi_offset 14, -4
 796 0004 0040A0E1 		mov	r4, r0
4209:../src/FreeRTOS/tasks.c **** 
 797              		.loc 1 4209 0
 798 0008 FEFFFFEB 		bl	strcpy
 799              	.LVL77:
4213:../src/FreeRTOS/tasks.c **** 		{
 800              		.loc 1 4213 0
 801 000c 0400A0E1 		mov	r0, r4
 802 0010 FEFFFFEB 		bl	strlen
 803              	.LVL78:
 804 0014 020000EA 		b	.L63
 805              	.L64:
4215:../src/FreeRTOS/tasks.c **** 		}
 806              		.loc 1 4215 0 discriminator 3
 807 0018 2030A0E3 		mov	r3, #32
 808 001c 0030C4E7 		strb	r3, [r4, r0]
4213:../src/FreeRTOS/tasks.c **** 		{
 809              		.loc 1 4213 0 discriminator 3
 810 0020 010080E2 		add	r0, r0, #1
 811              	.LVL79:
 812              	.L63:
4213:../src/FreeRTOS/tasks.c **** 		{
 813              		.loc 1 4213 0 is_stmt 0 discriminator 1
 814 0024 160050E3 		cmp	r0, #22
 815 0028 FAFFFF9A 		bls	.L64
4219:../src/FreeRTOS/tasks.c **** 
 816              		.loc 1 4219 0 is_stmt 1
 817 002c 0030A0E3 		mov	r3, #0
 818 0030 0030C4E7 		strb	r3, [r4, r0]
4223:../src/FreeRTOS/tasks.c **** 
 819              		.loc 1 4223 0
 820 0034 000084E0 		add	r0, r4, r0
 821              	.LVL80:
 822 0038 1080BDE8 		pop	{r4, pc}
 823              		.cfi_endproc
 824              	.LFE56:
 826              		.section	.text.xTaskCreate,"ax",%progbits
 827              		.align	2
 828              		.global	xTaskCreate
 829              		.syntax unified
 830              		.arm
 831              		.fpu neon
 833              	xTaskCreate:
 834              	.LFB1:
 749:../src/FreeRTOS/tasks.c **** 	TCB_t *pxNewTCB;
 835              		.loc 1 749 0
 836              		.cfi_startproc
 837              		@ args = 8, pretend = 0, frame = 0
 838              		@ frame_needed = 0, uses_anonymous_args = 0
 839              	.LVL81:
 840 0000 F0432DE9 		push	{r4, r5, r6, r7, r8, r9, lr}
 841              		.cfi_def_cfa_offset 28
 842              		.cfi_offset 4, -28
 843              		.cfi_offset 5, -24
 844              		.cfi_offset 6, -20
 845              		.cfi_offset 7, -16
 846              		.cfi_offset 8, -12
 847              		.cfi_offset 9, -8
 848              		.cfi_offset 14, -4
 849 0004 14D04DE2 		sub	sp, sp, #20
 850              		.cfi_def_cfa_offset 48
 851 0008 0060A0E1 		mov	r6, r0
 852 000c 0170A0E1 		mov	r7, r1
 853 0010 0250A0E1 		mov	r5, r2
 854 0014 0380A0E1 		mov	r8, r3
 855              	.LBB3:
 783:../src/FreeRTOS/tasks.c **** 
 856              		.loc 1 783 0
 857 0018 0201A0E1 		lsl	r0, r2, #2
 858              	.LVL82:
 859 001c FEFFFFEB 		bl	pvPortMalloc
 860              	.LVL83:
 785:../src/FreeRTOS/tasks.c **** 			{
 861              		.loc 1 785 0
 862 0020 009050E2 		subs	r9, r0, #0
 863 0024 1A00000A 		beq	.L70
 788:../src/FreeRTOS/tasks.c **** 
 864              		.loc 1 788 0
 865 0028 7800A0E3 		mov	r0, #120
 866              	.LVL84:
 867 002c FEFFFFEB 		bl	pvPortMalloc
 868              	.LVL85:
 790:../src/FreeRTOS/tasks.c **** 				{
 869              		.loc 1 790 0
 870 0030 004050E2 		subs	r4, r0, #0
 871 0034 1300000A 		beq	.L68
 793:../src/FreeRTOS/tasks.c **** 				}
 872              		.loc 1 793 0
 873 0038 309084E5 		str	r9, [r4, #48]
 874              	.LVL86:
 875              	.L67:
 876              	.LBE3:
 809:../src/FreeRTOS/tasks.c **** 		{
 877              		.loc 1 809 0
 878 003c 000054E3 		cmp	r4, #0
 879 0040 1500000A 		beq	.L71
 819:../src/FreeRTOS/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 880              		.loc 1 819 0
 881 0044 0030A0E3 		mov	r3, #0
 882 0048 0C308DE5 		str	r3, [sp, #12]
 883 004c 08408DE5 		str	r4, [sp, #8]
 884 0050 34309DE5 		ldr	r3, [sp, #52]
 885 0054 04308DE5 		str	r3, [sp, #4]
 886 0058 30309DE5 		ldr	r3, [sp, #48]
 887 005c 00308DE5 		str	r3, [sp]
 888 0060 0830A0E1 		mov	r3, r8
 889 0064 0520A0E1 		mov	r2, r5
 890 0068 0710A0E1 		mov	r1, r7
 891 006c 0600A0E1 		mov	r0, r6
 892 0070 FEFFFFEB 		bl	prvInitialiseNewTask
 893              	.LVL87:
 820:../src/FreeRTOS/tasks.c **** 			xReturn = pdPASS;
 894              		.loc 1 820 0
 895 0074 0400A0E1 		mov	r0, r4
 896 0078 FEFFFFEB 		bl	prvAddNewTaskToReadyList
 897              	.LVL88:
 821:../src/FreeRTOS/tasks.c **** 		}
 898              		.loc 1 821 0
 899 007c 0100A0E3 		mov	r0, #1
 900              	.LVL89:
 901              	.L66:
 829:../src/FreeRTOS/tasks.c **** 
 902              		.loc 1 829 0
 903 0080 14D08DE2 		add	sp, sp, #20
 904              		.cfi_remember_state
 905              		.cfi_def_cfa_offset 28
 906              		@ sp needed
 907 0084 F083BDE8 		pop	{r4, r5, r6, r7, r8, r9, pc}
 908              	.LVL90:
 909              	.L68:
 910              		.cfi_restore_state
 911              	.LBB4:
 799:../src/FreeRTOS/tasks.c **** 				}
 912              		.loc 1 799 0
 913 0088 0900A0E1 		mov	r0, r9
 914              	.LVL91:
 915 008c FEFFFFEB 		bl	vPortFree
 916              	.LVL92:
 917 0090 E9FFFFEA 		b	.L67
 918              	.LVL93:
 919              	.L70:
 804:../src/FreeRTOS/tasks.c **** 			}
 920              		.loc 1 804 0
 921 0094 0040A0E3 		mov	r4, #0
 922 0098 E7FFFFEA 		b	.L67
 923              	.LVL94:
 924              	.L71:
 925              	.LBE4:
 825:../src/FreeRTOS/tasks.c **** 		}
 926              		.loc 1 825 0
 927 009c 0000E0E3 		mvn	r0, #0
 928              	.LVL95:
 828:../src/FreeRTOS/tasks.c **** 	}
 929              		.loc 1 828 0
 930 00a0 F6FFFFEA 		b	.L66
 931              		.cfi_endproc
 932              	.LFE1:
 934              		.section	.text.vTaskDelete,"ax",%progbits
 935              		.align	2
 936              		.global	vTaskDelete
 937              		.syntax unified
 938              		.arm
 939              		.fpu neon
 941              	vTaskDelete:
 942              	.LFB4:
1124:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
 943              		.loc 1 1124 0
 944              		.cfi_startproc
 945              		@ args = 0, pretend = 0, frame = 0
 946              		@ frame_needed = 0, uses_anonymous_args = 0
 947              	.LVL96:
 948 0000 70402DE9 		push	{r4, r5, r6, lr}
 949              		.cfi_def_cfa_offset 16
 950              		.cfi_offset 4, -16
 951              		.cfi_offset 5, -12
 952              		.cfi_offset 6, -8
 953              		.cfi_offset 14, -4
 954 0004 0040A0E1 		mov	r4, r0
1127:../src/FreeRTOS/tasks.c **** 		{
 955              		.loc 1 1127 0
 956 0008 FEFFFFEB 		bl	vPortEnterCritical
 957              	.LVL97:
1131:../src/FreeRTOS/tasks.c **** 
 958              		.loc 1 1131 0
 959 000c 000054E3 		cmp	r4, #0
 960 0010 2B00000A 		beq	.L82
 961              	.LVL98:
 962              	.L74:
1134:../src/FreeRTOS/tasks.c **** 			{
 963              		.loc 1 1134 0 discriminator 4
 964 0014 045084E2 		add	r5, r4, #4
 965 0018 0500A0E1 		mov	r0, r5
 966 001c FEFFFFEB 		bl	uxListRemove
 967              	.LVL99:
1144:../src/FreeRTOS/tasks.c **** 			{
 968              		.loc 1 1144 0 discriminator 4
 969 0020 283094E5 		ldr	r3, [r4, #40]
 970 0024 000053E3 		cmp	r3, #0
 971 0028 0100000A 		beq	.L75
1146:../src/FreeRTOS/tasks.c **** 			}
 972              		.loc 1 1146 0
 973 002c 180084E2 		add	r0, r4, #24
 974 0030 FEFFFFEB 		bl	uxListRemove
 975              	.LVL100:
 976              	.L75:
1157:../src/FreeRTOS/tasks.c **** 
 977              		.loc 1 1157 0
 978 0034 003000E3 		movw	r3, #:lower16:.LANCHOR12
 979 0038 003040E3 		movt	r3, #:upper16:.LANCHOR12
 980 003c 002093E5 		ldr	r2, [r3]
 981 0040 012082E2 		add	r2, r2, #1
 982 0044 002083E5 		str	r2, [r3]
1159:../src/FreeRTOS/tasks.c **** 			{
 983              		.loc 1 1159 0
 984 0048 003000E3 		movw	r3, #:lower16:.LANCHOR10
 985 004c 003040E3 		movt	r3, #:upper16:.LANCHOR10
 986 0050 003093E5 		ldr	r3, [r3]
 987 0054 030054E1 		cmp	r4, r3
 988 0058 1D00000A 		beq	.L83
1182:../src/FreeRTOS/tasks.c **** 				prvDeleteTCB( pxTCB );
 989              		.loc 1 1182 0
 990 005c 003000E3 		movw	r3, #:lower16:.LANCHOR9
 991 0060 003040E3 		movt	r3, #:upper16:.LANCHOR9
 992 0064 002093E5 		ldr	r2, [r3]
 993 0068 012042E2 		sub	r2, r2, #1
 994 006c 002083E5 		str	r2, [r3]
1183:../src/FreeRTOS/tasks.c **** 
 995              		.loc 1 1183 0
 996 0070 0400A0E1 		mov	r0, r4
 997 0074 FEFFFFEB 		bl	prvDeleteTCB
 998              	.LVL101:
1187:../src/FreeRTOS/tasks.c **** 			}
 999              		.loc 1 1187 0
 1000 0078 FEFFFFEB 		bl	prvResetNextTaskUnblockTime
 1001              	.LVL102:
 1002              	.L77:
1192:../src/FreeRTOS/tasks.c **** 
 1003              		.loc 1 1192 0
 1004 007c FEFFFFEB 		bl	vPortExitCritical
 1005              	.LVL103:
1196:../src/FreeRTOS/tasks.c **** 		{
 1006              		.loc 1 1196 0
 1007 0080 003000E3 		movw	r3, #:lower16:.LANCHOR11
 1008 0084 003040E3 		movt	r3, #:upper16:.LANCHOR11
 1009 0088 003093E5 		ldr	r3, [r3]
 1010 008c 000053E3 		cmp	r3, #0
 1011 0090 7080BD08 		popeq	{r4, r5, r6, pc}
1198:../src/FreeRTOS/tasks.c **** 			{
 1012              		.loc 1 1198 0
 1013 0094 003000E3 		movw	r3, #:lower16:.LANCHOR10
 1014 0098 003040E3 		movt	r3, #:upper16:.LANCHOR10
 1015 009c 003093E5 		ldr	r3, [r3]
 1016 00a0 030054E1 		cmp	r4, r3
 1017 00a4 7080BD18 		popne	{r4, r5, r6, pc}
1200:../src/FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 1018              		.loc 1 1200 0
 1019 00a8 003000E3 		movw	r3, #:lower16:.LANCHOR16
 1020 00ac 003040E3 		movt	r3, #:upper16:.LANCHOR16
 1021 00b0 003093E5 		ldr	r3, [r3]
 1022 00b4 000053E3 		cmp	r3, #0
 1023 00b8 0F00001A 		bne	.L84
 1024              	.L79:
1201:../src/FreeRTOS/tasks.c **** 			}
 1025              		.loc 1 1201 0
 1026              		.syntax divided
 1027              	@ 1201 "../src/FreeRTOS/tasks.c" 1
 1028 00bc 000000EF 		SWI 0
 1029              	@ 0 "" 2
 1030              		.arm
 1031              		.syntax unified
 1032 00c0 7080BDE8 		pop	{r4, r5, r6, pc}
 1033              	.LVL104:
 1034              	.L82:
1131:../src/FreeRTOS/tasks.c **** 
 1035              		.loc 1 1131 0 discriminator 1
 1036 00c4 003000E3 		movw	r3, #:lower16:.LANCHOR10
 1037 00c8 003040E3 		movt	r3, #:upper16:.LANCHOR10
 1038 00cc 004093E5 		ldr	r4, [r3]
 1039              	.LVL105:
 1040 00d0 CFFFFFEA 		b	.L74
 1041              	.LVL106:
 1042              	.L83:
1166:../src/FreeRTOS/tasks.c **** 
 1043              		.loc 1 1166 0
 1044 00d4 0510A0E1 		mov	r1, r5
 1045 00d8 000000E3 		movw	r0, #:lower16:.LANCHOR7
 1046 00dc 000040E3 		movt	r0, #:upper16:.LANCHOR7
 1047 00e0 FEFFFFEB 		bl	vListInsertEnd
 1048              	.LVL107:
1171:../src/FreeRTOS/tasks.c **** 
 1049              		.loc 1 1171 0
 1050 00e4 003000E3 		movw	r3, #:lower16:.LANCHOR14
 1051 00e8 003040E3 		movt	r3, #:upper16:.LANCHOR14
 1052 00ec 002093E5 		ldr	r2, [r3]
 1053 00f0 012082E2 		add	r2, r2, #1
 1054 00f4 002083E5 		str	r2, [r3]
 1055 00f8 DFFFFFEA 		b	.L77
 1056              	.L84:
1200:../src/FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 1057              		.loc 1 1200 0 discriminator 1
 1058 00fc 4B1EA0E3 		mov	r1, #1200
 1059 0100 000000E3 		movw	r0, #:lower16:.LC0
 1060 0104 000040E3 		movt	r0, #:upper16:.LC0
 1061 0108 FEFFFFEB 		bl	R_OS_AssertCalled
 1062              	.LVL108:
 1063 010c EAFFFFEA 		b	.L79
 1064              		.cfi_endproc
 1065              	.LFE4:
 1067              		.section	.text.eTaskGetState,"ax",%progbits
 1068              		.align	2
 1069              		.global	eTaskGetState
 1070              		.syntax unified
 1071              		.arm
 1072              		.fpu neon
 1074              	eTaskGetState:
 1075              	.LFB7:
1345:../src/FreeRTOS/tasks.c **** 	eTaskState eReturn;
 1076              		.loc 1 1345 0
 1077              		.cfi_startproc
 1078              		@ args = 0, pretend = 0, frame = 0
 1079              		@ frame_needed = 0, uses_anonymous_args = 0
 1080              	.LVL109:
 1081 0000 70402DE9 		push	{r4, r5, r6, lr}
 1082              		.cfi_def_cfa_offset 16
 1083              		.cfi_offset 4, -16
 1084              		.cfi_offset 5, -12
 1085              		.cfi_offset 6, -8
 1086              		.cfi_offset 14, -4
 1087              	.LVL110:
1350:../src/FreeRTOS/tasks.c **** 
 1088              		.loc 1 1350 0
 1089 0004 005050E2 		subs	r5, r0, #0
 1090 0008 1D00000A 		beq	.L96
 1091              	.LVL111:
 1092              	.L86:
1352:../src/FreeRTOS/tasks.c **** 		{
 1093              		.loc 1 1352 0
 1094 000c 003000E3 		movw	r3, #:lower16:.LANCHOR10
 1095 0010 003040E3 		movt	r3, #:upper16:.LANCHOR10
 1096 0014 003093E5 		ldr	r3, [r3]
 1097 0018 030055E1 		cmp	r5, r3
 1098 001c 2600000A 		beq	.L89
1359:../src/FreeRTOS/tasks.c **** 			{
 1099              		.loc 1 1359 0
 1100 0020 FEFFFFEB 		bl	vPortEnterCritical
 1101              	.LVL112:
1361:../src/FreeRTOS/tasks.c **** 			}
 1102              		.loc 1 1361 0
 1103 0024 144095E5 		ldr	r4, [r5, #20]
 1104              	.LVL113:
1363:../src/FreeRTOS/tasks.c **** 
 1105              		.loc 1 1363 0
 1106 0028 FEFFFFEB 		bl	vPortExitCritical
 1107              	.LVL114:
1365:../src/FreeRTOS/tasks.c **** 			{
 1108              		.loc 1 1365 0
 1109 002c 003000E3 		movw	r3, #:lower16:.LANCHOR0
 1110 0030 003040E3 		movt	r3, #:upper16:.LANCHOR0
 1111 0034 003093E5 		ldr	r3, [r3]
 1112 0038 030054E1 		cmp	r4, r3
 1113 003c 2000000A 		beq	.L90
1365:../src/FreeRTOS/tasks.c **** 			{
 1114              		.loc 1 1365 0 is_stmt 0 discriminator 1
 1115 0040 003000E3 		movw	r3, #:lower16:.LANCHOR8
 1116 0044 003040E3 		movt	r3, #:upper16:.LANCHOR8
 1117 0048 003093E5 		ldr	r3, [r3]
 1118 004c 030054E1 		cmp	r4, r3
 1119 0050 1D00000A 		beq	.L91
1373:../src/FreeRTOS/tasks.c **** 				{
 1120              		.loc 1 1373 0 is_stmt 1
 1121 0054 003000E3 		movw	r3, #:lower16:.LANCHOR2
 1122 0058 003040E3 		movt	r3, #:upper16:.LANCHOR2
 1123 005c 030054E1 		cmp	r4, r3
 1124 0060 0C00000A 		beq	.L97
1390:../src/FreeRTOS/tasks.c **** 				{
 1125              		.loc 1 1390 0
 1126 0064 003000E3 		movw	r3, #:lower16:.LANCHOR7
 1127 0068 003040E3 		movt	r3, #:upper16:.LANCHOR7
 1128 006c 030054E1 		cmp	r4, r3
 1129 0070 1700000A 		beq	.L93
1390:../src/FreeRTOS/tasks.c **** 				{
 1130              		.loc 1 1390 0 is_stmt 0 discriminator 1
 1131 0074 000054E3 		cmp	r4, #0
 1132 0078 0D00000A 		beq	.L98
1403:../src/FreeRTOS/tasks.c **** 			}
 1133              		.loc 1 1403 0 is_stmt 1
 1134 007c 0100A0E3 		mov	r0, #1
 1135              	.LVL115:
1408:../src/FreeRTOS/tasks.c **** 
 1136              		.loc 1 1408 0
 1137 0080 7080BDE8 		pop	{r4, r5, r6, pc}
 1138              	.LVL116:
 1139              	.L96:
1350:../src/FreeRTOS/tasks.c **** 
 1140              		.loc 1 1350 0 discriminator 1
 1141 0084 461500E3 		movw	r1, #1350
 1142 0088 000000E3 		movw	r0, #:lower16:.LC0
 1143              	.LVL117:
 1144 008c 000040E3 		movt	r0, #:upper16:.LC0
 1145 0090 FEFFFFEB 		bl	R_OS_AssertCalled
 1146              	.LVL118:
 1147 0094 DCFFFFEA 		b	.L86
 1148              	.LVL119:
 1149              	.L97:
1378:../src/FreeRTOS/tasks.c **** 					{
 1150              		.loc 1 1378 0
 1151 0098 283095E5 		ldr	r3, [r5, #40]
 1152 009c 000053E3 		cmp	r3, #0
 1153 00a0 0100000A 		beq	.L99
1384:../src/FreeRTOS/tasks.c **** 					}
 1154              		.loc 1 1384 0
 1155 00a4 0200A0E3 		mov	r0, #2
 1156 00a8 7080BDE8 		pop	{r4, r5, r6, pc}
 1157              	.L99:
1380:../src/FreeRTOS/tasks.c **** 					}
 1158              		.loc 1 1380 0
 1159 00ac 0300A0E3 		mov	r0, #3
 1160 00b0 7080BDE8 		pop	{r4, r5, r6, pc}
 1161              	.L98:
1395:../src/FreeRTOS/tasks.c **** 				}
 1162              		.loc 1 1395 0
 1163 00b4 0400A0E3 		mov	r0, #4
 1164 00b8 7080BDE8 		pop	{r4, r5, r6, pc}
 1165              	.LVL120:
 1166              	.L89:
1355:../src/FreeRTOS/tasks.c **** 		}
 1167              		.loc 1 1355 0
 1168 00bc 0000A0E3 		mov	r0, #0
 1169 00c0 7080BDE8 		pop	{r4, r5, r6, pc}
 1170              	.LVL121:
 1171              	.L90:
1369:../src/FreeRTOS/tasks.c **** 			}
 1172              		.loc 1 1369 0
 1173 00c4 0200A0E3 		mov	r0, #2
 1174 00c8 7080BDE8 		pop	{r4, r5, r6, pc}
 1175              	.L91:
 1176 00cc 0200A0E3 		mov	r0, #2
 1177 00d0 7080BDE8 		pop	{r4, r5, r6, pc}
 1178              	.L93:
1395:../src/FreeRTOS/tasks.c **** 				}
 1179              		.loc 1 1395 0
 1180 00d4 0400A0E3 		mov	r0, #4
 1181 00d8 7080BDE8 		pop	{r4, r5, r6, pc}
 1182              		.cfi_endproc
 1183              	.LFE7:
 1185              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 1186              		.align	2
 1187              		.global	uxTaskPriorityGet
 1188              		.syntax unified
 1189              		.arm
 1190              		.fpu neon
 1192              	uxTaskPriorityGet:
 1193              	.LFB8:
1416:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
 1194              		.loc 1 1416 0
 1195              		.cfi_startproc
 1196              		@ args = 0, pretend = 0, frame = 0
 1197              		@ frame_needed = 0, uses_anonymous_args = 0
 1198              	.LVL122:
 1199 0000 10402DE9 		push	{r4, lr}
 1200              		.cfi_def_cfa_offset 8
 1201              		.cfi_offset 4, -8
 1202              		.cfi_offset 14, -4
 1203 0004 0040A0E1 		mov	r4, r0
1420:../src/FreeRTOS/tasks.c **** 		{
 1204              		.loc 1 1420 0
 1205 0008 FEFFFFEB 		bl	vPortEnterCritical
 1206              	.LVL123:
1424:../src/FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 1207              		.loc 1 1424 0
 1208 000c 000054E3 		cmp	r4, #0
 1209 0010 0300000A 		beq	.L104
 1210              	.LVL124:
 1211              	.L101:
1425:../src/FreeRTOS/tasks.c **** 		}
 1212              		.loc 1 1425 0 discriminator 4
 1213 0014 2C4094E5 		ldr	r4, [r4, #44]
 1214              	.LVL125:
1427:../src/FreeRTOS/tasks.c **** 
 1215              		.loc 1 1427 0 discriminator 4
 1216 0018 FEFFFFEB 		bl	vPortExitCritical
 1217              	.LVL126:
1430:../src/FreeRTOS/tasks.c **** 
 1218              		.loc 1 1430 0 discriminator 4
 1219 001c 0400A0E1 		mov	r0, r4
 1220 0020 1080BDE8 		pop	{r4, pc}
 1221              	.LVL127:
 1222              	.L104:
1424:../src/FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 1223              		.loc 1 1424 0 discriminator 1
 1224 0024 003000E3 		movw	r3, #:lower16:.LANCHOR10
 1225 0028 003040E3 		movt	r3, #:upper16:.LANCHOR10
 1226 002c 004093E5 		ldr	r4, [r3]
 1227              	.LVL128:
 1228 0030 F7FFFFEA 		b	.L101
 1229              		.cfi_endproc
 1230              	.LFE8:
 1232              		.section	.text.uxTaskPriorityGetFromISR,"ax",%progbits
 1233              		.align	2
 1234              		.global	uxTaskPriorityGetFromISR
 1235              		.syntax unified
 1236              		.arm
 1237              		.fpu neon
 1239              	uxTaskPriorityGetFromISR:
 1240              	.LFB9:
1438:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
 1241              		.loc 1 1438 0
 1242              		.cfi_startproc
 1243              		@ args = 0, pretend = 0, frame = 0
 1244              		@ frame_needed = 0, uses_anonymous_args = 0
 1245              	.LVL129:
 1246 0000 10402DE9 		push	{r4, lr}
 1247              		.cfi_def_cfa_offset 8
 1248              		.cfi_offset 4, -8
 1249              		.cfi_offset 14, -4
 1250 0004 0040A0E1 		mov	r4, r0
1458:../src/FreeRTOS/tasks.c **** 
 1251              		.loc 1 1458 0
 1252 0008 FEFFFFEB 		bl	vPortValidateInterruptPriority
 1253              	.LVL130:
1460:../src/FreeRTOS/tasks.c **** 		{
 1254              		.loc 1 1460 0
 1255 000c FEFFFFEB 		bl	ulPortSetInterruptMask
 1256              	.LVL131:
1464:../src/FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 1257              		.loc 1 1464 0
 1258 0010 000054E3 		cmp	r4, #0
 1259 0014 0300000A 		beq	.L109
 1260              	.LVL132:
 1261              	.L106:
1465:../src/FreeRTOS/tasks.c **** 		}
 1262              		.loc 1 1465 0 discriminator 4
 1263 0018 2C4094E5 		ldr	r4, [r4, #44]
 1264              	.LVL133:
1467:../src/FreeRTOS/tasks.c **** 
 1265              		.loc 1 1467 0 discriminator 4
 1266 001c FEFFFFEB 		bl	vPortClearInterruptMask
 1267              	.LVL134:
1470:../src/FreeRTOS/tasks.c **** 
 1268              		.loc 1 1470 0 discriminator 4
 1269 0020 0400A0E1 		mov	r0, r4
 1270 0024 1080BDE8 		pop	{r4, pc}
 1271              	.LVL135:
 1272              	.L109:
1464:../src/FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 1273              		.loc 1 1464 0 discriminator 1
 1274 0028 003000E3 		movw	r3, #:lower16:.LANCHOR10
 1275 002c 003040E3 		movt	r3, #:upper16:.LANCHOR10
 1276 0030 004093E5 		ldr	r4, [r3]
 1277              	.LVL136:
 1278 0034 F7FFFFEA 		b	.L106
 1279              		.cfi_endproc
 1280              	.LFE9:
 1282              		.section	.text.vTaskPrioritySet,"ax",%progbits
 1283              		.align	2
 1284              		.global	vTaskPrioritySet
 1285              		.syntax unified
 1286              		.arm
 1287              		.fpu neon
 1289              	vTaskPrioritySet:
 1290              	.LFB10:
1478:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
 1291              		.loc 1 1478 0
 1292              		.cfi_startproc
 1293              		@ args = 0, pretend = 0, frame = 0
 1294              		@ frame_needed = 0, uses_anonymous_args = 0
 1295              	.LVL137:
 1296 0000 70402DE9 		push	{r4, r5, r6, lr}
 1297              		.cfi_def_cfa_offset 16
 1298              		.cfi_offset 4, -16
 1299              		.cfi_offset 5, -12
 1300              		.cfi_offset 6, -8
 1301              		.cfi_offset 14, -4
 1302 0004 0040A0E1 		mov	r4, r0
 1303 0008 0150A0E1 		mov	r5, r1
 1304              	.LVL138:
1483:../src/FreeRTOS/tasks.c **** 
 1305              		.loc 1 1483 0
 1306 000c 130051E3 		cmp	r1, #19
 1307 0010 1500008A 		bhi	.L129
 1308              	.LVL139:
 1309              	.L111:
1486:../src/FreeRTOS/tasks.c **** 		{
 1310              		.loc 1 1486 0
 1311 0014 130055E3 		cmp	r5, #19
1488:../src/FreeRTOS/tasks.c **** 		}
 1312              		.loc 1 1488 0
 1313 0018 1350A083 		movhi	r5, #19
 1314              	.LVL140:
 1315              	.L112:
1495:../src/FreeRTOS/tasks.c **** 		{
 1316              		.loc 1 1495 0
 1317 001c FEFFFFEB 		bl	vPortEnterCritical
 1318              	.LVL141:
1499:../src/FreeRTOS/tasks.c **** 
 1319              		.loc 1 1499 0
 1320 0020 000054E3 		cmp	r4, #0
 1321 0024 1500000A 		beq	.L130
 1322              	.LVL142:
 1323              	.L113:
1505:../src/FreeRTOS/tasks.c **** 			}
 1324              		.loc 1 1505 0 discriminator 4
 1325 0028 582094E5 		ldr	r2, [r4, #88]
 1326              	.LVL143:
1513:../src/FreeRTOS/tasks.c **** 			{
 1327              		.loc 1 1513 0 discriminator 4
 1328 002c 020055E1 		cmp	r5, r2
 1329 0030 3200000A 		beq	.L114
1517:../src/FreeRTOS/tasks.c **** 				{
 1330              		.loc 1 1517 0
 1331 0034 1500009A 		bls	.L115
1519:../src/FreeRTOS/tasks.c **** 					{
 1332              		.loc 1 1519 0
 1333 0038 003000E3 		movw	r3, #:lower16:.LANCHOR10
 1334 003c 003040E3 		movt	r3, #:upper16:.LANCHOR10
 1335 0040 003093E5 		ldr	r3, [r3]
 1336 0044 030054E1 		cmp	r4, r3
 1337 0048 2E00000A 		beq	.L124
1524:../src/FreeRTOS/tasks.c **** 						{
 1338              		.loc 1 1524 0
 1339 004c 003000E3 		movw	r3, #:lower16:.LANCHOR10
 1340 0050 003040E3 		movt	r3, #:upper16:.LANCHOR10
 1341 0054 003093E5 		ldr	r3, [r3]
 1342 0058 2C3093E5 		ldr	r3, [r3, #44]
 1343 005c 030055E1 		cmp	r5, r3
 1344 0060 2A00002A 		bcs	.L125
1481:../src/FreeRTOS/tasks.c **** 
 1345              		.loc 1 1481 0
 1346 0064 0060A0E3 		mov	r6, #0
 1347 0068 0E0000EA 		b	.L116
 1348              	.LVL144:
 1349              	.L129:
1483:../src/FreeRTOS/tasks.c **** 
 1350              		.loc 1 1483 0 discriminator 1
 1351 006c CB1500E3 		movw	r1, #1483
 1352              	.LVL145:
 1353 0070 000000E3 		movw	r0, #:lower16:.LC0
 1354              	.LVL146:
 1355 0074 000040E3 		movt	r0, #:upper16:.LC0
 1356 0078 FEFFFFEB 		bl	R_OS_AssertCalled
 1357              	.LVL147:
 1358 007c E4FFFFEA 		b	.L111
 1359              	.L130:
1499:../src/FreeRTOS/tasks.c **** 
 1360              		.loc 1 1499 0 discriminator 1
 1361 0080 003000E3 		movw	r3, #:lower16:.LANCHOR10
 1362 0084 003040E3 		movt	r3, #:upper16:.LANCHOR10
 1363 0088 004093E5 		ldr	r4, [r3]
 1364              	.LVL148:
 1365 008c E5FFFFEA 		b	.L113
 1366              	.LVL149:
 1367              	.L115:
1540:../src/FreeRTOS/tasks.c **** 				{
 1368              		.loc 1 1540 0
 1369 0090 003000E3 		movw	r3, #:lower16:.LANCHOR10
 1370 0094 003040E3 		movt	r3, #:upper16:.LANCHOR10
 1371 0098 003093E5 		ldr	r3, [r3]
 1372 009c 030054E1 		cmp	r4, r3
 1373 00a0 1C00000A 		beq	.L126
1481:../src/FreeRTOS/tasks.c **** 
 1374              		.loc 1 1481 0
 1375 00a4 0060A0E3 		mov	r6, #0
 1376              	.L116:
 1377              	.LVL150:
1557:../src/FreeRTOS/tasks.c **** 
 1378              		.loc 1 1557 0
 1379 00a8 2C3094E5 		ldr	r3, [r4, #44]
 1380              	.LVL151:
1563:../src/FreeRTOS/tasks.c **** 					{
 1381              		.loc 1 1563 0
 1382 00ac 030052E1 		cmp	r2, r3
 1383 00b0 1A00000A 		beq	.L131
 1384              	.L117:
1573:../src/FreeRTOS/tasks.c **** 				}
 1385              		.loc 1 1573 0
 1386 00b4 585084E5 		str	r5, [r4, #88]
1583:../src/FreeRTOS/tasks.c **** 				{
 1387              		.loc 1 1583 0
 1388 00b8 182094E5 		ldr	r2, [r4, #24]
 1389              	.LVL152:
 1390 00bc 000052E3 		cmp	r2, #0
1585:../src/FreeRTOS/tasks.c **** 				}
 1391              		.loc 1 1585 0
 1392 00c0 145065A2 		rsbge	r5, r5, #20
 1393              	.LVL153:
 1394 00c4 185084A5 		strge	r5, [r4, #24]
 1395              	.L118:
1596:../src/FreeRTOS/tasks.c **** 				{
 1396              		.loc 1 1596 0
 1397 00c8 140094E5 		ldr	r0, [r4, #20]
 1398 00cc 002000E3 		movw	r2, #:lower16:.LANCHOR4
 1399 00d0 002040E3 		movt	r2, #:upper16:.LANCHOR4
 1400 00d4 033183E0 		add	r3, r3, r3, lsl #2
 1401              	.LVL154:
 1402 00d8 0311A0E1 		lsl	r1, r3, #2
 1403 00dc 012082E0 		add	r2, r2, r1
 1404 00e0 020050E1 		cmp	r0, r2
 1405 00e4 0F00000A 		beq	.L132
 1406 00e8 0030A0E3 		mov	r3, #0
 1407              	.L119:
1596:../src/FreeRTOS/tasks.c **** 				{
 1408              		.loc 1 1596 0 is_stmt 0 discriminator 4
 1409 00ec 000053E3 		cmp	r3, #0
 1410 00f0 0E00001A 		bne	.L133
 1411              	.LVL155:
 1412              	.L120:
1619:../src/FreeRTOS/tasks.c **** 				{
 1413              		.loc 1 1619 0 is_stmt 1
 1414 00f4 000056E3 		cmp	r6, #0
 1415 00f8 0000000A 		beq	.L114
1621:../src/FreeRTOS/tasks.c **** 				}
 1416              		.loc 1 1621 0
 1417              		.syntax divided
 1418              	@ 1621 "../src/FreeRTOS/tasks.c" 1
 1419 00fc 000000EF 		SWI 0
 1420              	@ 0 "" 2
 1421              	.LVL156:
 1422              		.arm
 1423              		.syntax unified
 1424              	.L114:
1633:../src/FreeRTOS/tasks.c **** 	}
 1425              		.loc 1 1633 0
 1426 0100 FEFFFFEB 		bl	vPortExitCritical
 1427              	.LVL157:
 1428 0104 7080BDE8 		pop	{r4, r5, r6, pc}
 1429              	.LVL158:
 1430              	.L124:
1481:../src/FreeRTOS/tasks.c **** 
 1431              		.loc 1 1481 0
 1432 0108 0060A0E3 		mov	r6, #0
 1433 010c E5FFFFEA 		b	.L116
 1434              	.L125:
1526:../src/FreeRTOS/tasks.c **** 						}
 1435              		.loc 1 1526 0
 1436 0110 0160A0E3 		mov	r6, #1
 1437 0114 E3FFFFEA 		b	.L116
 1438              	.L126:
1545:../src/FreeRTOS/tasks.c **** 				}
 1439              		.loc 1 1545 0
 1440 0118 0160A0E3 		mov	r6, #1
 1441 011c E1FFFFEA 		b	.L116
 1442              	.LVL159:
 1443              	.L131:
1565:../src/FreeRTOS/tasks.c **** 					}
 1444              		.loc 1 1565 0
 1445 0120 2C5084E5 		str	r5, [r4, #44]
 1446 0124 E2FFFFEA 		b	.L117
 1447              	.LVL160:
 1448              	.L132:
1596:../src/FreeRTOS/tasks.c **** 				{
 1449              		.loc 1 1596 0
 1450 0128 0130A0E3 		mov	r3, #1
 1451 012c EEFFFFEA 		b	.L119
 1452              	.L133:
1601:../src/FreeRTOS/tasks.c **** 					{
 1453              		.loc 1 1601 0
 1454 0130 045084E2 		add	r5, r4, #4
 1455 0134 0500A0E1 		mov	r0, r5
 1456 0138 FEFFFFEB 		bl	uxListRemove
 1457              	.LVL161:
1612:../src/FreeRTOS/tasks.c **** 				}
 1458              		.loc 1 1612 0
 1459 013c 2C3094E5 		ldr	r3, [r4, #44]
 1460 0140 002000E3 		movw	r2, #:lower16:.LANCHOR13
 1461 0144 002040E3 		movt	r2, #:upper16:.LANCHOR13
 1462 0148 002092E5 		ldr	r2, [r2]
 1463 014c 020053E1 		cmp	r3, r2
1612:../src/FreeRTOS/tasks.c **** 				}
 1464              		.loc 1 1612 0 is_stmt 0 discriminator 1
 1465 0150 00200083 		movwhi	r2, #:lower16:.LANCHOR13
 1466 0154 00204083 		movthi	r2, #:upper16:.LANCHOR13
 1467 0158 00308285 		strhi	r3, [r2]
 1468              	.L121:
1612:../src/FreeRTOS/tasks.c **** 				}
 1469              		.loc 1 1612 0 discriminator 3
 1470 015c 002000E3 		movw	r2, #:lower16:.LANCHOR4
 1471 0160 002040E3 		movt	r2, #:upper16:.LANCHOR4
 1472 0164 033183E0 		add	r3, r3, r3, lsl #2
 1473 0168 0301A0E1 		lsl	r0, r3, #2
 1474 016c 0510A0E1 		mov	r1, r5
 1475 0170 000082E0 		add	r0, r2, r0
 1476 0174 FEFFFFEB 		bl	vListInsertEnd
 1477              	.LVL162:
 1478 0178 DDFFFFEA 		b	.L120
 1479              		.cfi_endproc
 1480              	.LFE10:
 1482              		.section	.text.vTaskResume,"ax",%progbits
 1483              		.align	2
 1484              		.global	vTaskResume
 1485              		.syntax unified
 1486              		.arm
 1487              		.fpu neon
 1489              	vTaskResume:
 1490              	.LFB13:
1789:../src/FreeRTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1491              		.loc 1 1789 0 is_stmt 1
 1492              		.cfi_startproc
 1493              		@ args = 0, pretend = 0, frame = 0
 1494              		@ frame_needed = 0, uses_anonymous_args = 0
 1495              	.LVL163:
 1496 0000 70402DE9 		push	{r4, r5, r6, lr}
 1497              		.cfi_def_cfa_offset 16
 1498              		.cfi_offset 4, -16
 1499              		.cfi_offset 5, -12
 1500              		.cfi_offset 6, -8
 1501              		.cfi_offset 14, -4
 1502              	.LVL164:
1793:../src/FreeRTOS/tasks.c **** 
 1503              		.loc 1 1793 0
 1504 0004 004050E2 		subs	r4, r0, #0
 1505 0008 0D00000A 		beq	.L140
 1506              	.LVL165:
 1507              	.L135:
1797:../src/FreeRTOS/tasks.c **** 		{
 1508              		.loc 1 1797 0
 1509 000c 000054E3 		cmp	r4, #0
 1510 0010 7080BD08 		popeq	{r4, r5, r6, pc}
1797:../src/FreeRTOS/tasks.c **** 		{
 1511              		.loc 1 1797 0 is_stmt 0 discriminator 1
 1512 0014 003000E3 		movw	r3, #:lower16:.LANCHOR10
 1513 0018 003040E3 		movt	r3, #:upper16:.LANCHOR10
 1514 001c 003093E5 		ldr	r3, [r3]
 1515 0020 030054E1 		cmp	r4, r3
 1516 0024 7080BD08 		popeq	{r4, r5, r6, pc}
1799:../src/FreeRTOS/tasks.c **** 			{
 1517              		.loc 1 1799 0 is_stmt 1
 1518 0028 FEFFFFEB 		bl	vPortEnterCritical
 1519              	.LVL166:
1801:../src/FreeRTOS/tasks.c **** 				{
 1520              		.loc 1 1801 0
 1521 002c 0400A0E1 		mov	r0, r4
 1522 0030 FEFFFFEB 		bl	prvTaskIsTaskSuspended
 1523              	.LVL167:
 1524 0034 000050E3 		cmp	r0, #0
 1525 0038 0600001A 		bne	.L141
 1526              	.L137:
1828:../src/FreeRTOS/tasks.c **** 		}
 1527              		.loc 1 1828 0
 1528 003c FEFFFFEB 		bl	vPortExitCritical
 1529              	.LVL168:
 1530 0040 7080BDE8 		pop	{r4, r5, r6, pc}
 1531              	.LVL169:
 1532              	.L140:
1793:../src/FreeRTOS/tasks.c **** 
 1533              		.loc 1 1793 0 discriminator 1
 1534 0044 011700E3 		movw	r1, #1793
 1535 0048 000000E3 		movw	r0, #:lower16:.LC0
 1536              	.LVL170:
 1537 004c 000040E3 		movt	r0, #:upper16:.LC0
 1538 0050 FEFFFFEB 		bl	R_OS_AssertCalled
 1539              	.LVL171:
 1540 0054 ECFFFFEA 		b	.L135
 1541              	.L141:
1807:../src/FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1542              		.loc 1 1807 0
 1543 0058 045084E2 		add	r5, r4, #4
 1544 005c 0500A0E1 		mov	r0, r5
 1545 0060 FEFFFFEB 		bl	uxListRemove
 1546              	.LVL172:
1808:../src/FreeRTOS/tasks.c **** 
 1547              		.loc 1 1808 0
 1548 0064 2C3094E5 		ldr	r3, [r4, #44]
 1549 0068 002000E3 		movw	r2, #:lower16:.LANCHOR13
 1550 006c 002040E3 		movt	r2, #:upper16:.LANCHOR13
 1551 0070 002092E5 		ldr	r2, [r2]
 1552 0074 020053E1 		cmp	r3, r2
1808:../src/FreeRTOS/tasks.c **** 
 1553              		.loc 1 1808 0 is_stmt 0 discriminator 1
 1554 0078 00200083 		movwhi	r2, #:lower16:.LANCHOR13
 1555 007c 00204083 		movthi	r2, #:upper16:.LANCHOR13
 1556 0080 00308285 		strhi	r3, [r2]
 1557              	.L138:
1808:../src/FreeRTOS/tasks.c **** 
 1558              		.loc 1 1808 0 discriminator 3
 1559 0084 002000E3 		movw	r2, #:lower16:.LANCHOR4
 1560 0088 002040E3 		movt	r2, #:upper16:.LANCHOR4
 1561 008c 033183E0 		add	r3, r3, r3, lsl #2
 1562 0090 0301A0E1 		lsl	r0, r3, #2
 1563 0094 0510A0E1 		mov	r1, r5
 1564 0098 000082E0 		add	r0, r2, r0
 1565 009c FEFFFFEB 		bl	vListInsertEnd
 1566              	.LVL173:
1811:../src/FreeRTOS/tasks.c **** 					{
 1567              		.loc 1 1811 0 is_stmt 1 discriminator 3
 1568 00a0 2C2094E5 		ldr	r2, [r4, #44]
 1569 00a4 003000E3 		movw	r3, #:lower16:.LANCHOR10
 1570 00a8 003040E3 		movt	r3, #:upper16:.LANCHOR10
 1571 00ac 003093E5 		ldr	r3, [r3]
 1572 00b0 2C3093E5 		ldr	r3, [r3, #44]
 1573 00b4 030052E1 		cmp	r2, r3
 1574 00b8 DFFFFF3A 		bcc	.L137
1816:../src/FreeRTOS/tasks.c **** 					}
 1575              		.loc 1 1816 0
 1576              		.syntax divided
 1577              	@ 1816 "../src/FreeRTOS/tasks.c" 1
 1578 00bc 000000EF 		SWI 0
 1579              	@ 0 "" 2
 1580              		.arm
 1581              		.syntax unified
 1582 00c0 DDFFFFEA 		b	.L137
 1583              		.cfi_endproc
 1584              	.LFE13:
 1586              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1587              		.align	2
 1588              		.global	xTaskResumeFromISR
 1589              		.syntax unified
 1590              		.arm
 1591              		.fpu neon
 1593              	xTaskResumeFromISR:
 1594              	.LFB14:
1843:../src/FreeRTOS/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1595              		.loc 1 1843 0
 1596              		.cfi_startproc
 1597              		@ args = 0, pretend = 0, frame = 0
 1598              		@ frame_needed = 0, uses_anonymous_args = 0
 1599              	.LVL174:
 1600 0000 F0412DE9 		push	{r4, r5, r6, r7, r8, lr}
 1601              		.cfi_def_cfa_offset 24
 1602              		.cfi_offset 4, -24
 1603              		.cfi_offset 5, -20
 1604              		.cfi_offset 6, -16
 1605              		.cfi_offset 7, -12
 1606              		.cfi_offset 8, -8
 1607              		.cfi_offset 14, -4
 1608              	.LVL175:
1848:../src/FreeRTOS/tasks.c **** 
 1609              		.loc 1 1848 0
 1610 0004 004050E2 		subs	r4, r0, #0
 1611 0008 2900000A 		beq	.L151
 1612              	.LVL176:
 1613              	.L143:
1866:../src/FreeRTOS/tasks.c **** 
 1614              		.loc 1 1866 0
 1615 000c FEFFFFEB 		bl	vPortValidateInterruptPriority
 1616              	.LVL177:
1868:../src/FreeRTOS/tasks.c **** 		{
 1617              		.loc 1 1868 0
 1618 0010 FEFFFFEB 		bl	ulPortSetInterruptMask
 1619              	.LVL178:
 1620 0014 0050A0E1 		mov	r5, r0
 1621              	.LVL179:
1870:../src/FreeRTOS/tasks.c **** 			{
 1622              		.loc 1 1870 0
 1623 0018 0400A0E1 		mov	r0, r4
 1624              	.LVL180:
 1625 001c FEFFFFEB 		bl	prvTaskIsTaskSuspended
 1626              	.LVL181:
 1627 0020 000050E3 		cmp	r0, #0
 1628 0024 2F00000A 		beq	.L148
1875:../src/FreeRTOS/tasks.c **** 				{
 1629              		.loc 1 1875 0
 1630 0028 003000E3 		movw	r3, #:lower16:.LANCHOR16
 1631 002c 003040E3 		movt	r3, #:upper16:.LANCHOR16
 1632 0030 003093E5 		ldr	r3, [r3]
 1633 0034 000053E3 		cmp	r3, #0
 1634 0038 2400001A 		bne	.L145
1879:../src/FreeRTOS/tasks.c **** 					{
 1635              		.loc 1 1879 0
 1636 003c 2C2094E5 		ldr	r2, [r4, #44]
 1637 0040 003000E3 		movw	r3, #:lower16:.LANCHOR10
 1638 0044 003040E3 		movt	r3, #:upper16:.LANCHOR10
 1639 0048 003093E5 		ldr	r3, [r3]
 1640 004c 2C3093E5 		ldr	r3, [r3, #44]
 1641 0050 030052E1 		cmp	r2, r3
 1642 0054 1B00002A 		bcs	.L149
1844:../src/FreeRTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1643              		.loc 1 1844 0
 1644 0058 0060A0E3 		mov	r6, #0
 1645              	.L146:
 1646              	.LVL182:
1888:../src/FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1647              		.loc 1 1888 0
 1648 005c 047084E2 		add	r7, r4, #4
 1649 0060 0700A0E1 		mov	r0, r7
 1650 0064 FEFFFFEB 		bl	uxListRemove
 1651              	.LVL183:
1889:../src/FreeRTOS/tasks.c **** 				}
 1652              		.loc 1 1889 0
 1653 0068 2C3094E5 		ldr	r3, [r4, #44]
 1654 006c 002000E3 		movw	r2, #:lower16:.LANCHOR13
 1655 0070 002040E3 		movt	r2, #:upper16:.LANCHOR13
 1656 0074 002092E5 		ldr	r2, [r2]
 1657 0078 020053E1 		cmp	r3, r2
1889:../src/FreeRTOS/tasks.c **** 				}
 1658              		.loc 1 1889 0 is_stmt 0 discriminator 1
 1659 007c 00200083 		movwhi	r2, #:lower16:.LANCHOR13
 1660 0080 00204083 		movthi	r2, #:upper16:.LANCHOR13
 1661 0084 00308285 		strhi	r3, [r2]
 1662              	.L147:
1889:../src/FreeRTOS/tasks.c **** 				}
 1663              		.loc 1 1889 0 discriminator 3
 1664 0088 002000E3 		movw	r2, #:lower16:.LANCHOR4
 1665 008c 002040E3 		movt	r2, #:upper16:.LANCHOR4
 1666 0090 033183E0 		add	r3, r3, r3, lsl #2
 1667 0094 0301A0E1 		lsl	r0, r3, #2
 1668 0098 0710A0E1 		mov	r1, r7
 1669 009c 000082E0 		add	r0, r2, r0
 1670 00a0 FEFFFFEB 		bl	vListInsertEnd
 1671              	.LVL184:
 1672              	.L144:
1904:../src/FreeRTOS/tasks.c **** 
 1673              		.loc 1 1904 0 is_stmt 1
 1674 00a4 0500A0E1 		mov	r0, r5
 1675 00a8 FEFFFFEB 		bl	vPortClearInterruptMask
 1676              	.LVL185:
1907:../src/FreeRTOS/tasks.c **** 
 1677              		.loc 1 1907 0
 1678 00ac 0600A0E1 		mov	r0, r6
 1679 00b0 F081BDE8 		pop	{r4, r5, r6, r7, r8, pc}
 1680              	.LVL186:
 1681              	.L151:
1848:../src/FreeRTOS/tasks.c **** 
 1682              		.loc 1 1848 0 discriminator 1
 1683 00b4 381700E3 		movw	r1, #1848
 1684 00b8 000000E3 		movw	r0, #:lower16:.LC0
 1685              	.LVL187:
 1686 00bc 000040E3 		movt	r0, #:upper16:.LC0
 1687 00c0 FEFFFFEB 		bl	R_OS_AssertCalled
 1688              	.LVL188:
 1689 00c4 D0FFFFEA 		b	.L143
 1690              	.LVL189:
 1691              	.L149:
1881:../src/FreeRTOS/tasks.c **** 					}
 1692              		.loc 1 1881 0
 1693 00c8 0160A0E3 		mov	r6, #1
 1694 00cc E2FFFFEA 		b	.L146
 1695              	.L145:
1896:../src/FreeRTOS/tasks.c **** 				}
 1696              		.loc 1 1896 0
 1697 00d0 181084E2 		add	r1, r4, #24
 1698 00d4 000000E3 		movw	r0, #:lower16:.LANCHOR3
 1699 00d8 000040E3 		movt	r0, #:upper16:.LANCHOR3
 1700 00dc FEFFFFEB 		bl	vListInsertEnd
 1701              	.LVL190:
1844:../src/FreeRTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1702              		.loc 1 1844 0
 1703 00e0 0060A0E3 		mov	r6, #0
 1704 00e4 EEFFFFEA 		b	.L144
 1705              	.L148:
 1706 00e8 0060A0E3 		mov	r6, #0
 1707 00ec ECFFFFEA 		b	.L144
 1708              		.cfi_endproc
 1709              	.LFE14:
 1711              		.section	.text.vTaskStartScheduler,"ax",%progbits
 1712              		.align	2
 1713              		.global	vTaskStartScheduler
 1714              		.syntax unified
 1715              		.arm
 1716              		.fpu neon
 1718              	vTaskStartScheduler:
 1719              	.LFB15:
1913:../src/FreeRTOS/tasks.c **** BaseType_t xReturn;
 1720              		.loc 1 1913 0
 1721              		.cfi_startproc
 1722              		@ args = 0, pretend = 0, frame = 0
 1723              		@ frame_needed = 0, uses_anonymous_args = 0
 1724 0000 04E02DE5 		str	lr, [sp, #-4]!
 1725              		.cfi_def_cfa_offset 4
 1726              		.cfi_offset 14, -4
 1727 0004 0CD04DE2 		sub	sp, sp, #12
 1728              		.cfi_def_cfa_offset 16
1946:../src/FreeRTOS/tasks.c **** 								configIDLE_TASK_NAME,
 1729              		.loc 1 1946 0
 1730 0008 003000E3 		movw	r3, #:lower16:.LANCHOR17
 1731 000c 003040E3 		movt	r3, #:upper16:.LANCHOR17
 1732 0010 04308DE5 		str	r3, [sp, #4]
 1733 0014 0030A0E3 		mov	r3, #0
 1734 0018 00308DE5 		str	r3, [sp]
 1735 001c A020A0E3 		mov	r2, #160
 1736 0020 001000E3 		movw	r1, #:lower16:.LC1
 1737 0024 001040E3 		movt	r1, #:upper16:.LC1
 1738 0028 000000E3 		movw	r0, #:lower16:prvIdleTask
 1739 002c 000040E3 		movt	r0, #:upper16:prvIdleTask
 1740 0030 FEFFFFEB 		bl	xTaskCreate
 1741              	.LVL191:
1957:../src/FreeRTOS/tasks.c **** 		{
 1742              		.loc 1 1957 0
 1743 0034 010050E3 		cmp	r0, #1
 1744 0038 0500000A 		beq	.L157
 1745              	.L153:
1968:../src/FreeRTOS/tasks.c **** 	{
 1746              		.loc 1 1968 0
 1747 003c 010050E3 		cmp	r0, #1
 1748 0040 0500000A 		beq	.L158
2023:../src/FreeRTOS/tasks.c **** 	}
 1749              		.loc 1 2023 0
 1750 0044 010070E3 		cmn	r0, #1
 1751 0048 1300000A 		beq	.L159
 1752              	.LVL192:
 1753              	.L152:
2029:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 1754              		.loc 1 2029 0
 1755 004c 0CD08DE2 		add	sp, sp, #12
 1756              		.cfi_remember_state
 1757              		.cfi_def_cfa_offset 4
 1758              		@ sp needed
 1759 0050 04F09DE4 		ldr	pc, [sp], #4
 1760              	.LVL193:
 1761              	.L157:
 1762              		.cfi_restore_state
1959:../src/FreeRTOS/tasks.c **** 		}
 1763              		.loc 1 1959 0
 1764 0054 FEFFFFEB 		bl	xTimerCreateTimerTask
 1765              	.LVL194:
 1766 0058 F7FFFFEA 		b	.L153
 1767              	.L158:
1984:../src/FreeRTOS/tasks.c **** 
 1768              		.loc 1 1984 0
 1769 005c FEFFFFEB 		bl	ulPortSetInterruptMask
 1770              	.LVL195:
1994:../src/FreeRTOS/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1771              		.loc 1 1994 0
 1772 0060 003000E3 		movw	r3, #:lower16:.LANCHOR1
 1773 0064 003040E3 		movt	r3, #:upper16:.LANCHOR1
 1774 0068 0020E0E3 		mvn	r2, #0
 1775 006c 002083E5 		str	r2, [r3]
1995:../src/FreeRTOS/tasks.c **** 		xTickCount = ( TickType_t ) 0U;
 1776              		.loc 1 1995 0
 1777 0070 003000E3 		movw	r3, #:lower16:.LANCHOR11
 1778 0074 003040E3 		movt	r3, #:upper16:.LANCHOR11
 1779 0078 0120A0E3 		mov	r2, #1
 1780 007c 002083E5 		str	r2, [r3]
1996:../src/FreeRTOS/tasks.c **** 
 1781              		.loc 1 1996 0
 1782 0080 003000E3 		movw	r3, #:lower16:.LANCHOR15
 1783 0084 003040E3 		movt	r3, #:upper16:.LANCHOR15
 1784 0088 0020A0E3 		mov	r2, #0
 1785 008c 002083E5 		str	r2, [r3]
2004:../src/FreeRTOS/tasks.c **** 
 1786              		.loc 1 2004 0
 1787 0090 FEFFFFEB 		bl	vInitialiseRunTimeStats
 1788              	.LVL196:
2008:../src/FreeRTOS/tasks.c **** 		{
 1789              		.loc 1 2008 0
 1790 0094 FEFFFFEB 		bl	xPortStartScheduler
 1791              	.LVL197:
 1792 0098 EBFFFFEA 		b	.L152
 1793              	.LVL198:
 1794              	.L159:
2023:../src/FreeRTOS/tasks.c **** 	}
 1795              		.loc 1 2023 0 discriminator 1
 1796 009c E71700E3 		movw	r1, #2023
 1797 00a0 000000E3 		movw	r0, #:lower16:.LC0
 1798              	.LVL199:
 1799 00a4 000040E3 		movt	r0, #:upper16:.LC0
 1800 00a8 FEFFFFEB 		bl	R_OS_AssertCalled
 1801              	.LVL200:
2029:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 1802              		.loc 1 2029 0 discriminator 1
 1803 00ac E6FFFFEA 		b	.L152
 1804              		.cfi_endproc
 1805              	.LFE15:
 1807              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1808              		.align	2
 1809              		.global	vTaskEndScheduler
 1810              		.syntax unified
 1811              		.arm
 1812              		.fpu neon
 1814              	vTaskEndScheduler:
 1815              	.LFB16:
2033:../src/FreeRTOS/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
 1816              		.loc 1 2033 0
 1817              		.cfi_startproc
 1818              		@ args = 0, pretend = 0, frame = 0
 1819              		@ frame_needed = 0, uses_anonymous_args = 0
 1820 0000 10402DE9 		push	{r4, lr}
 1821              		.cfi_def_cfa_offset 8
 1822              		.cfi_offset 4, -8
 1823              		.cfi_offset 14, -4
2037:../src/FreeRTOS/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1824              		.loc 1 2037 0
 1825 0004 FEFFFFEB 		bl	ulPortSetInterruptMask
 1826              	.LVL201:
2038:../src/FreeRTOS/tasks.c **** 	vPortEndScheduler();
 1827              		.loc 1 2038 0
 1828 0008 003000E3 		movw	r3, #:lower16:.LANCHOR11
 1829 000c 003040E3 		movt	r3, #:upper16:.LANCHOR11
 1830 0010 0020A0E3 		mov	r2, #0
 1831 0014 002083E5 		str	r2, [r3]
2039:../src/FreeRTOS/tasks.c **** }
 1832              		.loc 1 2039 0
 1833 0018 FEFFFFEB 		bl	vPortEndScheduler
 1834              	.LVL202:
 1835 001c 1080BDE8 		pop	{r4, pc}
 1836              		.cfi_endproc
 1837              	.LFE16:
 1839              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1840              		.align	2
 1841              		.global	vTaskSuspendAll
 1842              		.syntax unified
 1843              		.arm
 1844              		.fpu neon
 1846              	vTaskSuspendAll:
 1847              	.LFB17:
2044:../src/FreeRTOS/tasks.c **** 	/* A critical section is not required as the variable is of type
 1848              		.loc 1 2044 0
 1849              		.cfi_startproc
 1850              		@ args = 0, pretend = 0, frame = 0
 1851              		@ frame_needed = 0, uses_anonymous_args = 0
 1852              		@ link register save eliminated.
2049:../src/FreeRTOS/tasks.c **** }
 1853              		.loc 1 2049 0
 1854 0000 003000E3 		movw	r3, #:lower16:.LANCHOR16
 1855 0004 003040E3 		movt	r3, #:upper16:.LANCHOR16
 1856 0008 002093E5 		ldr	r2, [r3]
 1857 000c 012082E2 		add	r2, r2, #1
 1858 0010 002083E5 		str	r2, [r3]
 1859 0014 1EFF2FE1 		bx	lr
 1860              		.cfi_endproc
 1861              	.LFE17:
 1863              		.section	.text.xTaskGetTickCount,"ax",%progbits
 1864              		.align	2
 1865              		.global	xTaskGetTickCount
 1866              		.syntax unified
 1867              		.arm
 1868              		.fpu neon
 1870              	xTaskGetTickCount:
 1871              	.LFB19:
2227:../src/FreeRTOS/tasks.c **** TickType_t xTicks;
 1872              		.loc 1 2227 0
 1873              		.cfi_startproc
 1874              		@ args = 0, pretend = 0, frame = 0
 1875              		@ frame_needed = 0, uses_anonymous_args = 0
 1876              		@ link register save eliminated.
2233:../src/FreeRTOS/tasks.c **** 	}
 1877              		.loc 1 2233 0
 1878 0000 003000E3 		movw	r3, #:lower16:.LANCHOR15
 1879 0004 003040E3 		movt	r3, #:upper16:.LANCHOR15
 1880 0008 000093E5 		ldr	r0, [r3]
 1881              	.LVL203:
2238:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 1882              		.loc 1 2238 0
 1883 000c 1EFF2FE1 		bx	lr
 1884              		.cfi_endproc
 1885              	.LFE19:
 1887              		.section	.text.xTaskGetIdleTickCount,"ax",%progbits
 1888              		.align	2
 1889              		.global	xTaskGetIdleTickCount
 1890              		.syntax unified
 1891              		.arm
 1892              		.fpu neon
 1894              	xTaskGetIdleTickCount:
 1895              	.LFB20:
2242:../src/FreeRTOS/tasks.c **** TickType_t xTicks;
 1896              		.loc 1 2242 0
 1897              		.cfi_startproc
 1898              		@ args = 0, pretend = 0, frame = 0
 1899              		@ frame_needed = 0, uses_anonymous_args = 0
 1900              		@ link register save eliminated.
2248:../src/FreeRTOS/tasks.c **** 	}
 1901              		.loc 1 2248 0
 1902 0000 003000E3 		movw	r3, #:lower16:.LANCHOR18
 1903 0004 003040E3 		movt	r3, #:upper16:.LANCHOR18
 1904 0008 000093E5 		ldr	r0, [r3]
 1905              	.LVL204:
2253:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 1906              		.loc 1 2253 0
 1907 000c 1EFF2FE1 		bx	lr
 1908              		.cfi_endproc
 1909              	.LFE20:
 1911              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1912              		.align	2
 1913              		.global	xTaskGetTickCountFromISR
 1914              		.syntax unified
 1915              		.arm
 1916              		.fpu neon
 1918              	xTaskGetTickCountFromISR:
 1919              	.LFB21:
2257:../src/FreeRTOS/tasks.c **** TickType_t xReturn;
 1920              		.loc 1 2257 0
 1921              		.cfi_startproc
 1922              		@ args = 0, pretend = 0, frame = 0
 1923              		@ frame_needed = 0, uses_anonymous_args = 0
 1924 0000 10402DE9 		push	{r4, lr}
 1925              		.cfi_def_cfa_offset 8
 1926              		.cfi_offset 4, -8
 1927              		.cfi_offset 14, -4
2275:../src/FreeRTOS/tasks.c **** 
 1928              		.loc 1 2275 0
 1929 0004 FEFFFFEB 		bl	vPortValidateInterruptPriority
 1930              	.LVL205:
2279:../src/FreeRTOS/tasks.c **** 	}
 1931              		.loc 1 2279 0
 1932 0008 003000E3 		movw	r3, #:lower16:.LANCHOR15
 1933 000c 003040E3 		movt	r3, #:upper16:.LANCHOR15
 1934 0010 000093E5 		ldr	r0, [r3]
 1935              	.LVL206:
2284:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 1936              		.loc 1 2284 0
 1937 0014 1080BDE8 		pop	{r4, pc}
 1938              		.cfi_endproc
 1939              	.LFE21:
 1941              		.section	.text.xTaskGetIdleTickCountFromISR,"ax",%progbits
 1942              		.align	2
 1943              		.global	xTaskGetIdleTickCountFromISR
 1944              		.syntax unified
 1945              		.arm
 1946              		.fpu neon
 1948              	xTaskGetIdleTickCountFromISR:
 1949              	.LFB22:
2288:../src/FreeRTOS/tasks.c **** TickType_t xReturn;
 1950              		.loc 1 2288 0
 1951              		.cfi_startproc
 1952              		@ args = 0, pretend = 0, frame = 0
 1953              		@ frame_needed = 0, uses_anonymous_args = 0
 1954 0000 10402DE9 		push	{r4, lr}
 1955              		.cfi_def_cfa_offset 8
 1956              		.cfi_offset 4, -8
 1957              		.cfi_offset 14, -4
2306:../src/FreeRTOS/tasks.c **** 
 1958              		.loc 1 2306 0
 1959 0004 FEFFFFEB 		bl	vPortValidateInterruptPriority
 1960              	.LVL207:
2310:../src/FreeRTOS/tasks.c **** 	}
 1961              		.loc 1 2310 0
 1962 0008 003000E3 		movw	r3, #:lower16:.LANCHOR18
 1963 000c 003040E3 		movt	r3, #:upper16:.LANCHOR18
 1964 0010 000093E5 		ldr	r0, [r3]
 1965              	.LVL208:
2315:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 1966              		.loc 1 2315 0
 1967 0014 1080BDE8 		pop	{r4, pc}
 1968              		.cfi_endproc
 1969              	.LFE22:
 1971              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 1972              		.align	2
 1973              		.global	uxTaskGetNumberOfTasks
 1974              		.syntax unified
 1975              		.arm
 1976              		.fpu neon
 1978              	uxTaskGetNumberOfTasks:
 1979              	.LFB23:
2319:../src/FreeRTOS/tasks.c **** 	/* A critical section is not required because the variables are of type
 1980              		.loc 1 2319 0
 1981              		.cfi_startproc
 1982              		@ args = 0, pretend = 0, frame = 0
 1983              		@ frame_needed = 0, uses_anonymous_args = 0
 1984              		@ link register save eliminated.
2322:../src/FreeRTOS/tasks.c **** }
 1985              		.loc 1 2322 0
 1986 0000 003000E3 		movw	r3, #:lower16:.LANCHOR9
 1987 0004 003040E3 		movt	r3, #:upper16:.LANCHOR9
 1988 0008 000093E5 		ldr	r0, [r3]
2323:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 1989              		.loc 1 2323 0
 1990 000c 1EFF2FE1 		bx	lr
 1991              		.cfi_endproc
 1992              	.LFE23:
 1994              		.section	.text.pcTaskGetName,"ax",%progbits
 1995              		.align	2
 1996              		.global	pcTaskGetName
 1997              		.syntax unified
 1998              		.arm
 1999              		.fpu neon
 2001              	pcTaskGetName:
 2002              	.LFB24:
2327:../src/FreeRTOS/tasks.c **** TCB_t *pxTCB;
 2003              		.loc 1 2327 0
 2004              		.cfi_startproc
 2005              		@ args = 0, pretend = 0, frame = 0
 2006              		@ frame_needed = 0, uses_anonymous_args = 0
 2007              	.LVL209:
 2008 0000 10402DE9 		push	{r4, lr}
 2009              		.cfi_def_cfa_offset 8
 2010              		.cfi_offset 4, -8
 2011              		.cfi_offset 14, -4
2332:../src/FreeRTOS/tasks.c **** 	configASSERT( pxTCB );
 2012              		.loc 1 2332 0
 2013 0004 004050E2 		subs	r4, r0, #0
 2014 0008 0300000A 		beq	.L175
 2015              	.L171:
 2016              	.LVL210:
2333:../src/FreeRTOS/tasks.c **** 	return &( pxTCB->pcTaskName[ 0 ] );
 2017              		.loc 1 2333 0 discriminator 4
 2018 000c 000054E3 		cmp	r4, #0
 2019 0010 0500000A 		beq	.L176
 2020              	.LVL211:
 2021              	.L172:
2335:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 2022              		.loc 1 2335 0
 2023 0014 340084E2 		add	r0, r4, #52
 2024 0018 1080BDE8 		pop	{r4, pc}
 2025              	.LVL212:
 2026              	.L175:
2332:../src/FreeRTOS/tasks.c **** 	configASSERT( pxTCB );
 2027              		.loc 1 2332 0 discriminator 1
 2028 001c 003000E3 		movw	r3, #:lower16:.LANCHOR10
 2029 0020 003040E3 		movt	r3, #:upper16:.LANCHOR10
 2030 0024 004093E5 		ldr	r4, [r3]
 2031 0028 F7FFFFEA 		b	.L171
 2032              	.LVL213:
 2033              	.L176:
2333:../src/FreeRTOS/tasks.c **** 	return &( pxTCB->pcTaskName[ 0 ] );
 2034              		.loc 1 2333 0 discriminator 1
 2035 002c 1D1900E3 		movw	r1, #2333
 2036 0030 000000E3 		movw	r0, #:lower16:.LC0
 2037              	.LVL214:
 2038 0034 000040E3 		movt	r0, #:upper16:.LC0
 2039 0038 FEFFFFEB 		bl	R_OS_AssertCalled
 2040              	.LVL215:
 2041 003c F4FFFFEA 		b	.L172
 2042              		.cfi_endproc
 2043              	.LFE24:
 2045              		.section	.text.xTaskIncrementTick,"ax",%progbits
 2046              		.align	2
 2047              		.global	xTaskIncrementTick
 2048              		.syntax unified
 2049              		.arm
 2050              		.fpu neon
 2052              	xTaskIncrementTick:
 2053              	.LFB27:
2647:../src/FreeRTOS/tasks.c **** TCB_t * pxTCB;
 2054              		.loc 1 2647 0
 2055              		.cfi_startproc
 2056              		@ args = 0, pretend = 0, frame = 0
 2057              		@ frame_needed = 0, uses_anonymous_args = 0
 2058 0000 F0412DE9 		push	{r4, r5, r6, r7, r8, lr}
 2059              		.cfi_def_cfa_offset 24
 2060              		.cfi_offset 4, -24
 2061              		.cfi_offset 5, -20
 2062              		.cfi_offset 6, -16
 2063              		.cfi_offset 7, -12
 2064              		.cfi_offset 8, -8
 2065              		.cfi_offset 14, -4
 2066              	.LVL216:
2656:../src/FreeRTOS/tasks.c **** 	{
 2067              		.loc 1 2656 0
 2068 0004 003000E3 		movw	r3, #:lower16:.LANCHOR16
 2069 0008 003040E3 		movt	r3, #:upper16:.LANCHOR16
 2070 000c 003093E5 		ldr	r3, [r3]
 2071 0010 000053E3 		cmp	r3, #0
 2072 0014 6F00001A 		bne	.L178
 2073              	.LBB5:
2660:../src/FreeRTOS/tasks.c **** 
 2074              		.loc 1 2660 0
 2075 0018 003000E3 		movw	r3, #:lower16:.LANCHOR15
 2076 001c 003040E3 		movt	r3, #:upper16:.LANCHOR15
 2077 0020 005093E5 		ldr	r5, [r3]
 2078 0024 015085E2 		add	r5, r5, #1
 2079              	.LVL217:
2664:../src/FreeRTOS/tasks.c **** 
 2080              		.loc 1 2664 0
 2081 0028 005083E5 		str	r5, [r3]
2666:../src/FreeRTOS/tasks.c **** 		{
 2082              		.loc 1 2666 0
 2083 002c 000055E3 		cmp	r5, #0
 2084 0030 1300001A 		bne	.L179
 2085              	.LBB6:
2668:../src/FreeRTOS/tasks.c **** 		}
 2086              		.loc 1 2668 0
 2087 0034 003000E3 		movw	r3, #:lower16:.LANCHOR0
 2088 0038 003040E3 		movt	r3, #:upper16:.LANCHOR0
 2089 003c 003093E5 		ldr	r3, [r3]
 2090 0040 003093E5 		ldr	r3, [r3]
 2091 0044 000053E3 		cmp	r3, #0
 2092 0048 1F00001A 		bne	.L198
 2093              	.L180:
2668:../src/FreeRTOS/tasks.c **** 		}
 2094              		.loc 1 2668 0 is_stmt 0 discriminator 3
 2095 004c 002000E3 		movw	r2, #:lower16:.LANCHOR0
 2096 0050 002040E3 		movt	r2, #:upper16:.LANCHOR0
 2097 0054 001092E5 		ldr	r1, [r2]
 2098              	.LVL218:
 2099 0058 003000E3 		movw	r3, #:lower16:.LANCHOR8
 2100 005c 003040E3 		movt	r3, #:upper16:.LANCHOR8
 2101 0060 000093E5 		ldr	r0, [r3]
 2102 0064 000082E5 		str	r0, [r2]
 2103 0068 001083E5 		str	r1, [r3]
 2104 006c 003000E3 		movw	r3, #:lower16:.LANCHOR19
 2105 0070 003040E3 		movt	r3, #:upper16:.LANCHOR19
 2106 0074 002093E5 		ldr	r2, [r3]
 2107 0078 012082E2 		add	r2, r2, #1
 2108 007c 002083E5 		str	r2, [r3]
 2109 0080 FEFFFFEB 		bl	prvResetNextTaskUnblockTime
 2110              	.LVL219:
 2111              	.L179:
 2112              	.LBE6:
2679:../src/FreeRTOS/tasks.c **** 		{
 2113              		.loc 1 2679 0 is_stmt 1
 2114 0084 003000E3 		movw	r3, #:lower16:.LANCHOR1
 2115 0088 003040E3 		movt	r3, #:upper16:.LANCHOR1
 2116 008c 003093E5 		ldr	r3, [r3]
 2117 0090 030055E1 		cmp	r5, r3
 2118 0094 4200002A 		bcs	.L192
 2119              	.LBE5:
2650:../src/FreeRTOS/tasks.c **** 
 2120              		.loc 1 2650 0
 2121 0098 0060A0E3 		mov	r6, #0
 2122              	.LVL220:
 2123              	.L182:
 2124              	.LBB8:
2762:../src/FreeRTOS/tasks.c **** 			{
 2125              		.loc 1 2762 0
 2126 009c 003000E3 		movw	r3, #:lower16:.LANCHOR10
 2127 00a0 003040E3 		movt	r3, #:upper16:.LANCHOR10
 2128 00a4 003093E5 		ldr	r3, [r3]
 2129 00a8 2C3093E5 		ldr	r3, [r3, #44]
 2130 00ac 002000E3 		movw	r2, #:lower16:.LANCHOR4
 2131 00b0 002040E3 		movt	r2, #:upper16:.LANCHOR4
 2132 00b4 033183E0 		add	r3, r3, r3, lsl #2
 2133 00b8 0311A0E1 		lsl	r1, r3, #2
 2134 00bc 013092E7 		ldr	r3, [r2, r1]
 2135 00c0 010053E3 		cmp	r3, #1
2764:../src/FreeRTOS/tasks.c **** 			}
 2136              		.loc 1 2764 0
 2137 00c4 0160A083 		movhi	r6, #1
 2138              	.LVL221:
 2139 00c8 480000EA 		b	.L190
 2140              	.LVL222:
 2141              	.L198:
 2142              	.LBB7:
2668:../src/FreeRTOS/tasks.c **** 		}
 2143              		.loc 1 2668 0 discriminator 1
 2144 00cc 6C1A00E3 		movw	r1, #2668
 2145 00d0 000000E3 		movw	r0, #:lower16:.LC0
 2146 00d4 000040E3 		movt	r0, #:upper16:.LC0
 2147 00d8 FEFFFFEB 		bl	R_OS_AssertCalled
 2148              	.LVL223:
 2149 00dc DAFFFFEA 		b	.L180
 2150              	.LVL224:
 2151              	.L194:
 2152              	.LBE7:
2745:../src/FreeRTOS/tasks.c **** 						}
 2153              		.loc 1 2745 0
 2154 00e0 0160A0E3 		mov	r6, #1
 2155              	.LVL225:
 2156              	.L181:
2683:../src/FreeRTOS/tasks.c **** 				{
 2157              		.loc 1 2683 0
 2158 00e4 003000E3 		movw	r3, #:lower16:.LANCHOR0
 2159 00e8 003040E3 		movt	r3, #:upper16:.LANCHOR0
 2160 00ec 003093E5 		ldr	r3, [r3]
 2161 00f0 003093E5 		ldr	r3, [r3]
 2162 00f4 000053E3 		cmp	r3, #0
 2163 00f8 2B00000A 		beq	.L199
 2164 00fc 0030A0E3 		mov	r3, #0
 2165              	.L183:
2683:../src/FreeRTOS/tasks.c **** 				{
 2166              		.loc 1 2683 0 is_stmt 0 discriminator 4
 2167 0100 000053E3 		cmp	r3, #0
 2168 0104 2A00001A 		bne	.L200
2699:../src/FreeRTOS/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 2169              		.loc 1 2699 0 is_stmt 1
 2170 0108 003000E3 		movw	r3, #:lower16:.LANCHOR0
 2171 010c 003040E3 		movt	r3, #:upper16:.LANCHOR0
 2172 0110 003093E5 		ldr	r3, [r3]
 2173 0114 0C3093E5 		ldr	r3, [r3, #12]
 2174 0118 0C4093E5 		ldr	r4, [r3, #12]
 2175              	.LVL226:
2700:../src/FreeRTOS/tasks.c **** 
 2176              		.loc 1 2700 0
 2177 011c 043094E5 		ldr	r3, [r4, #4]
 2178              	.LVL227:
2702:../src/FreeRTOS/tasks.c **** 					{
 2179              		.loc 1 2702 0
 2180 0120 030055E1 		cmp	r5, r3
 2181 0124 2700003A 		bcc	.L201
2718:../src/FreeRTOS/tasks.c **** 
 2182              		.loc 1 2718 0
 2183 0128 047084E2 		add	r7, r4, #4
 2184 012c 0700A0E1 		mov	r0, r7
 2185 0130 FEFFFFEB 		bl	uxListRemove
 2186              	.LVL228:
2722:../src/FreeRTOS/tasks.c **** 					{
 2187              		.loc 1 2722 0
 2188 0134 283094E5 		ldr	r3, [r4, #40]
 2189 0138 000053E3 		cmp	r3, #0
 2190 013c 0100000A 		beq	.L186
2724:../src/FreeRTOS/tasks.c **** 					}
 2191              		.loc 1 2724 0
 2192 0140 180084E2 		add	r0, r4, #24
 2193 0144 FEFFFFEB 		bl	uxListRemove
 2194              	.LVL229:
 2195              	.L186:
2733:../src/FreeRTOS/tasks.c **** 
 2196              		.loc 1 2733 0
 2197 0148 2C3094E5 		ldr	r3, [r4, #44]
 2198 014c 002000E3 		movw	r2, #:lower16:.LANCHOR13
 2199 0150 002040E3 		movt	r2, #:upper16:.LANCHOR13
 2200 0154 002092E5 		ldr	r2, [r2]
 2201 0158 020053E1 		cmp	r3, r2
2733:../src/FreeRTOS/tasks.c **** 
 2202              		.loc 1 2733 0 is_stmt 0 discriminator 1
 2203 015c 00200083 		movwhi	r2, #:lower16:.LANCHOR13
 2204 0160 00204083 		movthi	r2, #:upper16:.LANCHOR13
 2205 0164 00308285 		strhi	r3, [r2]
 2206              	.L187:
2733:../src/FreeRTOS/tasks.c **** 
 2207              		.loc 1 2733 0 discriminator 3
 2208 0168 002000E3 		movw	r2, #:lower16:.LANCHOR4
 2209 016c 002040E3 		movt	r2, #:upper16:.LANCHOR4
 2210 0170 033183E0 		add	r3, r3, r3, lsl #2
 2211 0174 0301A0E1 		lsl	r0, r3, #2
 2212 0178 0710A0E1 		mov	r1, r7
 2213 017c 000082E0 		add	r0, r2, r0
 2214 0180 FEFFFFEB 		bl	vListInsertEnd
 2215              	.LVL230:
2743:../src/FreeRTOS/tasks.c **** 						{
 2216              		.loc 1 2743 0 is_stmt 1 discriminator 3
 2217 0184 2C2094E5 		ldr	r2, [r4, #44]
 2218 0188 003000E3 		movw	r3, #:lower16:.LANCHOR10
 2219 018c 003040E3 		movt	r3, #:upper16:.LANCHOR10
 2220 0190 003093E5 		ldr	r3, [r3]
 2221 0194 2C3093E5 		ldr	r3, [r3, #44]
 2222 0198 030052E1 		cmp	r2, r3
 2223 019c CFFFFF2A 		bcs	.L194
 2224 01a0 CFFFFFEA 		b	.L181
 2225              	.LVL231:
 2226              	.L192:
 2227 01a4 0060A0E3 		mov	r6, #0
 2228 01a8 CDFFFFEA 		b	.L181
 2229              	.LVL232:
 2230              	.L199:
2683:../src/FreeRTOS/tasks.c **** 				{
 2231              		.loc 1 2683 0
 2232 01ac 0130A0E3 		mov	r3, #1
 2233 01b0 D2FFFFEA 		b	.L183
 2234              	.L200:
2690:../src/FreeRTOS/tasks.c **** 					break;
 2235              		.loc 1 2690 0
 2236 01b4 003000E3 		movw	r3, #:lower16:.LANCHOR1
 2237 01b8 003040E3 		movt	r3, #:upper16:.LANCHOR1
 2238 01bc 0020E0E3 		mvn	r2, #0
 2239 01c0 002083E5 		str	r2, [r3]
2691:../src/FreeRTOS/tasks.c **** 				}
 2240              		.loc 1 2691 0
 2241 01c4 B4FFFFEA 		b	.L182
 2242              	.LVL233:
 2243              	.L201:
2709:../src/FreeRTOS/tasks.c **** 						break;
 2244              		.loc 1 2709 0
 2245 01c8 002000E3 		movw	r2, #:lower16:.LANCHOR1
 2246 01cc 002040E3 		movt	r2, #:upper16:.LANCHOR1
 2247 01d0 003082E5 		str	r3, [r2]
2710:../src/FreeRTOS/tasks.c **** 					}
 2248              		.loc 1 2710 0
 2249 01d4 B0FFFFEA 		b	.L182
 2250              	.LVL234:
 2251              	.L178:
 2252              	.LBE8:
2790:../src/FreeRTOS/tasks.c **** 
 2253              		.loc 1 2790 0
 2254 01d8 003000E3 		movw	r3, #:lower16:.LANCHOR20
 2255 01dc 003040E3 		movt	r3, #:upper16:.LANCHOR20
 2256 01e0 002093E5 		ldr	r2, [r3]
 2257 01e4 012082E2 		add	r2, r2, #1
 2258 01e8 002083E5 		str	r2, [r3]
2650:../src/FreeRTOS/tasks.c **** 
 2259              		.loc 1 2650 0
 2260 01ec 0060A0E3 		mov	r6, #0
 2261              	.LVL235:
 2262              	.L190:
2803:../src/FreeRTOS/tasks.c **** 		{
 2263              		.loc 1 2803 0
 2264 01f0 003000E3 		movw	r3, #:lower16:.LANCHOR21
 2265 01f4 003040E3 		movt	r3, #:upper16:.LANCHOR21
 2266 01f8 003093E5 		ldr	r3, [r3]
 2267 01fc 000053E3 		cmp	r3, #0
2805:../src/FreeRTOS/tasks.c **** 		}
 2268              		.loc 1 2805 0
 2269 0200 0160A013 		movne	r6, #1
 2270              	.LVL236:
 2271              	.L177:
2815:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 2272              		.loc 1 2815 0
 2273 0204 0600A0E1 		mov	r0, r6
 2274 0208 F081BDE8 		pop	{r4, r5, r6, r7, r8, pc}
 2275              		.cfi_endproc
 2276              	.LFE27:
 2278              		.section	.text.xTaskResumeAll,"ax",%progbits
 2279              		.align	2
 2280              		.global	xTaskResumeAll
 2281              		.syntax unified
 2282              		.arm
 2283              		.fpu neon
 2285              	xTaskResumeAll:
 2286              	.LFB18:
2117:../src/FreeRTOS/tasks.c **** TCB_t *pxTCB = NULL;
 2287              		.loc 1 2117 0
 2288              		.cfi_startproc
 2289              		@ args = 0, pretend = 0, frame = 0
 2290              		@ frame_needed = 0, uses_anonymous_args = 0
 2291 0000 70402DE9 		push	{r4, r5, r6, lr}
 2292              		.cfi_def_cfa_offset 16
 2293              		.cfi_offset 4, -16
 2294              		.cfi_offset 5, -12
 2295              		.cfi_offset 6, -8
 2296              		.cfi_offset 14, -4
 2297              	.LVL237:
2123:../src/FreeRTOS/tasks.c **** 
 2298              		.loc 1 2123 0
 2299 0004 003000E3 		movw	r3, #:lower16:.LANCHOR16
 2300 0008 003040E3 		movt	r3, #:upper16:.LANCHOR16
 2301 000c 003093E5 		ldr	r3, [r3]
 2302 0010 000053E3 		cmp	r3, #0
 2303 0014 3600000A 		beq	.L217
 2304              	.L203:
2130:../src/FreeRTOS/tasks.c **** 	{
 2305              		.loc 1 2130 0
 2306 0018 FEFFFFEB 		bl	vPortEnterCritical
 2307              	.LVL238:
2132:../src/FreeRTOS/tasks.c **** 
 2308              		.loc 1 2132 0
 2309 001c 003000E3 		movw	r3, #:lower16:.LANCHOR16
 2310 0020 003040E3 		movt	r3, #:upper16:.LANCHOR16
 2311 0024 002093E5 		ldr	r2, [r3]
 2312 0028 012042E2 		sub	r2, r2, #1
 2313 002c 002083E5 		str	r2, [r3]
2134:../src/FreeRTOS/tasks.c **** 		{
 2314              		.loc 1 2134 0
 2315 0030 003093E5 		ldr	r3, [r3]
 2316 0034 000053E3 		cmp	r3, #0
 2317 0038 5200001A 		bne	.L213
2136:../src/FreeRTOS/tasks.c **** 			{
 2318              		.loc 1 2136 0
 2319 003c 003000E3 		movw	r3, #:lower16:.LANCHOR9
 2320 0040 003040E3 		movt	r3, #:upper16:.LANCHOR9
 2321 0044 003093E5 		ldr	r3, [r3]
 2322 0048 000053E3 		cmp	r3, #0
 2323 004c 2D00000A 		beq	.L218
 2324 0050 0040A0E3 		mov	r4, #0
 2325              	.LVL239:
 2326              	.L205:
2140:../src/FreeRTOS/tasks.c **** 				{
 2327              		.loc 1 2140 0
 2328 0054 003000E3 		movw	r3, #:lower16:.LANCHOR3
 2329 0058 003040E3 		movt	r3, #:upper16:.LANCHOR3
 2330 005c 003093E5 		ldr	r3, [r3]
 2331 0060 000053E3 		cmp	r3, #0
 2332 0064 2900000A 		beq	.L219
2142:../src/FreeRTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 2333              		.loc 1 2142 0
 2334 0068 003000E3 		movw	r3, #:lower16:.LANCHOR3
 2335 006c 003040E3 		movt	r3, #:upper16:.LANCHOR3
 2336 0070 0C3093E5 		ldr	r3, [r3, #12]
 2337 0074 0C4093E5 		ldr	r4, [r3, #12]
 2338              	.LVL240:
2143:../src/FreeRTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2339              		.loc 1 2143 0
 2340 0078 180084E2 		add	r0, r4, #24
 2341 007c FEFFFFEB 		bl	uxListRemove
 2342              	.LVL241:
2144:../src/FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 2343              		.loc 1 2144 0
 2344 0080 045084E2 		add	r5, r4, #4
 2345 0084 0500A0E1 		mov	r0, r5
 2346 0088 FEFFFFEB 		bl	uxListRemove
 2347              	.LVL242:
2145:../src/FreeRTOS/tasks.c **** 
 2348              		.loc 1 2145 0
 2349 008c 2C3094E5 		ldr	r3, [r4, #44]
 2350 0090 002000E3 		movw	r2, #:lower16:.LANCHOR13
 2351 0094 002040E3 		movt	r2, #:upper16:.LANCHOR13
 2352 0098 002092E5 		ldr	r2, [r2]
 2353 009c 020053E1 		cmp	r3, r2
2145:../src/FreeRTOS/tasks.c **** 
 2354              		.loc 1 2145 0 is_stmt 0 discriminator 1
 2355 00a0 00200083 		movwhi	r2, #:lower16:.LANCHOR13
 2356 00a4 00204083 		movthi	r2, #:upper16:.LANCHOR13
 2357 00a8 00308285 		strhi	r3, [r2]
 2358              	.L206:
2145:../src/FreeRTOS/tasks.c **** 
 2359              		.loc 1 2145 0 discriminator 3
 2360 00ac 002000E3 		movw	r2, #:lower16:.LANCHOR4
 2361 00b0 002040E3 		movt	r2, #:upper16:.LANCHOR4
 2362 00b4 033183E0 		add	r3, r3, r3, lsl #2
 2363 00b8 0301A0E1 		lsl	r0, r3, #2
 2364 00bc 0510A0E1 		mov	r1, r5
 2365 00c0 000082E0 		add	r0, r2, r0
 2366 00c4 FEFFFFEB 		bl	vListInsertEnd
 2367              	.LVL243:
2149:../src/FreeRTOS/tasks.c **** 					{
 2368              		.loc 1 2149 0 is_stmt 1 discriminator 3
 2369 00c8 2C2094E5 		ldr	r2, [r4, #44]
 2370 00cc 003000E3 		movw	r3, #:lower16:.LANCHOR10
 2371 00d0 003040E3 		movt	r3, #:upper16:.LANCHOR10
 2372 00d4 003093E5 		ldr	r3, [r3]
 2373 00d8 2C3093E5 		ldr	r3, [r3, #44]
 2374 00dc 030052E1 		cmp	r2, r3
2151:../src/FreeRTOS/tasks.c **** 					}
 2375              		.loc 1 2151 0
 2376 00e0 00300023 		movwcs	r3, #:lower16:.LANCHOR21
 2377 00e4 00304023 		movtcs	r3, #:upper16:.LANCHOR21
 2378 00e8 0120A023 		movcs	r2, #1
 2379 00ec 00208325 		strcs	r2, [r3]
 2380 00f0 D7FFFFEA 		b	.L205
 2381              	.LVL244:
 2382              	.L217:
2123:../src/FreeRTOS/tasks.c **** 
 2383              		.loc 1 2123 0 discriminator 1
 2384 00f4 4B1800E3 		movw	r1, #2123
 2385 00f8 000000E3 		movw	r0, #:lower16:.LC0
 2386 00fc 000040E3 		movt	r0, #:upper16:.LC0
 2387 0100 FEFFFFEB 		bl	R_OS_AssertCalled
 2388              	.LVL245:
 2389 0104 C3FFFFEA 		b	.L203
 2390              	.L218:
2119:../src/FreeRTOS/tasks.c **** 
 2391              		.loc 1 2119 0
 2392 0108 0040A0E3 		mov	r4, #0
 2393 010c 1E0000EA 		b	.L204
 2394              	.LVL246:
 2395              	.L219:
2159:../src/FreeRTOS/tasks.c **** 				{
 2396              		.loc 1 2159 0
 2397 0110 000054E3 		cmp	r4, #0
 2398 0114 0000000A 		beq	.L209
2167:../src/FreeRTOS/tasks.c **** 				}
 2399              		.loc 1 2167 0
 2400 0118 FEFFFFEB 		bl	prvResetNextTaskUnblockTime
 2401              	.LVL247:
 2402              	.L209:
 2403              	.LBB9:
2175:../src/FreeRTOS/tasks.c **** 
 2404              		.loc 1 2175 0
 2405 011c 003000E3 		movw	r3, #:lower16:.LANCHOR20
 2406 0120 003040E3 		movt	r3, #:upper16:.LANCHOR20
 2407 0124 004093E5 		ldr	r4, [r3]
 2408              	.LVL248:
2177:../src/FreeRTOS/tasks.c **** 					{
 2409              		.loc 1 2177 0
 2410 0128 000054E3 		cmp	r4, #0
 2411 012c 0900001A 		bne	.L212
 2412              	.L210:
 2413              	.LBE9:
2200:../src/FreeRTOS/tasks.c **** 				{
 2414              		.loc 1 2200 0
 2415 0130 003000E3 		movw	r3, #:lower16:.LANCHOR21
 2416 0134 003040E3 		movt	r3, #:upper16:.LANCHOR21
 2417 0138 003093E5 		ldr	r3, [r3]
 2418 013c 000053E3 		cmp	r3, #0
 2419 0140 1400000A 		beq	.L215
 2420              	.LVL249:
2207:../src/FreeRTOS/tasks.c **** 				}
 2421              		.loc 1 2207 0
 2422              		.syntax divided
 2423              	@ 2207 "../src/FreeRTOS/tasks.c" 1
 2424 0144 000000EF 		SWI 0
 2425              	@ 0 "" 2
2204:../src/FreeRTOS/tasks.c **** 					}
 2426              		.loc 1 2204 0
 2427              		.arm
 2428              		.syntax unified
 2429 0148 0140A0E3 		mov	r4, #1
 2430              	.LVL250:
 2431 014c 0E0000EA 		b	.L204
 2432              	.LVL251:
 2433              	.L211:
 2434              	.LBB10:
2190:../src/FreeRTOS/tasks.c **** 
 2435              		.loc 1 2190 0
 2436 0150 014054E2 		subs	r4, r4, #1
 2437              	.LVL252:
 2438 0154 0600000A 		beq	.L220
 2439              	.L212:
2181:../src/FreeRTOS/tasks.c **** 							{
 2440              		.loc 1 2181 0
 2441 0158 FEFFFFEB 		bl	xTaskIncrementTick
 2442              	.LVL253:
 2443 015c 000050E3 		cmp	r0, #0
2183:../src/FreeRTOS/tasks.c **** 							}
 2444              		.loc 1 2183 0
 2445 0160 00300013 		movwne	r3, #:lower16:.LANCHOR21
 2446 0164 00304013 		movtne	r3, #:upper16:.LANCHOR21
 2447 0168 0120A013 		movne	r2, #1
 2448 016c 00208315 		strne	r2, [r3]
 2449 0170 F6FFFFEA 		b	.L211
 2450              	.L220:
2192:../src/FreeRTOS/tasks.c **** 					}
 2451              		.loc 1 2192 0
 2452 0174 003000E3 		movw	r3, #:lower16:.LANCHOR20
 2453 0178 003040E3 		movt	r3, #:upper16:.LANCHOR20
 2454 017c 0020A0E3 		mov	r2, #0
 2455 0180 002083E5 		str	r2, [r3]
 2456 0184 E9FFFFEA 		b	.L210
 2457              	.LVL254:
 2458              	.L213:
 2459              	.LBE10:
2119:../src/FreeRTOS/tasks.c **** 
 2460              		.loc 1 2119 0
 2461 0188 0040A0E3 		mov	r4, #0
 2462              	.LVL255:
 2463              	.L204:
2220:../src/FreeRTOS/tasks.c **** 
 2464              		.loc 1 2220 0
 2465 018c FEFFFFEB 		bl	vPortExitCritical
 2466              	.LVL256:
2223:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 2467              		.loc 1 2223 0
 2468 0190 0400A0E1 		mov	r0, r4
 2469 0194 7080BDE8 		pop	{r4, r5, r6, pc}
 2470              	.LVL257:
 2471              	.L215:
2119:../src/FreeRTOS/tasks.c **** 
 2472              		.loc 1 2119 0
 2473 0198 0040A0E3 		mov	r4, #0
 2474              	.LVL258:
 2475 019c FAFFFFEA 		b	.L204
 2476              		.cfi_endproc
 2477              	.LFE18:
 2479              		.section	.text.vTaskDelayUntil,"ax",%progbits
 2480              		.align	2
 2481              		.global	vTaskDelayUntil
 2482              		.syntax unified
 2483              		.arm
 2484              		.fpu neon
 2486              	vTaskDelayUntil:
 2487              	.LFB5:
1216:../src/FreeRTOS/tasks.c **** 	TickType_t xTimeToWake;
 2488              		.loc 1 1216 0
 2489              		.cfi_startproc
 2490              		@ args = 0, pretend = 0, frame = 0
 2491              		@ frame_needed = 0, uses_anonymous_args = 0
 2492              	.LVL259:
 2493 0000 70402DE9 		push	{r4, r5, r6, lr}
 2494              		.cfi_def_cfa_offset 16
 2495              		.cfi_offset 4, -16
 2496              		.cfi_offset 5, -12
 2497              		.cfi_offset 6, -8
 2498              		.cfi_offset 14, -4
 2499 0004 0140A0E1 		mov	r4, r1
 2500              	.LVL260:
1220:../src/FreeRTOS/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 2501              		.loc 1 1220 0
 2502 0008 005050E2 		subs	r5, r0, #0
 2503 000c 1400000A 		beq	.L234
 2504              	.LVL261:
 2505              	.L222:
1221:../src/FreeRTOS/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
 2506              		.loc 1 1221 0
 2507 0010 000054E3 		cmp	r4, #0
 2508 0014 1700000A 		beq	.L235
 2509              	.L223:
1222:../src/FreeRTOS/tasks.c **** 
 2510              		.loc 1 1222 0
 2511 0018 003000E3 		movw	r3, #:lower16:.LANCHOR16
 2512 001c 003040E3 		movt	r3, #:upper16:.LANCHOR16
 2513 0020 003093E5 		ldr	r3, [r3]
 2514 0024 000053E3 		cmp	r3, #0
 2515 0028 1700001A 		bne	.L236
 2516              	.L224:
1224:../src/FreeRTOS/tasks.c **** 		{
 2517              		.loc 1 1224 0
 2518 002c FEFFFFEB 		bl	vTaskSuspendAll
 2519              	.LVL262:
 2520              	.LBB11:
1228:../src/FreeRTOS/tasks.c **** 
 2521              		.loc 1 1228 0
 2522 0030 003000E3 		movw	r3, #:lower16:.LANCHOR15
 2523 0034 003040E3 		movt	r3, #:upper16:.LANCHOR15
 2524 0038 000093E5 		ldr	r0, [r3]
 2525              	.LVL263:
1231:../src/FreeRTOS/tasks.c **** 
 2526              		.loc 1 1231 0
 2527 003c 002095E5 		ldr	r2, [r5]
 2528 0040 024084E0 		add	r4, r4, r2
 2529              	.LVL264:
1233:../src/FreeRTOS/tasks.c **** 			{
 2530              		.loc 1 1233 0
 2531 0044 020050E1 		cmp	r0, r2
 2532 0048 1400002A 		bcs	.L225
1240:../src/FreeRTOS/tasks.c **** 				{
 2533              		.loc 1 1240 0
 2534 004c 040052E1 		cmp	r2, r4
 2535 0050 1800009A 		bls	.L229
1240:../src/FreeRTOS/tasks.c **** 				{
 2536              		.loc 1 1240 0 is_stmt 0 discriminator 1
 2537 0054 040050E1 		cmp	r0, r4
 2538 0058 1F00003A 		bcc	.L230
 2539              	.LBE11:
1218:../src/FreeRTOS/tasks.c **** 
 2540              		.loc 1 1218 0 is_stmt 1
 2541 005c 0020A0E3 		mov	r2, #0
 2542 0060 150000EA 		b	.L226
 2543              	.LVL265:
 2544              	.L234:
1220:../src/FreeRTOS/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 2545              		.loc 1 1220 0 discriminator 1
 2546 0064 C41400E3 		movw	r1, #1220
 2547              	.LVL266:
 2548 0068 000000E3 		movw	r0, #:lower16:.LC0
 2549              	.LVL267:
 2550 006c 000040E3 		movt	r0, #:upper16:.LC0
 2551 0070 FEFFFFEB 		bl	R_OS_AssertCalled
 2552              	.LVL268:
 2553 0074 E5FFFFEA 		b	.L222
 2554              	.L235:
1221:../src/FreeRTOS/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
 2555              		.loc 1 1221 0 discriminator 1
 2556 0078 C51400E3 		movw	r1, #1221
 2557 007c 000000E3 		movw	r0, #:lower16:.LC0
 2558 0080 000040E3 		movt	r0, #:upper16:.LC0
 2559 0084 FEFFFFEB 		bl	R_OS_AssertCalled
 2560              	.LVL269:
 2561 0088 E2FFFFEA 		b	.L223
 2562              	.L236:
1222:../src/FreeRTOS/tasks.c **** 
 2563              		.loc 1 1222 0 discriminator 1
 2564 008c C61400E3 		movw	r1, #1222
 2565 0090 000000E3 		movw	r0, #:lower16:.LC0
 2566 0094 000040E3 		movt	r0, #:upper16:.LC0
 2567 0098 FEFFFFEB 		bl	R_OS_AssertCalled
 2568              	.LVL270:
 2569 009c E2FFFFEA 		b	.L224
 2570              	.LVL271:
 2571              	.L225:
 2572              	.LBB12:
1254:../src/FreeRTOS/tasks.c **** 				{
 2573              		.loc 1 1254 0
 2574 00a0 040052E1 		cmp	r2, r4
 2575 00a4 0E00008A 		bhi	.L231
1254:../src/FreeRTOS/tasks.c **** 				{
 2576              		.loc 1 1254 0 is_stmt 0 discriminator 1
 2577 00a8 040050E1 		cmp	r0, r4
 2578 00ac 0E00003A 		bcc	.L232
 2579              	.LBE12:
1218:../src/FreeRTOS/tasks.c **** 
 2580              		.loc 1 1218 0 is_stmt 1
 2581 00b0 0020A0E3 		mov	r2, #0
 2582 00b4 000000EA 		b	.L226
 2583              	.L229:
 2584 00b8 0020A0E3 		mov	r2, #0
 2585              	.L226:
 2586              	.LVL272:
 2587              	.LBB13:
1265:../src/FreeRTOS/tasks.c **** 
 2588              		.loc 1 1265 0
 2589 00bc 004085E5 		str	r4, [r5]
1267:../src/FreeRTOS/tasks.c **** 			{
 2590              		.loc 1 1267 0
 2591 00c0 000052E3 		cmp	r2, #0
 2592 00c4 0A00001A 		bne	.L237
 2593              	.LVL273:
 2594              	.L227:
 2595              	.LBE13:
1280:../src/FreeRTOS/tasks.c **** 
 2596              		.loc 1 1280 0
 2597 00c8 FEFFFFEB 		bl	xTaskResumeAll
 2598              	.LVL274:
1284:../src/FreeRTOS/tasks.c **** 		{
 2599              		.loc 1 1284 0
 2600 00cc 000050E3 		cmp	r0, #0
 2601 00d0 7080BD18 		popne	{r4, r5, r6, pc}
1286:../src/FreeRTOS/tasks.c **** 		}
 2602              		.loc 1 1286 0
 2603              		.syntax divided
 2604              	@ 1286 "../src/FreeRTOS/tasks.c" 1
 2605 00d4 000000EF 		SWI 0
 2606              	@ 0 "" 2
 2607              		.arm
 2608              		.syntax unified
 2609 00d8 7080BDE8 		pop	{r4, r5, r6, pc}
 2610              	.LVL275:
 2611              	.L230:
 2612              	.LBB14:
1242:../src/FreeRTOS/tasks.c **** 				}
 2613              		.loc 1 1242 0
 2614 00dc 0120A0E3 		mov	r2, #1
 2615 00e0 F5FFFFEA 		b	.L226
 2616              	.L231:
1256:../src/FreeRTOS/tasks.c **** 				}
 2617              		.loc 1 1256 0
 2618 00e4 0120A0E3 		mov	r2, #1
 2619 00e8 F3FFFFEA 		b	.L226
 2620              	.L232:
 2621 00ec 0120A0E3 		mov	r2, #1
 2622 00f0 F1FFFFEA 		b	.L226
 2623              	.LVL276:
 2624              	.L237:
1273:../src/FreeRTOS/tasks.c **** 			}
 2625              		.loc 1 1273 0
 2626 00f4 0010A0E3 		mov	r1, #0
 2627 00f8 000044E0 		sub	r0, r4, r0
 2628              	.LVL277:
 2629 00fc FEFFFFEB 		bl	prvAddCurrentTaskToDelayedList
 2630              	.LVL278:
 2631 0100 F0FFFFEA 		b	.L227
 2632              	.LBE14:
 2633              		.cfi_endproc
 2634              	.LFE5:
 2636              		.section	.text.vTaskDelay,"ax",%progbits
 2637              		.align	2
 2638              		.global	vTaskDelay
 2639              		.syntax unified
 2640              		.arm
 2641              		.fpu neon
 2643              	vTaskDelay:
 2644              	.LFB6:
1300:../src/FreeRTOS/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 2645              		.loc 1 1300 0
 2646              		.cfi_startproc
 2647              		@ args = 0, pretend = 0, frame = 0
 2648              		@ frame_needed = 0, uses_anonymous_args = 0
 2649              	.LVL279:
 2650 0000 10402DE9 		push	{r4, lr}
 2651              		.cfi_def_cfa_offset 8
 2652              		.cfi_offset 4, -8
 2653              		.cfi_offset 14, -4
 2654              	.LVL280:
1304:../src/FreeRTOS/tasks.c **** 		{
 2655              		.loc 1 1304 0
 2656 0004 004050E2 		subs	r4, r0, #0
 2657 0008 1200000A 		beq	.L242
1306:../src/FreeRTOS/tasks.c **** 			vTaskSuspendAll();
 2658              		.loc 1 1306 0
 2659 000c 003000E3 		movw	r3, #:lower16:.LANCHOR16
 2660 0010 003040E3 		movt	r3, #:upper16:.LANCHOR16
 2661 0014 003093E5 		ldr	r3, [r3]
 2662 0018 000053E3 		cmp	r3, #0
 2663 001c 0800001A 		bne	.L244
 2664              	.LVL281:
 2665              	.L240:
1307:../src/FreeRTOS/tasks.c **** 			{
 2666              		.loc 1 1307 0
 2667 0020 FEFFFFEB 		bl	vTaskSuspendAll
 2668              	.LVL282:
1318:../src/FreeRTOS/tasks.c **** 			}
 2669              		.loc 1 1318 0
 2670 0024 0010A0E3 		mov	r1, #0
 2671 0028 0400A0E1 		mov	r0, r4
 2672 002c FEFFFFEB 		bl	prvAddCurrentTaskToDelayedList
 2673              	.LVL283:
1320:../src/FreeRTOS/tasks.c **** 		}
 2674              		.loc 1 1320 0
 2675 0030 FEFFFFEB 		bl	xTaskResumeAll
 2676              	.LVL284:
 2677              	.L239:
1329:../src/FreeRTOS/tasks.c **** 		{
 2678              		.loc 1 1329 0
 2679 0034 000050E3 		cmp	r0, #0
 2680 0038 1080BD18 		popne	{r4, pc}
1331:../src/FreeRTOS/tasks.c **** 		}
 2681              		.loc 1 1331 0
 2682              		.syntax divided
 2683              	@ 1331 "../src/FreeRTOS/tasks.c" 1
 2684 003c 000000EF 		SWI 0
 2685              	@ 0 "" 2
 2686              		.arm
 2687              		.syntax unified
 2688 0040 1080BDE8 		pop	{r4, pc}
 2689              	.LVL285:
 2690              	.L244:
1306:../src/FreeRTOS/tasks.c **** 			vTaskSuspendAll();
 2691              		.loc 1 1306 0 discriminator 1
 2692 0044 1A1500E3 		movw	r1, #1306
 2693 0048 000000E3 		movw	r0, #:lower16:.LC0
 2694              	.LVL286:
 2695 004c 000040E3 		movt	r0, #:upper16:.LC0
 2696 0050 FEFFFFEB 		bl	R_OS_AssertCalled
 2697              	.LVL287:
 2698 0054 F1FFFFEA 		b	.L240
 2699              	.LVL288:
 2700              	.L242:
1301:../src/FreeRTOS/tasks.c **** 
 2701              		.loc 1 1301 0
 2702 0058 0000A0E3 		mov	r0, #0
 2703              	.LVL289:
 2704 005c F4FFFFEA 		b	.L239
 2705              		.cfi_endproc
 2706              	.LFE6:
 2708              		.section	.text.xTaskAbortDelay,"ax",%progbits
 2709              		.align	2
 2710              		.global	xTaskAbortDelay
 2711              		.syntax unified
 2712              		.arm
 2713              		.fpu neon
 2715              	xTaskAbortDelay:
 2716              	.LFB26:
2573:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB = ( TCB_t * ) xTask;
 2717              		.loc 1 2573 0
 2718              		.cfi_startproc
 2719              		@ args = 0, pretend = 0, frame = 0
 2720              		@ frame_needed = 0, uses_anonymous_args = 0
 2721              	.LVL290:
 2722 0000 70402DE9 		push	{r4, r5, r6, lr}
 2723              		.cfi_def_cfa_offset 16
 2724              		.cfi_offset 4, -16
 2725              		.cfi_offset 5, -12
 2726              		.cfi_offset 6, -8
 2727              		.cfi_offset 14, -4
 2728              	.LVL291:
2577:../src/FreeRTOS/tasks.c **** 
 2729              		.loc 1 2577 0
 2730 0004 004050E2 		subs	r4, r0, #0
 2731 0008 0800000A 		beq	.L253
 2732              	.LVL292:
 2733              	.L246:
2579:../src/FreeRTOS/tasks.c **** 		{
 2734              		.loc 1 2579 0
 2735 000c FEFFFFEB 		bl	vTaskSuspendAll
 2736              	.LVL293:
2583:../src/FreeRTOS/tasks.c **** 			{
 2737              		.loc 1 2583 0
 2738 0010 0400A0E1 		mov	r0, r4
 2739 0014 FEFFFFEB 		bl	eTaskGetState
 2740              	.LVL294:
 2741 0018 020050E3 		cmp	r0, #2
 2742 001c 0800000A 		beq	.L254
2635:../src/FreeRTOS/tasks.c **** 			}
 2743              		.loc 1 2635 0
 2744 0020 0040A0E3 		mov	r4, #0
 2745              	.LVL295:
 2746              	.L247:
2638:../src/FreeRTOS/tasks.c **** 
 2747              		.loc 1 2638 0
 2748 0024 FEFFFFEB 		bl	xTaskResumeAll
 2749              	.LVL296:
2641:../src/FreeRTOS/tasks.c **** 
 2750              		.loc 1 2641 0
 2751 0028 0400A0E1 		mov	r0, r4
 2752 002c 7080BDE8 		pop	{r4, r5, r6, pc}
 2753              	.LVL297:
 2754              	.L253:
2577:../src/FreeRTOS/tasks.c **** 
 2755              		.loc 1 2577 0 discriminator 1
 2756 0030 111A00E3 		movw	r1, #2577
 2757 0034 000000E3 		movw	r0, #:lower16:.LC0
 2758              	.LVL298:
 2759 0038 000040E3 		movt	r0, #:upper16:.LC0
 2760 003c FEFFFFEB 		bl	R_OS_AssertCalled
 2761              	.LVL299:
 2762 0040 F1FFFFEA 		b	.L246
 2763              	.L254:
 2764              	.LVL300:
2590:../src/FreeRTOS/tasks.c **** 
 2765              		.loc 1 2590 0
 2766 0044 045084E2 		add	r5, r4, #4
 2767 0048 0500A0E1 		mov	r0, r5
 2768 004c FEFFFFEB 		bl	uxListRemove
 2769              	.LVL301:
2596:../src/FreeRTOS/tasks.c **** 				{
 2770              		.loc 1 2596 0
 2771 0050 FEFFFFEB 		bl	vPortEnterCritical
 2772              	.LVL302:
2598:../src/FreeRTOS/tasks.c **** 					{
 2773              		.loc 1 2598 0
 2774 0054 283094E5 		ldr	r3, [r4, #40]
 2775 0058 000053E3 		cmp	r3, #0
 2776 005c 0300000A 		beq	.L248
2600:../src/FreeRTOS/tasks.c **** 						pxTCB->ucDelayAborted = pdTRUE;
 2777              		.loc 1 2600 0
 2778 0060 180084E2 		add	r0, r4, #24
 2779 0064 FEFFFFEB 		bl	uxListRemove
 2780              	.LVL303:
2601:../src/FreeRTOS/tasks.c **** 					}
 2781              		.loc 1 2601 0
 2782 0068 0130A0E3 		mov	r3, #1
 2783 006c 7530C4E5 		strb	r3, [r4, #117]
 2784              	.L248:
2608:../src/FreeRTOS/tasks.c **** 
 2785              		.loc 1 2608 0
 2786 0070 FEFFFFEB 		bl	vPortExitCritical
 2787              	.LVL304:
2611:../src/FreeRTOS/tasks.c **** 
 2788              		.loc 1 2611 0
 2789 0074 2C3094E5 		ldr	r3, [r4, #44]
 2790 0078 002000E3 		movw	r2, #:lower16:.LANCHOR13
 2791 007c 002040E3 		movt	r2, #:upper16:.LANCHOR13
 2792 0080 002092E5 		ldr	r2, [r2]
 2793 0084 020053E1 		cmp	r3, r2
2611:../src/FreeRTOS/tasks.c **** 
 2794              		.loc 1 2611 0 is_stmt 0 discriminator 1
 2795 0088 00200083 		movwhi	r2, #:lower16:.LANCHOR13
 2796 008c 00204083 		movthi	r2, #:upper16:.LANCHOR13
 2797 0090 00308285 		strhi	r3, [r2]
 2798              	.L249:
2611:../src/FreeRTOS/tasks.c **** 
 2799              		.loc 1 2611 0 discriminator 3
 2800 0094 002000E3 		movw	r2, #:lower16:.LANCHOR4
 2801 0098 002040E3 		movt	r2, #:upper16:.LANCHOR4
 2802 009c 033183E0 		add	r3, r3, r3, lsl #2
 2803 00a0 0301A0E1 		lsl	r0, r3, #2
 2804 00a4 0510A0E1 		mov	r1, r5
 2805 00a8 000082E0 		add	r0, r2, r0
 2806 00ac FEFFFFEB 		bl	vListInsertEnd
 2807              	.LVL305:
2620:../src/FreeRTOS/tasks.c **** 					{
 2808              		.loc 1 2620 0 is_stmt 1 discriminator 3
 2809 00b0 2C2094E5 		ldr	r2, [r4, #44]
 2810 00b4 003000E3 		movw	r3, #:lower16:.LANCHOR10
 2811 00b8 003040E3 		movt	r3, #:upper16:.LANCHOR10
 2812 00bc 003093E5 		ldr	r3, [r3]
 2813 00c0 2C3093E5 		ldr	r3, [r3, #44]
 2814 00c4 030052E1 		cmp	r2, r3
 2815 00c8 0400009A 		bls	.L251
2624:../src/FreeRTOS/tasks.c **** 					}
 2816              		.loc 1 2624 0
 2817 00cc 003000E3 		movw	r3, #:lower16:.LANCHOR21
 2818 00d0 003040E3 		movt	r3, #:upper16:.LANCHOR21
 2819 00d4 0140A0E3 		mov	r4, #1
 2820              	.LVL306:
 2821 00d8 004083E5 		str	r4, [r3]
 2822 00dc D0FFFFEA 		b	.L247
 2823              	.LVL307:
 2824              	.L251:
2585:../src/FreeRTOS/tasks.c **** 
 2825              		.loc 1 2585 0
 2826 00e0 0140A0E3 		mov	r4, #1
 2827              	.LVL308:
 2828 00e4 CEFFFFEA 		b	.L247
 2829              		.cfi_endproc
 2830              	.LFE26:
 2832              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2833              		.align	2
 2834              		.global	vTaskSwitchContext
 2835              		.syntax unified
 2836              		.arm
 2837              		.fpu neon
 2839              	vTaskSwitchContext:
 2840              	.LFB28:
2909:../src/FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2841              		.loc 1 2909 0
 2842              		.cfi_startproc
 2843              		@ args = 0, pretend = 0, frame = 0
 2844              		@ frame_needed = 0, uses_anonymous_args = 0
2910:../src/FreeRTOS/tasks.c **** 	{
 2845              		.loc 1 2910 0
 2846 0000 003000E3 		movw	r3, #:lower16:.LANCHOR16
 2847 0004 003040E3 		movt	r3, #:upper16:.LANCHOR16
 2848 0008 003093E5 		ldr	r3, [r3]
 2849 000c 000053E3 		cmp	r3, #0
 2850 0010 0400000A 		beq	.L256
2914:../src/FreeRTOS/tasks.c **** 	}
 2851              		.loc 1 2914 0
 2852 0014 003000E3 		movw	r3, #:lower16:.LANCHOR21
 2853 0018 003040E3 		movt	r3, #:upper16:.LANCHOR21
 2854 001c 0120A0E3 		mov	r2, #1
 2855 0020 002083E5 		str	r2, [r3]
 2856 0024 1EFF2FE1 		bx	lr
 2857              	.L256:
2909:../src/FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2858              		.loc 1 2909 0
 2859 0028 10402DE9 		push	{r4, lr}
 2860              		.cfi_def_cfa_offset 8
 2861              		.cfi_offset 4, -8
 2862              		.cfi_offset 14, -4
2918:../src/FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_OUT();
 2863              		.loc 1 2918 0
 2864 002c 003000E3 		movw	r3, #:lower16:.LANCHOR21
 2865 0030 003040E3 		movt	r3, #:upper16:.LANCHOR21
 2866 0034 0020A0E3 		mov	r2, #0
 2867 0038 002083E5 		str	r2, [r3]
2926:../src/FreeRTOS/tasks.c **** 				#endif
 2868              		.loc 1 2926 0
 2869 003c FEFFFFEB 		bl	ulGetRunTimeCounterValue
 2870              	.LVL309:
2936:../src/FreeRTOS/tasks.c **** 				{
 2871              		.loc 1 2936 0
 2872 0040 003000E3 		movw	r3, #:lower16:.LANCHOR22
 2873 0044 003040E3 		movt	r3, #:upper16:.LANCHOR22
 2874 0048 003093E5 		ldr	r3, [r3]
 2875 004c 030050E1 		cmp	r0, r3
 2876 0050 0600009A 		bls	.L258
2938:../src/FreeRTOS/tasks.c **** 				}
 2877              		.loc 1 2938 0
 2878 0054 002000E3 		movw	r2, #:lower16:.LANCHOR10
 2879 0058 002040E3 		movt	r2, #:upper16:.LANCHOR10
 2880 005c 001092E5 		ldr	r1, [r2]
 2881 0060 033040E0 		sub	r3, r0, r3
 2882 0064 6C2091E5 		ldr	r2, [r1, #108]
 2883 0068 033082E0 		add	r3, r2, r3
 2884 006c 6C3081E5 		str	r3, [r1, #108]
 2885              	.L258:
2944:../src/FreeRTOS/tasks.c **** 		}
 2886              		.loc 1 2944 0
 2887 0070 003000E3 		movw	r3, #:lower16:.LANCHOR22
 2888 0074 003040E3 		movt	r3, #:upper16:.LANCHOR22
 2889 0078 000083E5 		str	r0, [r3]
 2890              	.LBB15:
2949:../src/FreeRTOS/tasks.c **** 
 2891              		.loc 1 2949 0
 2892 007c 003000E3 		movw	r3, #:lower16:.LANCHOR10
 2893 0080 003040E3 		movt	r3, #:upper16:.LANCHOR10
 2894 0084 003093E5 		ldr	r3, [r3]
 2895 0088 302093E5 		ldr	r2, [r3, #48]
 2896              	.LVL310:
 2897 008c 001092E5 		ldr	r1, [r2]
 2898 0090 A5350AE3 		movw	r3, #42405
 2899 0094 1338DFE7 		bfi	r3, r3, #16, #16
 2900 0098 030051E1 		cmp	r1, r3
 2901 009c 0900000A 		beq	.L268
 2902              	.LVL311:
 2903              	.L259:
2949:../src/FreeRTOS/tasks.c **** 
 2904              		.loc 1 2949 0 is_stmt 0 discriminator 7
 2905 00a0 003000E3 		movw	r3, #:lower16:.LANCHOR10
 2906 00a4 003040E3 		movt	r3, #:upper16:.LANCHOR10
 2907 00a8 000093E5 		ldr	r0, [r3]
 2908 00ac 001093E5 		ldr	r1, [r3]
 2909 00b0 341081E2 		add	r1, r1, #52
 2910 00b4 FEFFFFEB 		bl	vApplicationStackOverflowHook
 2911              	.LVL312:
 2912              	.L260:
 2913              	.LBE15:
 2914              	.LBB16:
2960:../src/FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_IN();
 2915              		.loc 1 2960 0 is_stmt 1
 2916 00b8 003000E3 		movw	r3, #:lower16:.LANCHOR13
 2917 00bc 003040E3 		movt	r3, #:upper16:.LANCHOR13
 2918 00c0 004093E5 		ldr	r4, [r3]
 2919              	.LVL313:
 2920 00c4 100000EA 		b	.L261
 2921              	.LVL314:
 2922              	.L268:
 2923              	.LBE16:
 2924              	.LBB19:
2949:../src/FreeRTOS/tasks.c **** 
 2925              		.loc 1 2949 0 discriminator 2
 2926 00c8 041092E5 		ldr	r1, [r2, #4]
 2927 00cc A5350AE3 		movw	r3, #42405
 2928 00d0 1338DFE7 		bfi	r3, r3, #16, #16
 2929 00d4 030051E1 		cmp	r1, r3
 2930 00d8 F0FFFF1A 		bne	.L259
2949:../src/FreeRTOS/tasks.c **** 
 2931              		.loc 1 2949 0 is_stmt 0 discriminator 4
 2932 00dc 081092E5 		ldr	r1, [r2, #8]
 2933 00e0 A5350AE3 		movw	r3, #42405
 2934 00e4 1338DFE7 		bfi	r3, r3, #16, #16
 2935 00e8 030051E1 		cmp	r1, r3
 2936 00ec EBFFFF1A 		bne	.L259
2949:../src/FreeRTOS/tasks.c **** 
 2937              		.loc 1 2949 0 discriminator 6
 2938 00f0 0C2092E5 		ldr	r2, [r2, #12]
 2939              	.LVL315:
 2940 00f4 A5350AE3 		movw	r3, #42405
 2941 00f8 1338DFE7 		bfi	r3, r3, #16, #16
 2942 00fc 030052E1 		cmp	r2, r3
 2943 0100 E6FFFF1A 		bne	.L259
 2944 0104 EBFFFFEA 		b	.L260
 2945              	.LVL316:
 2946              	.L262:
 2947              	.LBE19:
 2948              	.LBB20:
2960:../src/FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_IN();
 2949              		.loc 1 2960 0 is_stmt 1 discriminator 4
 2950 0108 014044E2 		sub	r4, r4, #1
 2951              	.LVL317:
 2952              	.L261:
2960:../src/FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_IN();
 2953              		.loc 1 2960 0 is_stmt 0 discriminator 5
 2954 010c 003000E3 		movw	r3, #:lower16:.LANCHOR4
 2955 0110 003040E3 		movt	r3, #:upper16:.LANCHOR4
 2956 0114 041184E0 		add	r1, r4, r4, lsl #2
 2957 0118 0121A0E1 		lsl	r2, r1, #2
 2958 011c 023093E7 		ldr	r3, [r3, r2]
 2959 0120 000053E3 		cmp	r3, #0
 2960 0124 0600001A 		bne	.L269
2960:../src/FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_IN();
 2961              		.loc 1 2960 0 discriminator 6
 2962 0128 000054E3 		cmp	r4, #0
 2963 012c F5FFFF1A 		bne	.L262
2960:../src/FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_IN();
 2964              		.loc 1 2960 0 discriminator 2
 2965 0130 B91EA0E3 		mov	r1, #2960
 2966 0134 000000E3 		movw	r0, #:lower16:.LC0
 2967 0138 000040E3 		movt	r0, #:upper16:.LC0
 2968 013c FEFFFFEB 		bl	R_OS_AssertCalled
 2969              	.LVL318:
 2970 0140 F0FFFFEA 		b	.L262
 2971              	.L269:
 2972              	.LVL319:
 2973              	.LBB17:
2960:../src/FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_IN();
 2974              		.loc 1 2960 0 discriminator 7
 2975 0144 003000E3 		movw	r3, #:lower16:.LANCHOR4
 2976 0148 003040E3 		movt	r3, #:upper16:.LANCHOR4
 2977 014c 0421A0E1 		lsl	r2, r4, #2
 2978 0150 0111A0E1 		lsl	r1, r1, #2
 2979 0154 011083E0 		add	r1, r3, r1
 2980 0158 040091E5 		ldr	r0, [r1, #4]
 2981 015c 040090E5 		ldr	r0, [r0, #4]
 2982 0160 040081E5 		str	r0, [r1, #4]
 2983 0164 042082E0 		add	r2, r2, r4
 2984 0168 0211A0E1 		lsl	r1, r2, #2
 2985 016c 081081E2 		add	r1, r1, #8
 2986 0170 013083E0 		add	r3, r3, r1
 2987 0174 030050E1 		cmp	r0, r3
 2988 0178 0D00000A 		beq	.L270
 2989              	.L264:
2960:../src/FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_IN();
 2990              		.loc 1 2960 0 discriminator 10
 2991 017c 003000E3 		movw	r3, #:lower16:.LANCHOR4
 2992 0180 003040E3 		movt	r3, #:upper16:.LANCHOR4
 2993 0184 041184E0 		add	r1, r4, r4, lsl #2
 2994 0188 0121A0E1 		lsl	r2, r1, #2
 2995 018c 023083E0 		add	r3, r3, r2
 2996 0190 043093E5 		ldr	r3, [r3, #4]
 2997 0194 0C2093E5 		ldr	r2, [r3, #12]
 2998 0198 003000E3 		movw	r3, #:lower16:.LANCHOR10
 2999 019c 003040E3 		movt	r3, #:upper16:.LANCHOR10
 3000 01a0 002083E5 		str	r2, [r3]
 3001              	.LBE17:
 3002 01a4 003000E3 		movw	r3, #:lower16:.LANCHOR13
 3003 01a8 003040E3 		movt	r3, #:upper16:.LANCHOR13
 3004 01ac 004083E5 		str	r4, [r3]
 3005 01b0 1080BDE8 		pop	{r4, pc}
 3006              	.L270:
 3007              	.LBB18:
2960:../src/FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_IN();
 3008              		.loc 1 2960 0 discriminator 8
 3009 01b4 040090E5 		ldr	r0, [r0, #4]
 3010 01b8 003000E3 		movw	r3, #:lower16:.LANCHOR4
 3011 01bc 003040E3 		movt	r3, #:upper16:.LANCHOR4
 3012 01c0 0221A0E1 		lsl	r2, r2, #2
 3013 01c4 023083E0 		add	r3, r3, r2
 3014 01c8 040083E5 		str	r0, [r3, #4]
 3015 01cc EAFFFFEA 		b	.L264
 3016              	.LBE18:
 3017              	.LBE20:
 3018              		.cfi_endproc
 3019              	.LFE28:
 3021              		.section	.text.vTaskSuspend,"ax",%progbits
 3022              		.align	2
 3023              		.global	vTaskSuspend
 3024              		.syntax unified
 3025              		.arm
 3026              		.fpu neon
 3028              	vTaskSuspend:
 3029              	.LFB11:
1642:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
 3030              		.loc 1 1642 0 is_stmt 1
 3031              		.cfi_startproc
 3032              		@ args = 0, pretend = 0, frame = 0
 3033              		@ frame_needed = 0, uses_anonymous_args = 0
 3034              	.LVL320:
 3035 0000 70402DE9 		push	{r4, r5, r6, lr}
 3036              		.cfi_def_cfa_offset 16
 3037              		.cfi_offset 4, -16
 3038              		.cfi_offset 5, -12
 3039              		.cfi_offset 6, -8
 3040              		.cfi_offset 14, -4
 3041 0004 0040A0E1 		mov	r4, r0
1645:../src/FreeRTOS/tasks.c **** 		{
 3042              		.loc 1 1645 0
 3043 0008 FEFFFFEB 		bl	vPortEnterCritical
 3044              	.LVL321:
1649:../src/FreeRTOS/tasks.c **** 
 3045              		.loc 1 1649 0
 3046 000c 000054E3 		cmp	r4, #0
 3047 0010 2600000A 		beq	.L282
 3048              	.LVL322:
 3049              	.L272:
1655:../src/FreeRTOS/tasks.c **** 			{
 3050              		.loc 1 1655 0 discriminator 4
 3051 0014 045084E2 		add	r5, r4, #4
 3052 0018 0500A0E1 		mov	r0, r5
 3053 001c FEFFFFEB 		bl	uxListRemove
 3054              	.LVL323:
1665:../src/FreeRTOS/tasks.c **** 			{
 3055              		.loc 1 1665 0 discriminator 4
 3056 0020 283094E5 		ldr	r3, [r4, #40]
 3057 0024 000053E3 		cmp	r3, #0
 3058 0028 0100000A 		beq	.L273
1667:../src/FreeRTOS/tasks.c **** 			}
 3059              		.loc 1 1667 0
 3060 002c 180084E2 		add	r0, r4, #24
 3061 0030 FEFFFFEB 		bl	uxListRemove
 3062              	.LVL324:
 3063              	.L273:
1674:../src/FreeRTOS/tasks.c **** 
 3064              		.loc 1 1674 0
 3065 0034 0510A0E1 		mov	r1, r5
 3066 0038 000000E3 		movw	r0, #:lower16:.LANCHOR2
 3067 003c 000040E3 		movt	r0, #:upper16:.LANCHOR2
 3068 0040 FEFFFFEB 		bl	vListInsertEnd
 3069              	.LVL325:
1678:../src/FreeRTOS/tasks.c **** 				{
 3070              		.loc 1 1678 0
 3071 0044 7430D4E5 		ldrb	r3, [r4, #116]	@ zero_extendqisi2
 3072 0048 7330EFE6 		uxtb	r3, r3
 3073 004c 010053E3 		cmp	r3, #1
 3074 0050 1A00000A 		beq	.L283
 3075              	.L274:
1687:../src/FreeRTOS/tasks.c **** 
 3076              		.loc 1 1687 0
 3077 0054 FEFFFFEB 		bl	vPortExitCritical
 3078              	.LVL326:
1689:../src/FreeRTOS/tasks.c **** 		{
 3079              		.loc 1 1689 0
 3080 0058 003000E3 		movw	r3, #:lower16:.LANCHOR11
 3081 005c 003040E3 		movt	r3, #:upper16:.LANCHOR11
 3082 0060 003093E5 		ldr	r3, [r3]
 3083 0064 000053E3 		cmp	r3, #0
 3084 0068 1700001A 		bne	.L284
 3085              	.L275:
1704:../src/FreeRTOS/tasks.c **** 		{
 3086              		.loc 1 1704 0
 3087 006c 003000E3 		movw	r3, #:lower16:.LANCHOR10
 3088 0070 003040E3 		movt	r3, #:upper16:.LANCHOR10
 3089 0074 003093E5 		ldr	r3, [r3]
 3090 0078 030054E1 		cmp	r4, r3
 3091 007c 7080BD18 		popne	{r4, r5, r6, pc}
1706:../src/FreeRTOS/tasks.c **** 			{
 3092              		.loc 1 1706 0
 3093 0080 003000E3 		movw	r3, #:lower16:.LANCHOR11
 3094 0084 003040E3 		movt	r3, #:upper16:.LANCHOR11
 3095 0088 003093E5 		ldr	r3, [r3]
 3096 008c 000053E3 		cmp	r3, #0
 3097 0090 1600000A 		beq	.L277
1709:../src/FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 3098              		.loc 1 1709 0
 3099 0094 003000E3 		movw	r3, #:lower16:.LANCHOR16
 3100 0098 003040E3 		movt	r3, #:upper16:.LANCHOR16
 3101 009c 003093E5 		ldr	r3, [r3]
 3102 00a0 000053E3 		cmp	r3, #0
 3103 00a4 0C00001A 		bne	.L285
 3104              	.L278:
1710:../src/FreeRTOS/tasks.c **** 			}
 3105              		.loc 1 1710 0
 3106              		.syntax divided
 3107              	@ 1710 "../src/FreeRTOS/tasks.c" 1
 3108 00a8 000000EF 		SWI 0
 3109              	@ 0 "" 2
 3110              		.arm
 3111              		.syntax unified
 3112 00ac 7080BDE8 		pop	{r4, r5, r6, pc}
 3113              	.LVL327:
 3114              	.L282:
1649:../src/FreeRTOS/tasks.c **** 
 3115              		.loc 1 1649 0 discriminator 1
 3116 00b0 003000E3 		movw	r3, #:lower16:.LANCHOR10
 3117 00b4 003040E3 		movt	r3, #:upper16:.LANCHOR10
 3118 00b8 004093E5 		ldr	r4, [r3]
 3119              	.LVL328:
 3120 00bc D4FFFFEA 		b	.L272
 3121              	.LVL329:
 3122              	.L283:
1682:../src/FreeRTOS/tasks.c **** 				}
 3123              		.loc 1 1682 0
 3124 00c0 0030A0E3 		mov	r3, #0
 3125 00c4 7430C4E5 		strb	r3, [r4, #116]
 3126 00c8 E1FFFFEA 		b	.L274
 3127              	.L284:
1693:../src/FreeRTOS/tasks.c **** 			{
 3128              		.loc 1 1693 0
 3129 00cc FEFFFFEB 		bl	vPortEnterCritical
 3130              	.LVL330:
1695:../src/FreeRTOS/tasks.c **** 			}
 3131              		.loc 1 1695 0
 3132 00d0 FEFFFFEB 		bl	prvResetNextTaskUnblockTime
 3133              	.LVL331:
1697:../src/FreeRTOS/tasks.c **** 		}
 3134              		.loc 1 1697 0
 3135 00d4 FEFFFFEB 		bl	vPortExitCritical
 3136              	.LVL332:
 3137 00d8 E3FFFFEA 		b	.L275
 3138              	.L285:
1709:../src/FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 3139              		.loc 1 1709 0 discriminator 1
 3140 00dc AD1600E3 		movw	r1, #1709
 3141 00e0 000000E3 		movw	r0, #:lower16:.LC0
 3142 00e4 000040E3 		movt	r0, #:upper16:.LC0
 3143 00e8 FEFFFFEB 		bl	R_OS_AssertCalled
 3144              	.LVL333:
 3145 00ec EDFFFFEA 		b	.L278
 3146              	.L277:
1717:../src/FreeRTOS/tasks.c **** 				{
 3147              		.loc 1 1717 0
 3148 00f0 003000E3 		movw	r3, #:lower16:.LANCHOR2
 3149 00f4 003040E3 		movt	r3, #:upper16:.LANCHOR2
 3150 00f8 002093E5 		ldr	r2, [r3]
 3151 00fc 003000E3 		movw	r3, #:lower16:.LANCHOR9
 3152 0100 003040E3 		movt	r3, #:upper16:.LANCHOR9
 3153 0104 003093E5 		ldr	r3, [r3]
 3154 0108 030052E1 		cmp	r2, r3
 3155 010c 0100000A 		beq	.L286
1727:../src/FreeRTOS/tasks.c **** 				}
 3156              		.loc 1 1727 0
 3157 0110 FEFFFFEB 		bl	vTaskSwitchContext
 3158              	.LVL334:
 3159 0114 7080BDE8 		pop	{r4, r5, r6, pc}
 3160              	.L286:
1723:../src/FreeRTOS/tasks.c **** 				}
 3161              		.loc 1 1723 0
 3162 0118 003000E3 		movw	r3, #:lower16:.LANCHOR10
 3163 011c 003040E3 		movt	r3, #:upper16:.LANCHOR10
 3164 0120 0020A0E3 		mov	r2, #0
 3165 0124 002083E5 		str	r2, [r3]
 3166 0128 7080BDE8 		pop	{r4, r5, r6, pc}
 3167              		.cfi_endproc
 3168              	.LFE11:
 3170              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 3171              		.align	2
 3172              		.global	vTaskPlaceOnEventList
 3173              		.syntax unified
 3174              		.arm
 3175              		.fpu neon
 3177              	vTaskPlaceOnEventList:
 3178              	.LFB29:
2982:../src/FreeRTOS/tasks.c **** 	configASSERT( pxEventList );
 3179              		.loc 1 2982 0
 3180              		.cfi_startproc
 3181              		@ args = 0, pretend = 0, frame = 0
 3182              		@ frame_needed = 0, uses_anonymous_args = 0
 3183              	.LVL335:
 3184 0000 70402DE9 		push	{r4, r5, r6, lr}
 3185              		.cfi_def_cfa_offset 16
 3186              		.cfi_offset 4, -16
 3187              		.cfi_offset 5, -12
 3188              		.cfi_offset 6, -8
 3189              		.cfi_offset 14, -4
 3190 0004 0140A0E1 		mov	r4, r1
2983:../src/FreeRTOS/tasks.c **** 
 3191              		.loc 1 2983 0
 3192 0008 005050E2 		subs	r5, r0, #0
 3193 000c 0900000A 		beq	.L290
 3194              	.LVL336:
 3195              	.L288:
2992:../src/FreeRTOS/tasks.c **** 
 3196              		.loc 1 2992 0
 3197 0010 003000E3 		movw	r3, #:lower16:.LANCHOR10
 3198 0014 003040E3 		movt	r3, #:upper16:.LANCHOR10
 3199 0018 001093E5 		ldr	r1, [r3]
 3200 001c 181081E2 		add	r1, r1, #24
 3201 0020 0500A0E1 		mov	r0, r5
 3202 0024 FEFFFFEB 		bl	vListInsert
 3203              	.LVL337:
2994:../src/FreeRTOS/tasks.c **** }
 3204              		.loc 1 2994 0
 3205 0028 0110A0E3 		mov	r1, #1
 3206 002c 0400A0E1 		mov	r0, r4
 3207 0030 FEFFFFEB 		bl	prvAddCurrentTaskToDelayedList
 3208              	.LVL338:
 3209 0034 7080BDE8 		pop	{r4, r5, r6, pc}
 3210              	.LVL339:
 3211              	.L290:
2983:../src/FreeRTOS/tasks.c **** 
 3212              		.loc 1 2983 0 discriminator 1
 3213 0038 A71B00E3 		movw	r1, #2983
 3214              	.LVL340:
 3215 003c 000000E3 		movw	r0, #:lower16:.LC0
 3216              	.LVL341:
 3217 0040 000040E3 		movt	r0, #:upper16:.LC0
 3218 0044 FEFFFFEB 		bl	R_OS_AssertCalled
 3219              	.LVL342:
 3220 0048 F0FFFFEA 		b	.L288
 3221              		.cfi_endproc
 3222              	.LFE29:
 3224              		.section	.text.vTaskPlaceOnUnorderedEventList,"ax",%progbits
 3225              		.align	2
 3226              		.global	vTaskPlaceOnUnorderedEventList
 3227              		.syntax unified
 3228              		.arm
 3229              		.fpu neon
 3231              	vTaskPlaceOnUnorderedEventList:
 3232              	.LFB30:
2999:../src/FreeRTOS/tasks.c **** 	configASSERT( pxEventList );
 3233              		.loc 1 2999 0
 3234              		.cfi_startproc
 3235              		@ args = 0, pretend = 0, frame = 0
 3236              		@ frame_needed = 0, uses_anonymous_args = 0
 3237              	.LVL343:
 3238 0000 70402DE9 		push	{r4, r5, r6, lr}
 3239              		.cfi_def_cfa_offset 16
 3240              		.cfi_offset 4, -16
 3241              		.cfi_offset 5, -12
 3242              		.cfi_offset 6, -8
 3243              		.cfi_offset 14, -4
 3244 0004 0140A0E1 		mov	r4, r1
 3245 0008 0250A0E1 		mov	r5, r2
3000:../src/FreeRTOS/tasks.c **** 
 3246              		.loc 1 3000 0
 3247 000c 006050E2 		subs	r6, r0, #0
 3248 0010 1100000A 		beq	.L295
 3249              	.LVL344:
 3250              	.L292:
3004:../src/FreeRTOS/tasks.c **** 
 3251              		.loc 1 3004 0
 3252 0014 003000E3 		movw	r3, #:lower16:.LANCHOR16
 3253 0018 003040E3 		movt	r3, #:upper16:.LANCHOR16
 3254 001c 003093E5 		ldr	r3, [r3]
 3255 0020 000053E3 		cmp	r3, #0
 3256 0024 1100000A 		beq	.L296
 3257              	.L293:
3009:../src/FreeRTOS/tasks.c **** 
 3258              		.loc 1 3009 0
 3259 0028 003000E3 		movw	r3, #:lower16:.LANCHOR10
 3260 002c 003040E3 		movt	r3, #:upper16:.LANCHOR10
 3261 0030 002093E5 		ldr	r2, [r3]
 3262 0034 024184E3 		orr	r4, r4, #-2147483648
 3263              	.LVL345:
 3264 0038 184082E5 		str	r4, [r2, #24]
3016:../src/FreeRTOS/tasks.c **** 
 3265              		.loc 1 3016 0
 3266 003c 001093E5 		ldr	r1, [r3]
 3267 0040 181081E2 		add	r1, r1, #24
 3268 0044 0600A0E1 		mov	r0, r6
 3269 0048 FEFFFFEB 		bl	vListInsertEnd
 3270              	.LVL346:
3018:../src/FreeRTOS/tasks.c **** }
 3271              		.loc 1 3018 0
 3272 004c 0110A0E3 		mov	r1, #1
 3273 0050 0500A0E1 		mov	r0, r5
 3274 0054 FEFFFFEB 		bl	prvAddCurrentTaskToDelayedList
 3275              	.LVL347:
 3276 0058 7080BDE8 		pop	{r4, r5, r6, pc}
 3277              	.LVL348:
 3278              	.L295:
3000:../src/FreeRTOS/tasks.c **** 
 3279              		.loc 1 3000 0 discriminator 1
 3280 005c B81B00E3 		movw	r1, #3000
 3281              	.LVL349:
 3282 0060 000000E3 		movw	r0, #:lower16:.LC0
 3283              	.LVL350:
 3284 0064 000040E3 		movt	r0, #:upper16:.LC0
 3285 0068 FEFFFFEB 		bl	R_OS_AssertCalled
 3286              	.LVL351:
 3287 006c E8FFFFEA 		b	.L292
 3288              	.L296:
3004:../src/FreeRTOS/tasks.c **** 
 3289              		.loc 1 3004 0 discriminator 1
 3290 0070 BC1B00E3 		movw	r1, #3004
 3291 0074 000000E3 		movw	r0, #:lower16:.LC0
 3292 0078 000040E3 		movt	r0, #:upper16:.LC0
 3293 007c FEFFFFEB 		bl	R_OS_AssertCalled
 3294              	.LVL352:
 3295 0080 E8FFFFEA 		b	.L293
 3296              		.cfi_endproc
 3297              	.LFE30:
 3299              		.section	.text.vTaskPlaceOnEventListRestricted,"ax",%progbits
 3300              		.align	2
 3301              		.global	vTaskPlaceOnEventListRestricted
 3302              		.syntax unified
 3303              		.arm
 3304              		.fpu neon
 3306              	vTaskPlaceOnEventListRestricted:
 3307              	.LFB31:
3025:../src/FreeRTOS/tasks.c **** 		configASSERT( pxEventList );
 3308              		.loc 1 3025 0
 3309              		.cfi_startproc
 3310              		@ args = 0, pretend = 0, frame = 0
 3311              		@ frame_needed = 0, uses_anonymous_args = 0
 3312              	.LVL353:
 3313 0000 70402DE9 		push	{r4, r5, r6, lr}
 3314              		.cfi_def_cfa_offset 16
 3315              		.cfi_offset 4, -16
 3316              		.cfi_offset 5, -12
 3317              		.cfi_offset 6, -8
 3318              		.cfi_offset 14, -4
 3319 0004 0150A0E1 		mov	r5, r1
 3320 0008 0240A0E1 		mov	r4, r2
3026:../src/FreeRTOS/tasks.c **** 
 3321              		.loc 1 3026 0
 3322 000c 006050E2 		subs	r6, r0, #0
 3323 0010 0B00000A 		beq	.L302
 3324              	.LVL354:
 3325              	.L298:
3038:../src/FreeRTOS/tasks.c **** 
 3326              		.loc 1 3038 0
 3327 0014 003000E3 		movw	r3, #:lower16:.LANCHOR10
 3328 0018 003040E3 		movt	r3, #:upper16:.LANCHOR10
 3329 001c 001093E5 		ldr	r1, [r3]
 3330 0020 181081E2 		add	r1, r1, #24
 3331 0024 0600A0E1 		mov	r0, r6
 3332 0028 FEFFFFEB 		bl	vListInsertEnd
 3333              	.LVL355:
3043:../src/FreeRTOS/tasks.c **** 		{
 3334              		.loc 1 3043 0
 3335 002c 000054E3 		cmp	r4, #0
3045:../src/FreeRTOS/tasks.c **** 		}
 3336              		.loc 1 3045 0
 3337 0030 0050E013 		mvnne	r5, #0
 3338              	.LVL356:
 3339              	.L299:
3049:../src/FreeRTOS/tasks.c **** 	}
 3340              		.loc 1 3049 0
 3341 0034 0410A0E1 		mov	r1, r4
 3342 0038 0500A0E1 		mov	r0, r5
 3343 003c FEFFFFEB 		bl	prvAddCurrentTaskToDelayedList
 3344              	.LVL357:
 3345 0040 7080BDE8 		pop	{r4, r5, r6, pc}
 3346              	.LVL358:
 3347              	.L302:
3026:../src/FreeRTOS/tasks.c **** 
 3348              		.loc 1 3026 0 discriminator 1
 3349 0044 D21B00E3 		movw	r1, #3026
 3350              	.LVL359:
 3351 0048 000000E3 		movw	r0, #:lower16:.LC0
 3352              	.LVL360:
 3353 004c 000040E3 		movt	r0, #:upper16:.LC0
 3354 0050 FEFFFFEB 		bl	R_OS_AssertCalled
 3355              	.LVL361:
 3356 0054 EEFFFFEA 		b	.L298
 3357              		.cfi_endproc
 3358              	.LFE31:
 3360              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 3361              		.align	2
 3362              		.global	xTaskRemoveFromEventList
 3363              		.syntax unified
 3364              		.arm
 3365              		.fpu neon
 3367              	xTaskRemoveFromEventList:
 3368              	.LFB32:
3056:../src/FreeRTOS/tasks.c **** TCB_t *pxUnblockedTCB;
 3369              		.loc 1 3056 0
 3370              		.cfi_startproc
 3371              		@ args = 0, pretend = 0, frame = 0
 3372              		@ frame_needed = 0, uses_anonymous_args = 0
 3373              	.LVL362:
 3374 0000 70402DE9 		push	{r4, r5, r6, lr}
 3375              		.cfi_def_cfa_offset 16
 3376              		.cfi_offset 4, -16
 3377              		.cfi_offset 5, -12
 3378              		.cfi_offset 6, -8
 3379              		.cfi_offset 14, -4
3073:../src/FreeRTOS/tasks.c **** 	configASSERT( pxUnblockedTCB );
 3380              		.loc 1 3073 0
 3381 0004 0C3090E5 		ldr	r3, [r0, #12]
 3382 0008 0C4093E5 		ldr	r4, [r3, #12]
 3383              	.LVL363:
3074:../src/FreeRTOS/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 3384              		.loc 1 3074 0
 3385 000c 000054E3 		cmp	r4, #0
 3386 0010 2500000A 		beq	.L311
 3387              	.LVL364:
 3388              	.L304:
3075:../src/FreeRTOS/tasks.c **** 
 3389              		.loc 1 3075 0
 3390 0014 185084E2 		add	r5, r4, #24
 3391 0018 0500A0E1 		mov	r0, r5
 3392 001c FEFFFFEB 		bl	uxListRemove
 3393              	.LVL365:
3077:../src/FreeRTOS/tasks.c **** 	{
 3394              		.loc 1 3077 0
 3395 0020 003000E3 		movw	r3, #:lower16:.LANCHOR16
 3396 0024 003040E3 		movt	r3, #:upper16:.LANCHOR16
 3397 0028 003093E5 		ldr	r3, [r3]
 3398 002c 000053E3 		cmp	r3, #0
 3399 0030 2200001A 		bne	.L305
3079:../src/FreeRTOS/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 3400              		.loc 1 3079 0
 3401 0034 045084E2 		add	r5, r4, #4
 3402 0038 0500A0E1 		mov	r0, r5
 3403 003c FEFFFFEB 		bl	uxListRemove
 3404              	.LVL366:
3080:../src/FreeRTOS/tasks.c **** 	}
 3405              		.loc 1 3080 0
 3406 0040 2C3094E5 		ldr	r3, [r4, #44]
 3407 0044 002000E3 		movw	r2, #:lower16:.LANCHOR13
 3408 0048 002040E3 		movt	r2, #:upper16:.LANCHOR13
 3409 004c 002092E5 		ldr	r2, [r2]
 3410 0050 020053E1 		cmp	r3, r2
3080:../src/FreeRTOS/tasks.c **** 	}
 3411              		.loc 1 3080 0 is_stmt 0 discriminator 1
 3412 0054 00200083 		movwhi	r2, #:lower16:.LANCHOR13
 3413 0058 00204083 		movthi	r2, #:upper16:.LANCHOR13
 3414 005c 00308285 		strhi	r3, [r2]
 3415              	.L306:
3080:../src/FreeRTOS/tasks.c **** 	}
 3416              		.loc 1 3080 0 discriminator 3
 3417 0060 002000E3 		movw	r2, #:lower16:.LANCHOR4
 3418 0064 002040E3 		movt	r2, #:upper16:.LANCHOR4
 3419 0068 033183E0 		add	r3, r3, r3, lsl #2
 3420 006c 0301A0E1 		lsl	r0, r3, #2
 3421 0070 0510A0E1 		mov	r1, r5
 3422 0074 000082E0 		add	r0, r2, r0
 3423 0078 FEFFFFEB 		bl	vListInsertEnd
 3424              	.LVL367:
 3425              	.L307:
3089:../src/FreeRTOS/tasks.c **** 	{
 3426              		.loc 1 3089 0 is_stmt 1
 3427 007c 2C2094E5 		ldr	r2, [r4, #44]
 3428 0080 003000E3 		movw	r3, #:lower16:.LANCHOR10
 3429 0084 003040E3 		movt	r3, #:upper16:.LANCHOR10
 3430 0088 003093E5 		ldr	r3, [r3]
 3431 008c 2C3093E5 		ldr	r3, [r3, #44]
 3432 0090 030052E1 		cmp	r2, r3
 3433 0094 0E00009A 		bls	.L309
 3434              	.LVL368:
3098:../src/FreeRTOS/tasks.c **** 	}
 3435              		.loc 1 3098 0
 3436 0098 003000E3 		movw	r3, #:lower16:.LANCHOR21
 3437 009c 003040E3 		movt	r3, #:upper16:.LANCHOR21
 3438 00a0 0100A0E3 		mov	r0, #1
 3439 00a4 000083E5 		str	r0, [r3]
 3440 00a8 7080BDE8 		pop	{r4, r5, r6, pc}
 3441              	.LVL369:
 3442              	.L311:
3074:../src/FreeRTOS/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 3443              		.loc 1 3074 0 discriminator 1
 3444 00ac 021C00E3 		movw	r1, #3074
 3445 00b0 000000E3 		movw	r0, #:lower16:.LC0
 3446              	.LVL370:
 3447 00b4 000040E3 		movt	r0, #:upper16:.LC0
 3448 00b8 FEFFFFEB 		bl	R_OS_AssertCalled
 3449              	.LVL371:
 3450 00bc D4FFFFEA 		b	.L304
 3451              	.L305:
3086:../src/FreeRTOS/tasks.c **** 	}
 3452              		.loc 1 3086 0
 3453 00c0 0510A0E1 		mov	r1, r5
 3454 00c4 000000E3 		movw	r0, #:lower16:.LANCHOR3
 3455 00c8 000040E3 		movt	r0, #:upper16:.LANCHOR3
 3456 00cc FEFFFFEB 		bl	vListInsertEnd
 3457              	.LVL372:
 3458 00d0 E9FFFFEA 		b	.L307
 3459              	.L309:
3102:../src/FreeRTOS/tasks.c **** 	}
 3460              		.loc 1 3102 0
 3461 00d4 0000A0E3 		mov	r0, #0
 3462              	.LVL373:
3120:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 3463              		.loc 1 3120 0
 3464 00d8 7080BDE8 		pop	{r4, r5, r6, pc}
 3465              		.cfi_endproc
 3466              	.LFE32:
 3468              		.section	.text.vTaskRemoveFromUnorderedEventList,"ax",%progbits
 3469              		.align	2
 3470              		.global	vTaskRemoveFromUnorderedEventList
 3471              		.syntax unified
 3472              		.arm
 3473              		.fpu neon
 3475              	vTaskRemoveFromUnorderedEventList:
 3476              	.LFB33:
3124:../src/FreeRTOS/tasks.c **** TCB_t *pxUnblockedTCB;
 3477              		.loc 1 3124 0
 3478              		.cfi_startproc
 3479              		@ args = 0, pretend = 0, frame = 0
 3480              		@ frame_needed = 0, uses_anonymous_args = 0
 3481              	.LVL374:
 3482 0000 70402DE9 		push	{r4, r5, r6, lr}
 3483              		.cfi_def_cfa_offset 16
 3484              		.cfi_offset 4, -16
 3485              		.cfi_offset 5, -12
 3486              		.cfi_offset 6, -8
 3487              		.cfi_offset 14, -4
 3488 0004 0050A0E1 		mov	r5, r0
 3489 0008 0140A0E1 		mov	r4, r1
3129:../src/FreeRTOS/tasks.c **** 
 3490              		.loc 1 3129 0
 3491 000c 003000E3 		movw	r3, #:lower16:.LANCHOR16
 3492 0010 003040E3 		movt	r3, #:upper16:.LANCHOR16
 3493 0014 003093E5 		ldr	r3, [r3]
 3494 0018 000053E3 		cmp	r3, #0
 3495 001c 2300000A 		beq	.L318
 3496              	.LVL375:
 3497              	.L313:
3132:../src/FreeRTOS/tasks.c **** 
 3498              		.loc 1 3132 0
 3499 0020 024184E3 		orr	r4, r4, #-2147483648
 3500              	.LVL376:
 3501 0024 004085E5 		str	r4, [r5]
3136:../src/FreeRTOS/tasks.c **** 	configASSERT( pxUnblockedTCB );
 3502              		.loc 1 3136 0
 3503 0028 0C4095E5 		ldr	r4, [r5, #12]
 3504              	.LVL377:
3137:../src/FreeRTOS/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
 3505              		.loc 1 3137 0
 3506 002c 000054E3 		cmp	r4, #0
 3507 0030 2300000A 		beq	.L319
 3508              	.L314:
3138:../src/FreeRTOS/tasks.c **** 
 3509              		.loc 1 3138 0
 3510 0034 0500A0E1 		mov	r0, r5
 3511 0038 FEFFFFEB 		bl	uxListRemove
 3512              	.LVL378:
3143:../src/FreeRTOS/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 3513              		.loc 1 3143 0
 3514 003c 045084E2 		add	r5, r4, #4
 3515              	.LVL379:
 3516 0040 0500A0E1 		mov	r0, r5
 3517 0044 FEFFFFEB 		bl	uxListRemove
 3518              	.LVL380:
3144:../src/FreeRTOS/tasks.c **** 
 3519              		.loc 1 3144 0
 3520 0048 2C3094E5 		ldr	r3, [r4, #44]
 3521 004c 002000E3 		movw	r2, #:lower16:.LANCHOR13
 3522 0050 002040E3 		movt	r2, #:upper16:.LANCHOR13
 3523 0054 002092E5 		ldr	r2, [r2]
 3524 0058 020053E1 		cmp	r3, r2
3144:../src/FreeRTOS/tasks.c **** 
 3525              		.loc 1 3144 0 is_stmt 0 discriminator 1
 3526 005c 00200083 		movwhi	r2, #:lower16:.LANCHOR13
 3527 0060 00204083 		movthi	r2, #:upper16:.LANCHOR13
 3528 0064 00308285 		strhi	r3, [r2]
 3529              	.L315:
3144:../src/FreeRTOS/tasks.c **** 
 3530              		.loc 1 3144 0 discriminator 3
 3531 0068 002000E3 		movw	r2, #:lower16:.LANCHOR4
 3532 006c 002040E3 		movt	r2, #:upper16:.LANCHOR4
 3533 0070 033183E0 		add	r3, r3, r3, lsl #2
 3534 0074 0301A0E1 		lsl	r0, r3, #2
 3535 0078 0510A0E1 		mov	r1, r5
 3536 007c 000082E0 		add	r0, r2, r0
 3537 0080 FEFFFFEB 		bl	vListInsertEnd
 3538              	.LVL381:
3146:../src/FreeRTOS/tasks.c **** 	{
 3539              		.loc 1 3146 0 is_stmt 1 discriminator 3
 3540 0084 2C2094E5 		ldr	r2, [r4, #44]
 3541 0088 003000E3 		movw	r3, #:lower16:.LANCHOR10
 3542 008c 003040E3 		movt	r3, #:upper16:.LANCHOR10
 3543 0090 003093E5 		ldr	r3, [r3]
 3544 0094 2C3093E5 		ldr	r3, [r3, #44]
 3545 0098 030052E1 		cmp	r2, r3
3152:../src/FreeRTOS/tasks.c **** 	}
 3546              		.loc 1 3152 0
 3547 009c 00300083 		movwhi	r3, #:lower16:.LANCHOR21
 3548 00a0 00304083 		movthi	r3, #:upper16:.LANCHOR21
 3549 00a4 0120A083 		movhi	r2, #1
 3550 00a8 00208385 		strhi	r2, [r3]
 3551 00ac 7080BDE8 		pop	{r4, r5, r6, pc}
 3552              	.LVL382:
 3553              	.L318:
3129:../src/FreeRTOS/tasks.c **** 
 3554              		.loc 1 3129 0 discriminator 1
 3555 00b0 391C00E3 		movw	r1, #3129
 3556              	.LVL383:
 3557 00b4 000000E3 		movw	r0, #:lower16:.LC0
 3558              	.LVL384:
 3559 00b8 000040E3 		movt	r0, #:upper16:.LC0
 3560 00bc FEFFFFEB 		bl	R_OS_AssertCalled
 3561              	.LVL385:
 3562 00c0 D6FFFFEA 		b	.L313
 3563              	.LVL386:
 3564              	.L319:
3137:../src/FreeRTOS/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
 3565              		.loc 1 3137 0 discriminator 1
 3566 00c4 411C00E3 		movw	r1, #3137
 3567 00c8 000000E3 		movw	r0, #:lower16:.LC0
 3568 00cc 000040E3 		movt	r0, #:upper16:.LC0
 3569 00d0 FEFFFFEB 		bl	R_OS_AssertCalled
 3570              	.LVL387:
 3571 00d4 D6FFFFEA 		b	.L314
 3572              		.cfi_endproc
 3573              	.LFE33:
 3575              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 3576              		.align	2
 3577              		.global	vTaskSetTimeOutState
 3578              		.syntax unified
 3579              		.arm
 3580              		.fpu neon
 3582              	vTaskSetTimeOutState:
 3583              	.LFB34:
3158:../src/FreeRTOS/tasks.c **** 	configASSERT( pxTimeOut );
 3584              		.loc 1 3158 0
 3585              		.cfi_startproc
 3586              		@ args = 0, pretend = 0, frame = 0
 3587              		@ frame_needed = 0, uses_anonymous_args = 0
 3588              	.LVL388:
 3589 0000 10402DE9 		push	{r4, lr}
 3590              		.cfi_def_cfa_offset 8
 3591              		.cfi_offset 4, -8
 3592              		.cfi_offset 14, -4
3159:../src/FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
 3593              		.loc 1 3159 0
 3594 0004 004050E2 		subs	r4, r0, #0
 3595 0008 0A00000A 		beq	.L323
 3596              	.LVL389:
 3597              	.L321:
3160:../src/FreeRTOS/tasks.c **** 	{
 3598              		.loc 1 3160 0
 3599 000c FEFFFFEB 		bl	vPortEnterCritical
 3600              	.LVL390:
3162:../src/FreeRTOS/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
 3601              		.loc 1 3162 0
 3602 0010 003000E3 		movw	r3, #:lower16:.LANCHOR19
 3603 0014 003040E3 		movt	r3, #:upper16:.LANCHOR19
 3604 0018 003093E5 		ldr	r3, [r3]
 3605 001c 003084E5 		str	r3, [r4]
3163:../src/FreeRTOS/tasks.c **** 	}
 3606              		.loc 1 3163 0
 3607 0020 003000E3 		movw	r3, #:lower16:.LANCHOR15
 3608 0024 003040E3 		movt	r3, #:upper16:.LANCHOR15
 3609 0028 003093E5 		ldr	r3, [r3]
 3610 002c 043084E5 		str	r3, [r4, #4]
3165:../src/FreeRTOS/tasks.c **** }
 3611              		.loc 1 3165 0
 3612 0030 FEFFFFEB 		bl	vPortExitCritical
 3613              	.LVL391:
 3614 0034 1080BDE8 		pop	{r4, pc}
 3615              	.LVL392:
 3616              	.L323:
3159:../src/FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
 3617              		.loc 1 3159 0 discriminator 1
 3618 0038 571C00E3 		movw	r1, #3159
 3619 003c 000000E3 		movw	r0, #:lower16:.LC0
 3620              	.LVL393:
 3621 0040 000040E3 		movt	r0, #:upper16:.LC0
 3622 0044 FEFFFFEB 		bl	R_OS_AssertCalled
 3623              	.LVL394:
 3624 0048 EFFFFFEA 		b	.L321
 3625              		.cfi_endproc
 3626              	.LFE34:
 3628              		.section	.text.vTaskInternalSetTimeOutState,"ax",%progbits
 3629              		.align	2
 3630              		.global	vTaskInternalSetTimeOutState
 3631              		.syntax unified
 3632              		.arm
 3633              		.fpu neon
 3635              	vTaskInternalSetTimeOutState:
 3636              	.LFB35:
3170:../src/FreeRTOS/tasks.c **** 	/* For internal use only as it does not use a critical section. */
 3637              		.loc 1 3170 0
 3638              		.cfi_startproc
 3639              		@ args = 0, pretend = 0, frame = 0
 3640              		@ frame_needed = 0, uses_anonymous_args = 0
 3641              		@ link register save eliminated.
 3642              	.LVL395:
3172:../src/FreeRTOS/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 3643              		.loc 1 3172 0
 3644 0000 003000E3 		movw	r3, #:lower16:.LANCHOR19
 3645 0004 003040E3 		movt	r3, #:upper16:.LANCHOR19
 3646 0008 003093E5 		ldr	r3, [r3]
 3647 000c 003080E5 		str	r3, [r0]
3173:../src/FreeRTOS/tasks.c **** }
 3648              		.loc 1 3173 0
 3649 0010 003000E3 		movw	r3, #:lower16:.LANCHOR15
 3650 0014 003040E3 		movt	r3, #:upper16:.LANCHOR15
 3651 0018 003093E5 		ldr	r3, [r3]
 3652 001c 043080E5 		str	r3, [r0, #4]
 3653 0020 1EFF2FE1 		bx	lr
 3654              		.cfi_endproc
 3655              	.LFE35:
 3657              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 3658              		.align	2
 3659              		.global	xTaskCheckForTimeOut
 3660              		.syntax unified
 3661              		.arm
 3662              		.fpu neon
 3664              	xTaskCheckForTimeOut:
 3665              	.LFB36:
3178:../src/FreeRTOS/tasks.c **** BaseType_t xReturn;
 3666              		.loc 1 3178 0
 3667              		.cfi_startproc
 3668              		@ args = 0, pretend = 0, frame = 0
 3669              		@ frame_needed = 0, uses_anonymous_args = 0
 3670              	.LVL396:
 3671 0000 70402DE9 		push	{r4, r5, r6, lr}
 3672              		.cfi_def_cfa_offset 16
 3673              		.cfi_offset 4, -16
 3674              		.cfi_offset 5, -12
 3675              		.cfi_offset 6, -8
 3676              		.cfi_offset 14, -4
 3677 0004 0140A0E1 		mov	r4, r1
3181:../src/FreeRTOS/tasks.c **** 	configASSERT( pxTicksToWait );
 3678              		.loc 1 3181 0
 3679 0008 005050E2 		subs	r5, r0, #0
 3680 000c 1E00000A 		beq	.L335
 3681              	.LVL397:
 3682              	.L326:
3182:../src/FreeRTOS/tasks.c **** 
 3683              		.loc 1 3182 0
 3684 0010 000054E3 		cmp	r4, #0
 3685 0014 2100000A 		beq	.L336
 3686              	.L327:
3184:../src/FreeRTOS/tasks.c **** 	{
 3687              		.loc 1 3184 0
 3688 0018 FEFFFFEB 		bl	vPortEnterCritical
 3689              	.LVL398:
 3690              	.LBB21:
3187:../src/FreeRTOS/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 3691              		.loc 1 3187 0
 3692 001c 003000E3 		movw	r3, #:lower16:.LANCHOR15
 3693 0020 003040E3 		movt	r3, #:upper16:.LANCHOR15
 3694 0024 001093E5 		ldr	r1, [r3]
 3695              	.LVL399:
3188:../src/FreeRTOS/tasks.c **** 
 3696              		.loc 1 3188 0
 3697 0028 042095E5 		ldr	r2, [r5, #4]
 3698 002c 02C041E0 		sub	ip, r1, r2
 3699              	.LVL400:
3191:../src/FreeRTOS/tasks.c **** 			{
 3700              		.loc 1 3191 0
 3701 0030 003000E3 		movw	r3, #:lower16:.LANCHOR10
 3702 0034 003040E3 		movt	r3, #:upper16:.LANCHOR10
 3703 0038 003093E5 		ldr	r3, [r3]
 3704 003c 7530D3E5 		ldrb	r3, [r3, #117]	@ zero_extendqisi2
 3705 0040 000053E3 		cmp	r3, #0
 3706 0044 1A00001A 		bne	.L337
3202:../src/FreeRTOS/tasks.c **** 			{
 3707              		.loc 1 3202 0
 3708 0048 000094E5 		ldr	r0, [r4]
 3709 004c 010070E3 		cmn	r0, #1
 3710 0050 2600000A 		beq	.L332
3212:../src/FreeRTOS/tasks.c **** 		{
 3711              		.loc 1 3212 0
 3712 0054 00E095E5 		ldr	lr, [r5]
 3713 0058 003000E3 		movw	r3, #:lower16:.LANCHOR19
 3714 005c 003040E3 		movt	r3, #:upper16:.LANCHOR19
 3715 0060 003093E5 		ldr	r3, [r3]
 3716 0064 03005EE1 		cmp	lr, r3
 3717 0068 0100000A 		beq	.L330
3212:../src/FreeRTOS/tasks.c **** 		{
 3718              		.loc 1 3212 0 is_stmt 0 discriminator 1
 3719 006c 020051E1 		cmp	r1, r2
 3720 0070 2000002A 		bcs	.L333
 3721              	.L330:
3221:../src/FreeRTOS/tasks.c **** 		{
 3722              		.loc 1 3221 0 is_stmt 1
 3723 0074 00005CE1 		cmp	ip, r0
 3724 0078 1600003A 		bcc	.L338
3230:../src/FreeRTOS/tasks.c **** 			xReturn = pdTRUE;
 3725              		.loc 1 3230 0
 3726 007c 0030A0E3 		mov	r3, #0
 3727 0080 003084E5 		str	r3, [r4]
 3728              	.LVL401:
3231:../src/FreeRTOS/tasks.c **** 		}
 3729              		.loc 1 3231 0
 3730 0084 0140A0E3 		mov	r4, #1
 3731              	.LVL402:
 3732 0088 0F0000EA 		b	.L329
 3733              	.LVL403:
 3734              	.L335:
 3735              	.LBE21:
3181:../src/FreeRTOS/tasks.c **** 	configASSERT( pxTicksToWait );
 3736              		.loc 1 3181 0 discriminator 1
 3737 008c 6D1C00E3 		movw	r1, #3181
 3738              	.LVL404:
 3739 0090 000000E3 		movw	r0, #:lower16:.LC0
 3740              	.LVL405:
 3741 0094 000040E3 		movt	r0, #:upper16:.LC0
 3742 0098 FEFFFFEB 		bl	R_OS_AssertCalled
 3743              	.LVL406:
 3744 009c DBFFFFEA 		b	.L326
 3745              	.L336:
3182:../src/FreeRTOS/tasks.c **** 
 3746              		.loc 1 3182 0 discriminator 1
 3747 00a0 6E1C00E3 		movw	r1, #3182
 3748 00a4 000000E3 		movw	r0, #:lower16:.LC0
 3749 00a8 000040E3 		movt	r0, #:upper16:.LC0
 3750 00ac FEFFFFEB 		bl	R_OS_AssertCalled
 3751              	.LVL407:
 3752 00b0 D8FFFFEA 		b	.L327
 3753              	.LVL408:
 3754              	.L337:
 3755              	.LBB22:
3195:../src/FreeRTOS/tasks.c **** 				xReturn = pdTRUE;
 3756              		.loc 1 3195 0
 3757 00b4 003000E3 		movw	r3, #:lower16:.LANCHOR10
 3758 00b8 003040E3 		movt	r3, #:upper16:.LANCHOR10
 3759 00bc 003093E5 		ldr	r3, [r3]
 3760 00c0 0020A0E3 		mov	r2, #0
 3761 00c4 7520C3E5 		strb	r2, [r3, #117]
 3762              	.LVL409:
3196:../src/FreeRTOS/tasks.c **** 			}
 3763              		.loc 1 3196 0
 3764 00c8 0140A0E3 		mov	r4, #1
 3765              	.LVL410:
 3766              	.L329:
 3767              	.LBE22:
3234:../src/FreeRTOS/tasks.c **** 
 3768              		.loc 1 3234 0
 3769 00cc FEFFFFEB 		bl	vPortExitCritical
 3770              	.LVL411:
3237:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 3771              		.loc 1 3237 0
 3772 00d0 0400A0E1 		mov	r0, r4
 3773 00d4 7080BDE8 		pop	{r4, r5, r6, pc}
 3774              	.LVL412:
 3775              	.L338:
 3776              	.LBB23:
3224:../src/FreeRTOS/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
 3777              		.loc 1 3224 0
 3778 00d8 0C0040E0 		sub	r0, r0, ip
 3779 00dc 000084E5 		str	r0, [r4]
3225:../src/FreeRTOS/tasks.c **** 			xReturn = pdFALSE;
 3780              		.loc 1 3225 0
 3781 00e0 0500A0E1 		mov	r0, r5
 3782 00e4 FEFFFFEB 		bl	vTaskInternalSetTimeOutState
 3783              	.LVL413:
3226:../src/FreeRTOS/tasks.c **** 		}
 3784              		.loc 1 3226 0
 3785 00e8 0040A0E3 		mov	r4, #0
 3786              	.LVL414:
 3787 00ec F6FFFFEA 		b	.L329
 3788              	.LVL415:
 3789              	.L332:
3207:../src/FreeRTOS/tasks.c **** 			}
 3790              		.loc 1 3207 0
 3791 00f0 0040A0E3 		mov	r4, #0
 3792              	.LVL416:
 3793 00f4 F4FFFFEA 		b	.L329
 3794              	.LVL417:
 3795              	.L333:
3219:../src/FreeRTOS/tasks.c **** 		}
 3796              		.loc 1 3219 0
 3797 00f8 0140A0E3 		mov	r4, #1
 3798              	.LVL418:
 3799 00fc F2FFFFEA 		b	.L329
 3800              	.LBE23:
 3801              		.cfi_endproc
 3802              	.LFE36:
 3804              		.section	.text.vTaskMissedYield,"ax",%progbits
 3805              		.align	2
 3806              		.global	vTaskMissedYield
 3807              		.syntax unified
 3808              		.arm
 3809              		.fpu neon
 3811              	vTaskMissedYield:
 3812              	.LFB37:
3241:../src/FreeRTOS/tasks.c **** 	xYieldPending = pdTRUE;
 3813              		.loc 1 3241 0
 3814              		.cfi_startproc
 3815              		@ args = 0, pretend = 0, frame = 0
 3816              		@ frame_needed = 0, uses_anonymous_args = 0
 3817              		@ link register save eliminated.
3242:../src/FreeRTOS/tasks.c **** }
 3818              		.loc 1 3242 0
 3819 0000 003000E3 		movw	r3, #:lower16:.LANCHOR21
 3820 0004 003040E3 		movt	r3, #:upper16:.LANCHOR21
 3821 0008 0120A0E3 		mov	r2, #1
 3822 000c 002083E5 		str	r2, [r3]
 3823 0010 1EFF2FE1 		bx	lr
 3824              		.cfi_endproc
 3825              	.LFE37:
 3827              		.section	.text.uxTaskGetTaskNumber,"ax",%progbits
 3828              		.align	2
 3829              		.global	uxTaskGetTaskNumber
 3830              		.syntax unified
 3831              		.arm
 3832              		.fpu neon
 3834              	uxTaskGetTaskNumber:
 3835              	.LFB38:
3249:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxReturn;
 3836              		.loc 1 3249 0
 3837              		.cfi_startproc
 3838              		@ args = 0, pretend = 0, frame = 0
 3839              		@ frame_needed = 0, uses_anonymous_args = 0
 3840              		@ link register save eliminated.
 3841              	.LVL419:
3253:../src/FreeRTOS/tasks.c **** 		{
 3842              		.loc 1 3253 0
 3843 0000 000050E3 		cmp	r0, #0
 3844 0004 0100000A 		beq	.L342
 3845              	.LVL420:
3256:../src/FreeRTOS/tasks.c **** 		}
 3846              		.loc 1 3256 0
 3847 0008 540090E5 		ldr	r0, [r0, #84]
 3848              	.LVL421:
 3849 000c 1EFF2FE1 		bx	lr
 3850              	.LVL422:
 3851              	.L342:
3260:../src/FreeRTOS/tasks.c **** 		}
 3852              		.loc 1 3260 0
 3853 0010 0000A0E3 		mov	r0, #0
 3854              	.LVL423:
3264:../src/FreeRTOS/tasks.c **** 
 3855              		.loc 1 3264 0
 3856 0014 1EFF2FE1 		bx	lr
 3857              		.cfi_endproc
 3858              	.LFE38:
 3860              		.section	.text.vTaskSetTaskNumber,"ax",%progbits
 3861              		.align	2
 3862              		.global	vTaskSetTaskNumber
 3863              		.syntax unified
 3864              		.arm
 3865              		.fpu neon
 3867              	vTaskSetTaskNumber:
 3868              	.LFB39:
3272:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
 3869              		.loc 1 3272 0
 3870              		.cfi_startproc
 3871              		@ args = 0, pretend = 0, frame = 0
 3872              		@ frame_needed = 0, uses_anonymous_args = 0
 3873              		@ link register save eliminated.
 3874              	.LVL424:
3275:../src/FreeRTOS/tasks.c **** 		{
 3875              		.loc 1 3275 0
 3876 0000 000050E3 		cmp	r0, #0
 3877              	.LVL425:
3278:../src/FreeRTOS/tasks.c **** 		}
 3878              		.loc 1 3278 0
 3879 0004 54108015 		strne	r1, [r0, #84]
 3880 0008 1EFF2FE1 		bx	lr
 3881              		.cfi_endproc
 3882              	.LFE39:
 3884              		.section	.text.vTaskSetThreadLocalStoragePointer,"ax",%progbits
 3885              		.align	2
 3886              		.global	vTaskSetThreadLocalStoragePointer
 3887              		.syntax unified
 3888              		.arm
 3889              		.fpu neon
 3891              	vTaskSetThreadLocalStoragePointer:
 3892              	.LFB41:
3455:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
 3893              		.loc 1 3455 0
 3894              		.cfi_startproc
 3895              		@ args = 0, pretend = 0, frame = 0
 3896              		@ frame_needed = 0, uses_anonymous_args = 0
 3897              		@ link register save eliminated.
 3898              	.LVL426:
3458:../src/FreeRTOS/tasks.c **** 		{
 3899              		.loc 1 3458 0
 3900 0000 020051E3 		cmp	r1, #2
 3901 0004 1EFF2FC1 		bxgt	lr
3460:../src/FreeRTOS/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
 3902              		.loc 1 3460 0
 3903 0008 000050E3 		cmp	r0, #0
 3904 000c 0200000A 		beq	.L349
 3905              	.LVL427:
 3906              	.L347:
3461:../src/FreeRTOS/tasks.c **** 		}
 3907              		.loc 1 3461 0 discriminator 4
 3908 0010 181081E2 		add	r1, r1, #24
 3909              	.LVL428:
 3910 0014 012180E7 		str	r2, [r0, r1, lsl #2]
 3911 0018 1EFF2FE1 		bx	lr
 3912              	.LVL429:
 3913              	.L349:
3460:../src/FreeRTOS/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
 3914              		.loc 1 3460 0 discriminator 1
 3915 001c 003000E3 		movw	r3, #:lower16:.LANCHOR10
 3916 0020 003040E3 		movt	r3, #:upper16:.LANCHOR10
 3917 0024 000093E5 		ldr	r0, [r3]
 3918              	.LVL430:
 3919 0028 F8FFFFEA 		b	.L347
 3920              		.cfi_endproc
 3921              	.LFE41:
 3923              		.section	.text.pvTaskGetThreadLocalStoragePointer,"ax",%progbits
 3924              		.align	2
 3925              		.global	pvTaskGetThreadLocalStoragePointer
 3926              		.syntax unified
 3927              		.arm
 3928              		.fpu neon
 3930              	pvTaskGetThreadLocalStoragePointer:
 3931              	.LFB42:
3471:../src/FreeRTOS/tasks.c **** 	void *pvReturn = NULL;
 3932              		.loc 1 3471 0
 3933              		.cfi_startproc
 3934              		@ args = 0, pretend = 0, frame = 0
 3935              		@ frame_needed = 0, uses_anonymous_args = 0
 3936              		@ link register save eliminated.
 3937              	.LVL431:
3475:../src/FreeRTOS/tasks.c **** 		{
 3938              		.loc 1 3475 0
 3939 0000 020051E3 		cmp	r1, #2
 3940 0004 080000CA 		bgt	.L353
3477:../src/FreeRTOS/tasks.c **** 			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
 3941              		.loc 1 3477 0
 3942 0008 000050E3 		cmp	r0, #0
 3943 000c 0200000A 		beq	.L355
 3944              	.LVL432:
 3945              	.L352:
3478:../src/FreeRTOS/tasks.c **** 		}
 3946              		.loc 1 3478 0 discriminator 4
 3947 0010 181081E2 		add	r1, r1, #24
 3948              	.LVL433:
 3949 0014 010190E7 		ldr	r0, [r0, r1, lsl #2]
 3950              	.LVL434:
 3951 0018 1EFF2FE1 		bx	lr
 3952              	.LVL435:
 3953              	.L355:
3477:../src/FreeRTOS/tasks.c **** 			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
 3954              		.loc 1 3477 0 discriminator 1
 3955 001c 003000E3 		movw	r3, #:lower16:.LANCHOR10
 3956 0020 003040E3 		movt	r3, #:upper16:.LANCHOR10
 3957 0024 000093E5 		ldr	r0, [r3]
 3958              	.LVL436:
 3959 0028 F8FFFFEA 		b	.L352
 3960              	.LVL437:
 3961              	.L353:
3482:../src/FreeRTOS/tasks.c **** 		}
 3962              		.loc 1 3482 0
 3963 002c 0000A0E3 		mov	r0, #0
 3964              	.LVL438:
3486:../src/FreeRTOS/tasks.c **** 
 3965              		.loc 1 3486 0
 3966 0030 1EFF2FE1 		bx	lr
 3967              		.cfi_endproc
 3968              	.LFE42:
 3970              		.section	.text.vTaskGetInfo,"ax",%progbits
 3971              		.align	2
 3972              		.global	vTaskGetInfo
 3973              		.syntax unified
 3974              		.arm
 3975              		.fpu neon
 3977              	vTaskGetInfo:
 3978              	.LFB45:
3571:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
 3979              		.loc 1 3571 0
 3980              		.cfi_startproc
 3981              		@ args = 0, pretend = 0, frame = 0
 3982              		@ frame_needed = 0, uses_anonymous_args = 0
 3983              	.LVL439:
 3984 0000 70402DE9 		push	{r4, r5, r6, lr}
 3985              		.cfi_def_cfa_offset 16
 3986              		.cfi_offset 4, -16
 3987              		.cfi_offset 5, -12
 3988              		.cfi_offset 6, -8
 3989              		.cfi_offset 14, -4
 3990 0004 0150A0E1 		mov	r5, r1
 3991 0008 0260A0E1 		mov	r6, r2
3575:../src/FreeRTOS/tasks.c **** 
 3992              		.loc 1 3575 0
 3993 000c 004050E2 		subs	r4, r0, #0
 3994 0010 1B00000A 		beq	.L366
 3995              	.LVL440:
 3996              	.L357:
3577:../src/FreeRTOS/tasks.c **** 		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
 3997              		.loc 1 3577 0 discriminator 4
 3998 0014 004085E5 		str	r4, [r5]
3578:../src/FreeRTOS/tasks.c **** 		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 3999              		.loc 1 3578 0 discriminator 4
 4000 0018 342084E2 		add	r2, r4, #52
 4001 001c 042085E5 		str	r2, [r5, #4]
3579:../src/FreeRTOS/tasks.c **** 		pxTaskStatus->pxStackBase = pxTCB->pxStack;
 4002              		.loc 1 3579 0 discriminator 4
 4003 0020 2C2094E5 		ldr	r2, [r4, #44]
 4004 0024 102085E5 		str	r2, [r5, #16]
3580:../src/FreeRTOS/tasks.c **** 		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 4005              		.loc 1 3580 0 discriminator 4
 4006 0028 302094E5 		ldr	r2, [r4, #48]
 4007 002c 1C2085E5 		str	r2, [r5, #28]
3581:../src/FreeRTOS/tasks.c **** 
 4008              		.loc 1 3581 0 discriminator 4
 4009 0030 502094E5 		ldr	r2, [r4, #80]
 4010 0034 082085E5 		str	r2, [r5, #8]
3585:../src/FreeRTOS/tasks.c **** 		}
 4011              		.loc 1 3585 0 discriminator 4
 4012 0038 582094E5 		ldr	r2, [r4, #88]
 4013 003c 142085E5 		str	r2, [r5, #20]
3595:../src/FreeRTOS/tasks.c **** 		}
 4014              		.loc 1 3595 0 discriminator 4
 4015 0040 6C2094E5 		ldr	r2, [r4, #108]
 4016 0044 182085E5 		str	r2, [r5, #24]
3606:../src/FreeRTOS/tasks.c **** 		{
 4017              		.loc 1 3606 0 discriminator 4
 4018 0048 050053E3 		cmp	r3, #5
 4019 004c 1A00000A 		beq	.L358
3608:../src/FreeRTOS/tasks.c **** 			{
 4020              		.loc 1 3608 0
 4021 0050 002000E3 		movw	r2, #:lower16:.LANCHOR10
 4022 0054 002040E3 		movt	r2, #:upper16:.LANCHOR10
 4023 0058 002092E5 		ldr	r2, [r2]
 4024 005c 020054E1 		cmp	r4, r2
 4025 0060 0B00000A 		beq	.L367
3614:../src/FreeRTOS/tasks.c **** 
 4026              		.loc 1 3614 0
 4027 0064 0C30C5E5 		strb	r3, [r5, #12]
3621:../src/FreeRTOS/tasks.c **** 					{
 4028              		.loc 1 3621 0
 4029 0068 030053E3 		cmp	r3, #3
 4030 006c 0B00000A 		beq	.L368
 4031              	.LVL441:
 4032              	.L360:
3643:../src/FreeRTOS/tasks.c **** 		{
 4033              		.loc 1 3643 0
 4034 0070 000056E3 		cmp	r6, #0
 4035 0074 1400001A 		bne	.L369
3657:../src/FreeRTOS/tasks.c **** 		}
 4036              		.loc 1 3657 0
 4037 0078 0030A0E3 		mov	r3, #0
 4038 007c B032C5E1 		strh	r3, [r5, #32]	@ movhi
 4039 0080 7080BDE8 		pop	{r4, r5, r6, pc}
 4040              	.LVL442:
 4041              	.L366:
3575:../src/FreeRTOS/tasks.c **** 
 4042              		.loc 1 3575 0 discriminator 1
 4043 0084 002000E3 		movw	r2, #:lower16:.LANCHOR10
 4044              	.LVL443:
 4045 0088 002040E3 		movt	r2, #:upper16:.LANCHOR10
 4046 008c 004092E5 		ldr	r4, [r2]
 4047 0090 DFFFFFEA 		b	.L357
 4048              	.LVL444:
 4049              	.L367:
3610:../src/FreeRTOS/tasks.c **** 			}
 4050              		.loc 1 3610 0
 4051 0094 0030A0E3 		mov	r3, #0
 4052              	.LVL445:
 4053 0098 0C30C5E5 		strb	r3, [r5, #12]
 4054 009c F3FFFFEA 		b	.L360
 4055              	.LVL446:
 4056              	.L368:
3623:../src/FreeRTOS/tasks.c **** 						{
 4057              		.loc 1 3623 0
 4058 00a0 FEFFFFEB 		bl	vTaskSuspendAll
 4059              	.LVL447:
3625:../src/FreeRTOS/tasks.c **** 							{
 4060              		.loc 1 3625 0
 4061 00a4 283094E5 		ldr	r3, [r4, #40]
 4062 00a8 000053E3 		cmp	r3, #0
3627:../src/FreeRTOS/tasks.c **** 							}
 4063              		.loc 1 3627 0
 4064 00ac 0230A013 		movne	r3, #2
 4065 00b0 0C30C515 		strbne	r3, [r5, #12]
 4066              	.L361:
3630:../src/FreeRTOS/tasks.c **** 					}
 4067              		.loc 1 3630 0
 4068 00b4 FEFFFFEB 		bl	xTaskResumeAll
 4069              	.LVL448:
 4070 00b8 ECFFFFEA 		b	.L360
 4071              	.LVL449:
 4072              	.L358:
3638:../src/FreeRTOS/tasks.c **** 		}
 4073              		.loc 1 3638 0
 4074 00bc 0400A0E1 		mov	r0, r4
 4075              	.LVL450:
 4076 00c0 FEFFFFEB 		bl	eTaskGetState
 4077              	.LVL451:
 4078 00c4 0C00C5E5 		strb	r0, [r5, #12]
 4079 00c8 E8FFFFEA 		b	.L360
 4080              	.L369:
3651:../src/FreeRTOS/tasks.c **** 			}
 4081              		.loc 1 3651 0
 4082 00cc 300094E5 		ldr	r0, [r4, #48]
 4083 00d0 FEFFFFEB 		bl	prvTaskCheckFreeStackSpace
 4084              	.LVL452:
 4085 00d4 B002C5E1 		strh	r0, [r5, #32]	@ movhi
 4086 00d8 7080BDE8 		pop	{r4, r5, r6, pc}
 4087              		.cfi_endproc
 4088              	.LFE45:
 4090              		.section	.text.prvListTasksWithinSingleList,"ax",%progbits
 4091              		.align	2
 4092              		.syntax unified
 4093              		.arm
 4094              		.fpu neon
 4096              	prvListTasksWithinSingleList:
 4097              	.LFB46:
3667:../src/FreeRTOS/tasks.c **** 	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
 4098              		.loc 1 3667 0
 4099              		.cfi_startproc
 4100              		@ args = 0, pretend = 0, frame = 0
 4101              		@ frame_needed = 0, uses_anonymous_args = 0
 4102              	.LVL453:
 4103 0000 F0472DE9 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 4104              		.cfi_def_cfa_offset 32
 4105              		.cfi_offset 4, -32
 4106              		.cfi_offset 5, -28
 4107              		.cfi_offset 6, -24
 4108              		.cfi_offset 7, -20
 4109              		.cfi_offset 8, -16
 4110              		.cfi_offset 9, -12
 4111              		.cfi_offset 10, -8
 4112              		.cfi_offset 14, -4
 4113              	.LVL454:
3671:../src/FreeRTOS/tasks.c **** 		{
 4114              		.loc 1 3671 0
 4115 0004 003091E5 		ldr	r3, [r1]
 4116 0008 000053E3 		cmp	r3, #0
 4117 000c 2200000A 		beq	.L375
 4118              	.LVL455:
 4119              	.LBB24:
3673:../src/FreeRTOS/tasks.c **** 
 4120              		.loc 1 3673 0
 4121 0010 043091E5 		ldr	r3, [r1, #4]
 4122 0014 043093E5 		ldr	r3, [r3, #4]
 4123 0018 043081E5 		str	r3, [r1, #4]
 4124 001c 089081E2 		add	r9, r1, #8
 4125 0020 090053E1 		cmp	r3, r9
 4126 0024 0600000A 		beq	.L377
 4127              	.L372:
 4128 0028 0280A0E1 		mov	r8, r2
 4129 002c 0150A0E1 		mov	r5, r1
 4130 0030 0070A0E1 		mov	r7, r0
3673:../src/FreeRTOS/tasks.c **** 
 4131              		.loc 1 3673 0 is_stmt 0 discriminator 3
 4132 0034 043091E5 		ldr	r3, [r1, #4]
 4133 0038 0CA093E5 		ldr	r10, [r3, #12]
 4134              	.LVL456:
 4135              	.LBE24:
3669:../src/FreeRTOS/tasks.c **** 
 4136              		.loc 1 3669 0 is_stmt 1 discriminator 3
 4137 003c 0040A0E3 		mov	r4, #0
 4138 0040 0E0000EA 		b	.L374
 4139              	.LVL457:
 4140              	.L377:
 4141              	.LBB25:
3673:../src/FreeRTOS/tasks.c **** 
 4142              		.loc 1 3673 0 discriminator 1
 4143 0044 043093E5 		ldr	r3, [r3, #4]
 4144 0048 043081E5 		str	r3, [r1, #4]
 4145 004c F5FFFFEA 		b	.L372
 4146              	.LVL458:
 4147              	.L373:
 4148              	.LBE25:
 4149              	.LBB26:
3681:../src/FreeRTOS/tasks.c **** 				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
 4150              		.loc 1 3681 0 discriminator 3
 4151 0050 043095E5 		ldr	r3, [r5, #4]
 4152 0054 0C6093E5 		ldr	r6, [r3, #12]
 4153              	.LVL459:
 4154              	.LBE26:
3682:../src/FreeRTOS/tasks.c **** 				uxTask++;
 4155              		.loc 1 3682 0 discriminator 3
 4156 0058 843184E0 		add	r3, r4, r4, lsl #3
 4157 005c 0311A0E1 		lsl	r1, r3, #2
 4158 0060 0830A0E1 		mov	r3, r8
 4159 0064 0120A0E3 		mov	r2, #1
 4160 0068 011087E0 		add	r1, r7, r1
 4161 006c 0600A0E1 		mov	r0, r6
 4162 0070 FEFFFFEB 		bl	vTaskGetInfo
 4163              	.LVL460:
3683:../src/FreeRTOS/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
 4164              		.loc 1 3683 0 discriminator 3
 4165 0074 014084E2 		add	r4, r4, #1
 4166              	.LVL461:
3684:../src/FreeRTOS/tasks.c **** 		}
 4167              		.loc 1 3684 0 discriminator 3
 4168 0078 06005AE1 		cmp	r10, r6
 4169 007c 0700000A 		beq	.L370
 4170              	.LVL462:
 4171              	.L374:
 4172              	.LBB27:
3681:../src/FreeRTOS/tasks.c **** 				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
 4173              		.loc 1 3681 0
 4174 0080 043095E5 		ldr	r3, [r5, #4]
 4175 0084 043093E5 		ldr	r3, [r3, #4]
 4176 0088 043085E5 		str	r3, [r5, #4]
 4177 008c 030059E1 		cmp	r9, r3
3681:../src/FreeRTOS/tasks.c **** 				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
 4178              		.loc 1 3681 0 is_stmt 0 discriminator 1
 4179 0090 04309305 		ldreq	r3, [r3, #4]
 4180 0094 04308505 		streq	r3, [r5, #4]
 4181 0098 ECFFFFEA 		b	.L373
 4182              	.LVL463:
 4183              	.L375:
 4184              	.LBE27:
3669:../src/FreeRTOS/tasks.c **** 
 4185              		.loc 1 3669 0 is_stmt 1
 4186 009c 0040A0E3 		mov	r4, #0
 4187              	.LVL464:
 4188              	.L370:
3692:../src/FreeRTOS/tasks.c **** 
 4189              		.loc 1 3692 0
 4190 00a0 0400A0E1 		mov	r0, r4
 4191 00a4 F087BDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 4192              		.cfi_endproc
 4193              	.LFE46:
 4195              		.section	.text.uxTaskGetSystemState,"ax",%progbits
 4196              		.align	2
 4197              		.global	uxTaskGetSystemState
 4198              		.syntax unified
 4199              		.arm
 4200              		.fpu neon
 4202              	uxTaskGetSystemState:
 4203              	.LFB25:
2467:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 4204              		.loc 1 2467 0
 4205              		.cfi_startproc
 4206              		@ args = 0, pretend = 0, frame = 0
 4207              		@ frame_needed = 0, uses_anonymous_args = 0
 4208              	.LVL465:
 4209 0000 F0412DE9 		push	{r4, r5, r6, r7, r8, lr}
 4210              		.cfi_def_cfa_offset 24
 4211              		.cfi_offset 4, -24
 4212              		.cfi_offset 5, -20
 4213              		.cfi_offset 6, -16
 4214              		.cfi_offset 7, -12
 4215              		.cfi_offset 8, -8
 4216              		.cfi_offset 14, -4
 4217 0004 0070A0E1 		mov	r7, r0
 4218 0008 0140A0E1 		mov	r4, r1
 4219 000c 0260A0E1 		mov	r6, r2
 4220              	.LVL466:
2470:../src/FreeRTOS/tasks.c **** 		{
 4221              		.loc 1 2470 0
 4222 0010 FEFFFFEB 		bl	vTaskSuspendAll
 4223              	.LVL467:
2473:../src/FreeRTOS/tasks.c **** 			{
 4224              		.loc 1 2473 0
 4225 0014 003000E3 		movw	r3, #:lower16:.LANCHOR9
 4226 0018 003040E3 		movt	r3, #:upper16:.LANCHOR9
 4227 001c 003093E5 		ldr	r3, [r3]
 4228 0020 040053E1 		cmp	r3, r4
 4229 0024 3800008A 		bhi	.L381
 4230 0028 1440A0E3 		mov	r4, #20
 4231              	.LVL468:
 4232 002c 0050A0E3 		mov	r5, #0
 4233              	.LVL469:
 4234              	.L380:
2479:../src/FreeRTOS/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists
 4235              		.loc 1 2479 0 discriminator 1
 4236 0030 014044E2 		sub	r4, r4, #1
 4237              	.LVL470:
2480:../src/FreeRTOS/tasks.c **** 
 4238              		.loc 1 2480 0 discriminator 1
 4239 0034 853185E0 		add	r3, r5, r5, lsl #3
 4240 0038 0301A0E1 		lsl	r0, r3, #2
 4241 003c 003000E3 		movw	r3, #:lower16:.LANCHOR4
 4242 0040 003040E3 		movt	r3, #:upper16:.LANCHOR4
 4243 0044 042184E0 		add	r2, r4, r4, lsl #2
 4244 0048 0211A0E1 		lsl	r1, r2, #2
 4245 004c 0120A0E3 		mov	r2, #1
 4246 0050 011083E0 		add	r1, r3, r1
 4247 0054 000087E0 		add	r0, r7, r0
 4248 0058 FEFFFFEB 		bl	prvListTasksWithinSingleList
 4249              	.LVL471:
 4250 005c 005085E0 		add	r5, r5, r0
 4251              	.LVL472:
2482:../src/FreeRTOS/tasks.c **** 
 4252              		.loc 1 2482 0 discriminator 1
 4253 0060 000054E3 		cmp	r4, #0
 4254 0064 F1FFFF1A 		bne	.L380
2486:../src/FreeRTOS/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverfl
 4255              		.loc 1 2486 0
 4256 0068 853185E0 		add	r3, r5, r5, lsl #3
 4257 006c 0301A0E1 		lsl	r0, r3, #2
 4258 0070 003000E3 		movw	r3, #:lower16:.LANCHOR0
 4259 0074 003040E3 		movt	r3, #:upper16:.LANCHOR0
 4260 0078 001093E5 		ldr	r1, [r3]
 4261 007c 0220A0E3 		mov	r2, #2
 4262 0080 000087E0 		add	r0, r7, r0
 4263 0084 FEFFFFEB 		bl	prvListTasksWithinSingleList
 4264              	.LVL473:
 4265 0088 004085E0 		add	r4, r5, r0
 4266              	.LVL474:
2487:../src/FreeRTOS/tasks.c **** 
 4267              		.loc 1 2487 0
 4268 008c 843184E0 		add	r3, r4, r4, lsl #3
 4269 0090 0301A0E1 		lsl	r0, r3, #2
 4270 0094 003000E3 		movw	r3, #:lower16:.LANCHOR8
 4271 0098 003040E3 		movt	r3, #:upper16:.LANCHOR8
 4272 009c 001093E5 		ldr	r1, [r3]
 4273 00a0 0220A0E3 		mov	r2, #2
 4274 00a4 000087E0 		add	r0, r7, r0
 4275 00a8 FEFFFFEB 		bl	prvListTasksWithinSingleList
 4276              	.LVL475:
 4277 00ac 004084E0 		add	r4, r4, r0
 4278              	.LVL476:
2493:../src/FreeRTOS/tasks.c **** 				}
 4279              		.loc 1 2493 0
 4280 00b0 843184E0 		add	r3, r4, r4, lsl #3
 4281 00b4 0301A0E1 		lsl	r0, r3, #2
 4282 00b8 0420A0E3 		mov	r2, #4
 4283 00bc 001000E3 		movw	r1, #:lower16:.LANCHOR7
 4284 00c0 001040E3 		movt	r1, #:upper16:.LANCHOR7
 4285 00c4 000087E0 		add	r0, r7, r0
 4286 00c8 FEFFFFEB 		bl	prvListTasksWithinSingleList
 4287              	.LVL477:
 4288 00cc 004084E0 		add	r4, r4, r0
 4289              	.LVL478:
2501:../src/FreeRTOS/tasks.c **** 				}
 4290              		.loc 1 2501 0
 4291 00d0 843184E0 		add	r3, r4, r4, lsl #3
 4292 00d4 0301A0E1 		lsl	r0, r3, #2
 4293 00d8 0320A0E3 		mov	r2, #3
 4294 00dc 001000E3 		movw	r1, #:lower16:.LANCHOR2
 4295 00e0 001040E3 		movt	r1, #:upper16:.LANCHOR2
 4296 00e4 000087E0 		add	r0, r7, r0
 4297 00e8 FEFFFFEB 		bl	prvListTasksWithinSingleList
 4298              	.LVL479:
 4299 00ec 004084E0 		add	r4, r4, r0
 4300              	.LVL480:
2507:../src/FreeRTOS/tasks.c **** 					{
 4301              		.loc 1 2507 0
 4302 00f0 000056E3 		cmp	r6, #0
 4303 00f4 0100000A 		beq	.L379
2512:../src/FreeRTOS/tasks.c **** 						#endif
 4304              		.loc 1 2512 0
 4305 00f8 FEFFFFEB 		bl	ulGetRunTimeCounterValue
 4306              	.LVL481:
 4307 00fc 000086E5 		str	r0, [r6]
 4308              	.LVL482:
 4309              	.L379:
2530:../src/FreeRTOS/tasks.c **** 
 4310              		.loc 1 2530 0
 4311 0100 FEFFFFEB 		bl	xTaskResumeAll
 4312              	.LVL483:
2533:../src/FreeRTOS/tasks.c **** 
 4313              		.loc 1 2533 0
 4314 0104 0400A0E1 		mov	r0, r4
 4315 0108 F081BDE8 		pop	{r4, r5, r6, r7, r8, pc}
 4316              	.LVL484:
 4317              	.L381:
2468:../src/FreeRTOS/tasks.c **** 
 4318              		.loc 1 2468 0
 4319 010c 0040A0E3 		mov	r4, #0
 4320              	.LVL485:
 4321 0110 FAFFFFEA 		b	.L379
 4322              		.cfi_endproc
 4323              	.LFE25:
 4325              		.section	.text.uxTaskGetStackHighWaterMark,"ax",%progbits
 4326              		.align	2
 4327              		.global	uxTaskGetStackHighWaterMark
 4328              		.syntax unified
 4329              		.arm
 4330              		.fpu neon
 4332              	uxTaskGetStackHighWaterMark:
 4333              	.LFB48:
3720:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
 4334              		.loc 1 3720 0
 4335              		.cfi_startproc
 4336              		@ args = 0, pretend = 0, frame = 0
 4337              		@ frame_needed = 0, uses_anonymous_args = 0
 4338              	.LVL486:
 4339 0000 10402DE9 		push	{r4, lr}
 4340              		.cfi_def_cfa_offset 8
 4341              		.cfi_offset 4, -8
 4342              		.cfi_offset 14, -4
3725:../src/FreeRTOS/tasks.c **** 
 4343              		.loc 1 3725 0
 4344 0004 000050E3 		cmp	r0, #0
 4345 0008 0200000A 		beq	.L387
 4346              	.LVL487:
 4347              	.L384:
3737:../src/FreeRTOS/tasks.c **** 
 4348              		.loc 1 3737 0 discriminator 4
 4349 000c 300090E5 		ldr	r0, [r0, #48]
 4350              	.LVL488:
 4351 0010 FEFFFFEB 		bl	prvTaskCheckFreeStackSpace
 4352              	.LVL489:
3740:../src/FreeRTOS/tasks.c **** 
 4353              		.loc 1 3740 0 discriminator 4
 4354 0014 1080BDE8 		pop	{r4, pc}
 4355              	.LVL490:
 4356              	.L387:
3725:../src/FreeRTOS/tasks.c **** 
 4357              		.loc 1 3725 0 discriminator 1
 4358 0018 003000E3 		movw	r3, #:lower16:.LANCHOR10
 4359 001c 003040E3 		movt	r3, #:upper16:.LANCHOR10
 4360 0020 000093E5 		ldr	r0, [r3]
 4361              	.LVL491:
 4362 0024 F8FFFFEA 		b	.L384
 4363              		.cfi_endproc
 4364              	.LFE48:
 4366              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 4367              		.align	2
 4368              		.global	xTaskGetCurrentTaskHandle
 4369              		.syntax unified
 4370              		.arm
 4371              		.fpu neon
 4373              	xTaskGetCurrentTaskHandle:
 4374              	.LFB51:
3828:../src/FreeRTOS/tasks.c **** 	TaskHandle_t xReturn;
 4375              		.loc 1 3828 0
 4376              		.cfi_startproc
 4377              		@ args = 0, pretend = 0, frame = 0
 4378              		@ frame_needed = 0, uses_anonymous_args = 0
 4379              		@ link register save eliminated.
3834:../src/FreeRTOS/tasks.c **** 
 4380              		.loc 1 3834 0
 4381 0000 003000E3 		movw	r3, #:lower16:.LANCHOR10
 4382 0004 003040E3 		movt	r3, #:upper16:.LANCHOR10
 4383 0008 000093E5 		ldr	r0, [r3]
 4384              	.LVL492:
3837:../src/FreeRTOS/tasks.c **** 
 4385              		.loc 1 3837 0
 4386 000c 1EFF2FE1 		bx	lr
 4387              		.cfi_endproc
 4388              	.LFE51:
 4390              		.section	.text.xTaskGetSchedulerState,"ax",%progbits
 4391              		.align	2
 4392              		.global	xTaskGetSchedulerState
 4393              		.syntax unified
 4394              		.arm
 4395              		.fpu neon
 4397              	xTaskGetSchedulerState:
 4398              	.LFB52:
3845:../src/FreeRTOS/tasks.c **** 	BaseType_t xReturn;
 4399              		.loc 1 3845 0
 4400              		.cfi_startproc
 4401              		@ args = 0, pretend = 0, frame = 0
 4402              		@ frame_needed = 0, uses_anonymous_args = 0
 4403              		@ link register save eliminated.
3848:../src/FreeRTOS/tasks.c **** 		{
 4404              		.loc 1 3848 0
 4405 0000 003000E3 		movw	r3, #:lower16:.LANCHOR11
 4406 0004 003040E3 		movt	r3, #:upper16:.LANCHOR11
 4407 0008 003093E5 		ldr	r3, [r3]
 4408 000c 000053E3 		cmp	r3, #0
 4409 0010 0600000A 		beq	.L391
3854:../src/FreeRTOS/tasks.c **** 			{
 4410              		.loc 1 3854 0
 4411 0014 003000E3 		movw	r3, #:lower16:.LANCHOR16
 4412 0018 003040E3 		movt	r3, #:upper16:.LANCHOR16
 4413 001c 003093E5 		ldr	r3, [r3]
 4414 0020 000053E3 		cmp	r3, #0
 4415 0024 0300001A 		bne	.L392
3856:../src/FreeRTOS/tasks.c **** 			}
 4416              		.loc 1 3856 0
 4417 0028 0200A0E3 		mov	r0, #2
 4418 002c 1EFF2FE1 		bx	lr
 4419              	.L391:
3850:../src/FreeRTOS/tasks.c **** 		}
 4420              		.loc 1 3850 0
 4421 0030 0100A0E3 		mov	r0, #1
 4422 0034 1EFF2FE1 		bx	lr
 4423              	.L392:
3860:../src/FreeRTOS/tasks.c **** 			}
 4424              		.loc 1 3860 0
 4425 0038 0000A0E3 		mov	r0, #0
 4426              	.LVL493:
3865:../src/FreeRTOS/tasks.c **** 
 4427              		.loc 1 3865 0
 4428 003c 1EFF2FE1 		bx	lr
 4429              		.cfi_endproc
 4430              	.LFE52:
 4432              		.section	.text.xTaskPriorityInherit,"ax",%progbits
 4433              		.align	2
 4434              		.global	xTaskPriorityInherit
 4435              		.syntax unified
 4436              		.arm
 4437              		.fpu neon
 4439              	xTaskPriorityInherit:
 4440              	.LFB53:
3873:../src/FreeRTOS/tasks.c **** 	TCB_t * const pxMutexHolderTCB = ( TCB_t * ) pxMutexHolder;
 4441              		.loc 1 3873 0
 4442              		.cfi_startproc
 4443              		@ args = 0, pretend = 0, frame = 0
 4444              		@ frame_needed = 0, uses_anonymous_args = 0
 4445              	.LVL494:
 4446 0000 70402DE9 		push	{r4, r5, r6, lr}
 4447              		.cfi_def_cfa_offset 16
 4448              		.cfi_offset 4, -16
 4449              		.cfi_offset 5, -12
 4450              		.cfi_offset 6, -8
 4451              		.cfi_offset 14, -4
 4452              	.LVL495:
3880:../src/FreeRTOS/tasks.c **** 		{
 4453              		.loc 1 3880 0
 4454 0004 005050E2 		subs	r5, r0, #0
 4455 0008 4600000A 		beq	.L400
3885:../src/FreeRTOS/tasks.c **** 			{
 4456              		.loc 1 3885 0
 4457 000c 2C3095E5 		ldr	r3, [r5, #44]
 4458 0010 002000E3 		movw	r2, #:lower16:.LANCHOR10
 4459 0014 002040E3 		movt	r2, #:upper16:.LANCHOR10
 4460 0018 002092E5 		ldr	r2, [r2]
 4461 001c 2C2092E5 		ldr	r2, [r2, #44]
 4462 0020 020053E1 		cmp	r3, r2
 4463 0024 3400002A 		bcs	.L395
3890:../src/FreeRTOS/tasks.c **** 				{
 4464              		.loc 1 3890 0
 4465 0028 182095E5 		ldr	r2, [r5, #24]
 4466 002c 000052E3 		cmp	r2, #0
 4467 0030 050000BA 		blt	.L396
3892:../src/FreeRTOS/tasks.c **** 				}
 4468              		.loc 1 3892 0
 4469 0034 002000E3 		movw	r2, #:lower16:.LANCHOR10
 4470 0038 002040E3 		movt	r2, #:upper16:.LANCHOR10
 4471 003c 002092E5 		ldr	r2, [r2]
 4472 0040 2C2092E5 		ldr	r2, [r2, #44]
 4473 0044 142062E2 		rsb	r2, r2, #20
 4474 0048 182085E5 		str	r2, [r5, #24]
 4475              	.L396:
3901:../src/FreeRTOS/tasks.c **** 				{
 4476              		.loc 1 3901 0
 4477 004c 14C095E5 		ldr	ip, [r5, #20]
 4478 0050 002000E3 		movw	r2, #:lower16:.LANCHOR4
 4479 0054 002040E3 		movt	r2, #:upper16:.LANCHOR4
 4480 0058 033183E0 		add	r3, r3, r3, lsl #2
 4481 005c 0311A0E1 		lsl	r1, r3, #2
 4482 0060 012082E0 		add	r2, r2, r1
 4483 0064 02005CE1 		cmp	ip, r2
 4484 0068 0900000A 		beq	.L404
 4485 006c 0030A0E3 		mov	r3, #0
 4486              	.L397:
3901:../src/FreeRTOS/tasks.c **** 				{
 4487              		.loc 1 3901 0 is_stmt 0 discriminator 4
 4488 0070 000053E3 		cmp	r3, #0
 4489 0074 0800001A 		bne	.L405
3919:../src/FreeRTOS/tasks.c **** 				}
 4490              		.loc 1 3919 0 is_stmt 1
 4491 0078 003000E3 		movw	r3, #:lower16:.LANCHOR10
 4492 007c 003040E3 		movt	r3, #:upper16:.LANCHOR10
 4493 0080 003093E5 		ldr	r3, [r3]
 4494 0084 2C3093E5 		ldr	r3, [r3, #44]
 4495 0088 2C3085E5 		str	r3, [r5, #44]
3925:../src/FreeRTOS/tasks.c **** 			}
 4496              		.loc 1 3925 0
 4497 008c 0100A0E3 		mov	r0, #1
 4498              	.LVL496:
 4499 0090 7080BDE8 		pop	{r4, r5, r6, pc}
 4500              	.LVL497:
 4501              	.L404:
3901:../src/FreeRTOS/tasks.c **** 				{
 4502              		.loc 1 3901 0
 4503 0094 0130A0E3 		mov	r3, #1
 4504 0098 F4FFFFEA 		b	.L397
 4505              	.L405:
3903:../src/FreeRTOS/tasks.c **** 					{
 4506              		.loc 1 3903 0
 4507 009c 044085E2 		add	r4, r5, #4
 4508 00a0 0400A0E1 		mov	r0, r4
 4509              	.LVL498:
 4510 00a4 FEFFFFEB 		bl	uxListRemove
 4511              	.LVL499:
3913:../src/FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxMutexHolderTCB );
 4512              		.loc 1 3913 0
 4513 00a8 003000E3 		movw	r3, #:lower16:.LANCHOR10
 4514 00ac 003040E3 		movt	r3, #:upper16:.LANCHOR10
 4515 00b0 003093E5 		ldr	r3, [r3]
 4516 00b4 2C3093E5 		ldr	r3, [r3, #44]
 4517 00b8 2C3085E5 		str	r3, [r5, #44]
3914:../src/FreeRTOS/tasks.c **** 				}
 4518              		.loc 1 3914 0
 4519 00bc 002000E3 		movw	r2, #:lower16:.LANCHOR13
 4520 00c0 002040E3 		movt	r2, #:upper16:.LANCHOR13
 4521 00c4 002092E5 		ldr	r2, [r2]
 4522 00c8 020053E1 		cmp	r3, r2
3914:../src/FreeRTOS/tasks.c **** 				}
 4523              		.loc 1 3914 0 is_stmt 0 discriminator 1
 4524 00cc 00200083 		movwhi	r2, #:lower16:.LANCHOR13
 4525 00d0 00204083 		movthi	r2, #:upper16:.LANCHOR13
 4526 00d4 00308285 		strhi	r3, [r2]
 4527              	.L399:
3914:../src/FreeRTOS/tasks.c **** 				}
 4528              		.loc 1 3914 0 discriminator 3
 4529 00d8 002000E3 		movw	r2, #:lower16:.LANCHOR4
 4530 00dc 002040E3 		movt	r2, #:upper16:.LANCHOR4
 4531 00e0 033183E0 		add	r3, r3, r3, lsl #2
 4532 00e4 0301A0E1 		lsl	r0, r3, #2
 4533 00e8 0410A0E1 		mov	r1, r4
 4534 00ec 000082E0 		add	r0, r2, r0
 4535 00f0 FEFFFFEB 		bl	vListInsertEnd
 4536              	.LVL500:
3925:../src/FreeRTOS/tasks.c **** 			}
 4537              		.loc 1 3925 0 is_stmt 1 discriminator 3
 4538 00f4 0100A0E3 		mov	r0, #1
 4539 00f8 7080BDE8 		pop	{r4, r5, r6, pc}
 4540              	.LVL501:
 4541              	.L395:
3929:../src/FreeRTOS/tasks.c **** 				{
 4542              		.loc 1 3929 0
 4543 00fc 582095E5 		ldr	r2, [r5, #88]
 4544 0100 003000E3 		movw	r3, #:lower16:.LANCHOR10
 4545 0104 003040E3 		movt	r3, #:upper16:.LANCHOR10
 4546 0108 003093E5 		ldr	r3, [r3]
 4547 010c 2C3093E5 		ldr	r3, [r3, #44]
 4548 0110 030052E1 		cmp	r2, r3
 4549 0114 0100002A 		bcs	.L406
3938:../src/FreeRTOS/tasks.c **** 				}
 4550              		.loc 1 3938 0
 4551 0118 0100A0E3 		mov	r0, #1
 4552              	.LVL502:
3952:../src/FreeRTOS/tasks.c **** 
 4553              		.loc 1 3952 0
 4554 011c 7080BDE8 		pop	{r4, r5, r6, pc}
 4555              	.LVL503:
 4556              	.L406:
3875:../src/FreeRTOS/tasks.c **** 
 4557              		.loc 1 3875 0
 4558 0120 0000A0E3 		mov	r0, #0
 4559              	.LVL504:
 4560 0124 7080BDE8 		pop	{r4, r5, r6, pc}
 4561              	.LVL505:
 4562              	.L400:
 4563 0128 0000A0E3 		mov	r0, #0
 4564              	.LVL506:
 4565 012c 7080BDE8 		pop	{r4, r5, r6, pc}
 4566              		.cfi_endproc
 4567              	.LFE53:
 4569              		.section	.text.xTaskPriorityDisinherit,"ax",%progbits
 4570              		.align	2
 4571              		.global	xTaskPriorityDisinherit
 4572              		.syntax unified
 4573              		.arm
 4574              		.fpu neon
 4576              	xTaskPriorityDisinherit:
 4577              	.LFB54:
3960:../src/FreeRTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 4578              		.loc 1 3960 0
 4579              		.cfi_startproc
 4580              		@ args = 0, pretend = 0, frame = 0
 4581              		@ frame_needed = 0, uses_anonymous_args = 0
 4582              	.LVL507:
 4583 0000 70402DE9 		push	{r4, r5, r6, lr}
 4584              		.cfi_def_cfa_offset 16
 4585              		.cfi_offset 4, -16
 4586              		.cfi_offset 5, -12
 4587              		.cfi_offset 6, -8
 4588              		.cfi_offset 14, -4
 4589              	.LVL508:
3964:../src/FreeRTOS/tasks.c **** 		{
 4590              		.loc 1 3964 0
 4591 0004 004050E2 		subs	r4, r0, #0
 4592 0008 3200000A 		beq	.L412
3970:../src/FreeRTOS/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
 4593              		.loc 1 3970 0
 4594 000c 003000E3 		movw	r3, #:lower16:.LANCHOR10
 4595 0010 003040E3 		movt	r3, #:upper16:.LANCHOR10
 4596 0014 003093E5 		ldr	r3, [r3]
 4597 0018 030054E1 		cmp	r4, r3
 4598 001c 0300000A 		beq	.L409
3970:../src/FreeRTOS/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
 4599              		.loc 1 3970 0 is_stmt 0 discriminator 1
 4600 0020 821F00E3 		movw	r1, #3970
 4601 0024 000000E3 		movw	r0, #:lower16:.LC0
 4602              	.LVL509:
 4603 0028 000040E3 		movt	r0, #:upper16:.LC0
 4604 002c FEFFFFEB 		bl	R_OS_AssertCalled
 4605              	.LVL510:
 4606              	.L409:
3971:../src/FreeRTOS/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
 4607              		.loc 1 3971 0 is_stmt 1
 4608 0030 5C3094E5 		ldr	r3, [r4, #92]
 4609 0034 000053E3 		cmp	r3, #0
 4610 0038 0A00000A 		beq	.L416
 4611              	.L410:
3972:../src/FreeRTOS/tasks.c **** 
 4612              		.loc 1 3972 0
 4613 003c 5C3094E5 		ldr	r3, [r4, #92]
 4614 0040 013043E2 		sub	r3, r3, #1
 4615 0044 5C3084E5 		str	r3, [r4, #92]
3976:../src/FreeRTOS/tasks.c **** 			{
 4616              		.loc 1 3976 0
 4617 0048 2C1094E5 		ldr	r1, [r4, #44]
 4618 004c 582094E5 		ldr	r2, [r4, #88]
 4619 0050 020051E1 		cmp	r1, r2
 4620 0054 2100000A 		beq	.L413
3979:../src/FreeRTOS/tasks.c **** 				{
 4621              		.loc 1 3979 0
 4622 0058 000053E3 		cmp	r3, #0
 4623 005c 0600000A 		beq	.L417
3962:../src/FreeRTOS/tasks.c **** 
 4624              		.loc 1 3962 0
 4625 0060 0000A0E3 		mov	r0, #0
4032:../src/FreeRTOS/tasks.c **** 
 4626              		.loc 1 4032 0
 4627 0064 7080BDE8 		pop	{r4, r5, r6, pc}
 4628              	.L416:
3971:../src/FreeRTOS/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
 4629              		.loc 1 3971 0 discriminator 1
 4630 0068 831F00E3 		movw	r1, #3971
 4631 006c 000000E3 		movw	r0, #:lower16:.LC0
 4632 0070 000040E3 		movt	r0, #:upper16:.LC0
 4633 0074 FEFFFFEB 		bl	R_OS_AssertCalled
 4634              	.LVL511:
 4635 0078 EFFFFFEA 		b	.L410
 4636              	.L417:
3986:../src/FreeRTOS/tasks.c **** 					{
 4637              		.loc 1 3986 0
 4638 007c 045084E2 		add	r5, r4, #4
 4639 0080 0500A0E1 		mov	r0, r5
 4640 0084 FEFFFFEB 		bl	uxListRemove
 4641              	.LVL512:
3998:../src/FreeRTOS/tasks.c **** 
 4642              		.loc 1 3998 0
 4643 0088 583094E5 		ldr	r3, [r4, #88]
 4644 008c 2C3084E5 		str	r3, [r4, #44]
4003:../src/FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4645              		.loc 1 4003 0
 4646 0090 142063E2 		rsb	r2, r3, #20
 4647 0094 182084E5 		str	r2, [r4, #24]
4004:../src/FreeRTOS/tasks.c **** 
 4648              		.loc 1 4004 0
 4649 0098 002000E3 		movw	r2, #:lower16:.LANCHOR13
 4650 009c 002040E3 		movt	r2, #:upper16:.LANCHOR13
 4651 00a0 002092E5 		ldr	r2, [r2]
 4652 00a4 020053E1 		cmp	r3, r2
4004:../src/FreeRTOS/tasks.c **** 
 4653              		.loc 1 4004 0 is_stmt 0 discriminator 1
 4654 00a8 00200083 		movwhi	r2, #:lower16:.LANCHOR13
 4655 00ac 00204083 		movthi	r2, #:upper16:.LANCHOR13
 4656 00b0 00308285 		strhi	r3, [r2]
 4657              	.L411:
4004:../src/FreeRTOS/tasks.c **** 
 4658              		.loc 1 4004 0 discriminator 3
 4659 00b4 002000E3 		movw	r2, #:lower16:.LANCHOR4
 4660 00b8 002040E3 		movt	r2, #:upper16:.LANCHOR4
 4661 00bc 033183E0 		add	r3, r3, r3, lsl #2
 4662 00c0 0301A0E1 		lsl	r0, r3, #2
 4663 00c4 0510A0E1 		mov	r1, r5
 4664 00c8 000082E0 		add	r0, r2, r0
 4665 00cc FEFFFFEB 		bl	vListInsertEnd
 4666              	.LVL513:
4014:../src/FreeRTOS/tasks.c **** 				}
 4667              		.loc 1 4014 0 is_stmt 1 discriminator 3
 4668 00d0 0100A0E3 		mov	r0, #1
 4669 00d4 7080BDE8 		pop	{r4, r5, r6, pc}
 4670              	.LVL514:
 4671              	.L412:
3962:../src/FreeRTOS/tasks.c **** 
 4672              		.loc 1 3962 0
 4673 00d8 0000A0E3 		mov	r0, #0
 4674              	.LVL515:
 4675 00dc 7080BDE8 		pop	{r4, r5, r6, pc}
 4676              	.L413:
 4677 00e0 0000A0E3 		mov	r0, #0
 4678 00e4 7080BDE8 		pop	{r4, r5, r6, pc}
 4679              		.cfi_endproc
 4680              	.LFE54:
 4682              		.section	.text.vTaskPriorityDisinheritAfterTimeout,"ax",%progbits
 4683              		.align	2
 4684              		.global	vTaskPriorityDisinheritAfterTimeout
 4685              		.syntax unified
 4686              		.arm
 4687              		.fpu neon
 4689              	vTaskPriorityDisinheritAfterTimeout:
 4690              	.LFB55:
4040:../src/FreeRTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 4691              		.loc 1 4040 0
 4692              		.cfi_startproc
 4693              		@ args = 0, pretend = 0, frame = 0
 4694              		@ frame_needed = 0, uses_anonymous_args = 0
 4695              	.LVL516:
 4696 0000 70402DE9 		push	{r4, r5, r6, lr}
 4697              		.cfi_def_cfa_offset 16
 4698              		.cfi_offset 4, -16
 4699              		.cfi_offset 5, -12
 4700              		.cfi_offset 6, -8
 4701              		.cfi_offset 14, -4
 4702              	.LVL517:
4045:../src/FreeRTOS/tasks.c **** 		{
 4703              		.loc 1 4045 0
 4704 0004 004050E2 		subs	r4, r0, #0
 4705 0008 7080BD08 		popeq	{r4, r5, r6, pc}
 4706 000c 0150A0E1 		mov	r5, r1
4049:../src/FreeRTOS/tasks.c **** 
 4707              		.loc 1 4049 0
 4708 0010 5C3094E5 		ldr	r3, [r4, #92]
 4709 0014 000053E3 		cmp	r3, #0
 4710 0018 3100000A 		beq	.L428
 4711              	.LVL518:
 4712              	.L420:
4055:../src/FreeRTOS/tasks.c **** 			{
 4713              		.loc 1 4055 0
 4714 001c 586094E5 		ldr	r6, [r4, #88]
 4715 0020 050056E1 		cmp	r6, r5
4057:../src/FreeRTOS/tasks.c **** 			}
 4716              		.loc 1 4057 0
 4717 0024 0560A031 		movcc	r6, r5
 4718              	.L421:
 4719              	.LVL519:
4065:../src/FreeRTOS/tasks.c **** 			{
 4720              		.loc 1 4065 0
 4721 0028 2C3094E5 		ldr	r3, [r4, #44]
 4722 002c 030056E1 		cmp	r6, r3
 4723 0030 7080BD08 		popeq	{r4, r5, r6, pc}
4071:../src/FreeRTOS/tasks.c **** 				{
 4724              		.loc 1 4071 0
 4725 0034 5C3094E5 		ldr	r3, [r4, #92]
 4726 0038 010053E3 		cmp	r3, #1
 4727 003c 7080BD18 		popne	{r4, r5, r6, pc}
4076:../src/FreeRTOS/tasks.c **** 
 4728              		.loc 1 4076 0
 4729 0040 003000E3 		movw	r3, #:lower16:.LANCHOR10
 4730 0044 003040E3 		movt	r3, #:upper16:.LANCHOR10
 4731 0048 003093E5 		ldr	r3, [r3]
 4732 004c 030054E1 		cmp	r4, r3
 4733 0050 2800000A 		beq	.L429
 4734              	.L422:
4082:../src/FreeRTOS/tasks.c **** 					pxTCB->uxPriority = uxPriorityToUse;
 4735              		.loc 1 4082 0
 4736 0054 2C2094E5 		ldr	r2, [r4, #44]
 4737              	.LVL520:
4083:../src/FreeRTOS/tasks.c **** 
 4738              		.loc 1 4083 0
 4739 0058 2C6084E5 		str	r6, [r4, #44]
4087:../src/FreeRTOS/tasks.c **** 					{
 4740              		.loc 1 4087 0
 4741 005c 183094E5 		ldr	r3, [r4, #24]
 4742 0060 000053E3 		cmp	r3, #0
4089:../src/FreeRTOS/tasks.c **** 					}
 4743              		.loc 1 4089 0
 4744 0064 146066A2 		rsbge	r6, r6, #20
 4745              	.LVL521:
 4746 0068 186084A5 		strge	r6, [r4, #24]
 4747              	.L423:
4102:../src/FreeRTOS/tasks.c **** 					{
 4748              		.loc 1 4102 0
 4749 006c 140094E5 		ldr	r0, [r4, #20]
 4750 0070 003000E3 		movw	r3, #:lower16:.LANCHOR4
 4751 0074 003040E3 		movt	r3, #:upper16:.LANCHOR4
 4752 0078 022182E0 		add	r2, r2, r2, lsl #2
 4753              	.LVL522:
 4754 007c 0211A0E1 		lsl	r1, r2, #2
 4755 0080 013083E0 		add	r3, r3, r1
 4756 0084 030050E1 		cmp	r0, r3
 4757 0088 1F00000A 		beq	.L430
 4758 008c 0030A0E3 		mov	r3, #0
 4759              	.L424:
4102:../src/FreeRTOS/tasks.c **** 					{
 4760              		.loc 1 4102 0 is_stmt 0 discriminator 4
 4761 0090 000053E3 		cmp	r3, #0
 4762 0094 7080BD08 		popeq	{r4, r5, r6, pc}
4104:../src/FreeRTOS/tasks.c **** 						{
 4763              		.loc 1 4104 0 is_stmt 1
 4764 0098 045084E2 		add	r5, r4, #4
 4765              	.LVL523:
 4766 009c 0500A0E1 		mov	r0, r5
 4767 00a0 FEFFFFEB 		bl	uxListRemove
 4768              	.LVL524:
4113:../src/FreeRTOS/tasks.c **** 					}
 4769              		.loc 1 4113 0
 4770 00a4 2C3094E5 		ldr	r3, [r4, #44]
 4771 00a8 002000E3 		movw	r2, #:lower16:.LANCHOR13
 4772 00ac 002040E3 		movt	r2, #:upper16:.LANCHOR13
 4773 00b0 002092E5 		ldr	r2, [r2]
 4774 00b4 020053E1 		cmp	r3, r2
4113:../src/FreeRTOS/tasks.c **** 					}
 4775              		.loc 1 4113 0 is_stmt 0 discriminator 1
 4776 00b8 00200083 		movwhi	r2, #:lower16:.LANCHOR13
 4777 00bc 00204083 		movthi	r2, #:upper16:.LANCHOR13
 4778 00c0 00308285 		strhi	r3, [r2]
 4779              	.L425:
4113:../src/FreeRTOS/tasks.c **** 					}
 4780              		.loc 1 4113 0 discriminator 3
 4781 00c4 002000E3 		movw	r2, #:lower16:.LANCHOR4
 4782 00c8 002040E3 		movt	r2, #:upper16:.LANCHOR4
 4783 00cc 033183E0 		add	r3, r3, r3, lsl #2
 4784 00d0 0301A0E1 		lsl	r0, r3, #2
 4785 00d4 0510A0E1 		mov	r1, r5
 4786 00d8 000082E0 		add	r0, r2, r0
 4787 00dc FEFFFFEB 		bl	vListInsertEnd
 4788              	.LVL525:
 4789 00e0 7080BDE8 		pop	{r4, r5, r6, pc}
 4790              	.LVL526:
 4791              	.L428:
4049:../src/FreeRTOS/tasks.c **** 
 4792              		.loc 1 4049 0 is_stmt 1 discriminator 1
 4793 00e4 D11F00E3 		movw	r1, #4049
 4794              	.LVL527:
 4795 00e8 000000E3 		movw	r0, #:lower16:.LC0
 4796              	.LVL528:
 4797 00ec 000040E3 		movt	r0, #:upper16:.LC0
 4798 00f0 FEFFFFEB 		bl	R_OS_AssertCalled
 4799              	.LVL529:
 4800 00f4 C8FFFFEA 		b	.L420
 4801              	.LVL530:
 4802              	.L429:
4076:../src/FreeRTOS/tasks.c **** 
 4803              		.loc 1 4076 0 discriminator 1
 4804 00f8 EC1F00E3 		movw	r1, #4076
 4805 00fc 000000E3 		movw	r0, #:lower16:.LC0
 4806 0100 000040E3 		movt	r0, #:upper16:.LC0
 4807 0104 FEFFFFEB 		bl	R_OS_AssertCalled
 4808              	.LVL531:
 4809 0108 D1FFFFEA 		b	.L422
 4810              	.LVL532:
 4811              	.L430:
4102:../src/FreeRTOS/tasks.c **** 					{
 4812              		.loc 1 4102 0
 4813 010c 0130A0E3 		mov	r3, #1
 4814 0110 DEFFFFEA 		b	.L424
 4815              		.cfi_endproc
 4816              	.LFE55:
 4818              		.section	.text.vTaskList,"ax",%progbits
 4819              		.align	2
 4820              		.global	vTaskList
 4821              		.syntax unified
 4822              		.arm
 4823              		.fpu neon
 4825              	vTaskList:
 4826              	.LFB57:
4231:../src/FreeRTOS/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
 4827              		.loc 1 4231 0
 4828              		.cfi_startproc
 4829              		@ args = 0, pretend = 0, frame = 8
 4830              		@ frame_needed = 0, uses_anonymous_args = 0
 4831              	.LVL533:
 4832 0000 70402DE9 		push	{r4, r5, r6, lr}
 4833              		.cfi_def_cfa_offset 16
 4834              		.cfi_offset 4, -16
 4835              		.cfi_offset 5, -12
 4836              		.cfi_offset 6, -8
 4837              		.cfi_offset 14, -4
 4838 0004 10D04DE2 		sub	sp, sp, #16
 4839              		.cfi_def_cfa_offset 32
 4840 0008 0050A0E1 		mov	r5, r0
4262:../src/FreeRTOS/tasks.c **** 
 4841              		.loc 1 4262 0
 4842 000c 0030A0E3 		mov	r3, #0
 4843 0010 0030C0E5 		strb	r3, [r0]
4266:../src/FreeRTOS/tasks.c **** 
 4844              		.loc 1 4266 0
 4845 0014 003000E3 		movw	r3, #:lower16:.LANCHOR9
 4846 0018 003040E3 		movt	r3, #:upper16:.LANCHOR9
 4847 001c 002093E5 		ldr	r2, [r3]
 4848 0020 0C208DE5 		str	r2, [sp, #12]
4271:../src/FreeRTOS/tasks.c **** 
 4849              		.loc 1 4271 0
 4850 0024 003093E5 		ldr	r3, [r3]
 4851 0028 833183E0 		add	r3, r3, r3, lsl #3
 4852 002c 0301A0E1 		lsl	r0, r3, #2
 4853              	.LVL534:
 4854 0030 FEFFFFEB 		bl	pvPortMalloc
 4855              	.LVL535:
4273:../src/FreeRTOS/tasks.c **** 		{
 4856              		.loc 1 4273 0
 4857 0034 004050E2 		subs	r4, r0, #0
 4858 0038 4800000A 		beq	.L431
4276:../src/FreeRTOS/tasks.c **** 
 4859              		.loc 1 4276 0
 4860 003c 0C109DE5 		ldr	r1, [sp, #12]
 4861 0040 0020A0E3 		mov	r2, #0
 4862 0044 0400A0E1 		mov	r0, r4
 4863 0048 FEFFFFEB 		bl	uxTaskGetSystemState
 4864              	.LVL536:
 4865 004c 0C008DE5 		str	r0, [sp, #12]
4279:../src/FreeRTOS/tasks.c **** 			{
 4866              		.loc 1 4279 0
 4867 0050 0030A0E3 		mov	r3, #0
 4868 0054 08308DE5 		str	r3, [sp, #8]
 4869 0058 2D0000EA 		b	.L433
 4870              	.L435:
4283:../src/FreeRTOS/tasks.c **** 										break;
 4871              		.loc 1 4283 0
 4872 005c 5860A0E3 		mov	r6, #88
 4873 0060 080000EA 		b	.L437
 4874              	.L438:
 4875              	.LVL537:
4289:../src/FreeRTOS/tasks.c **** 										break;
 4876              		.loc 1 4289 0
 4877 0064 4260A0E3 		mov	r6, #66
4290:../src/FreeRTOS/tasks.c **** 
 4878              		.loc 1 4290 0
 4879 0068 060000EA 		b	.L437
 4880              	.LVL538:
 4881              	.L439:
4292:../src/FreeRTOS/tasks.c **** 										break;
 4882              		.loc 1 4292 0
 4883 006c 5360A0E3 		mov	r6, #83
4293:../src/FreeRTOS/tasks.c **** 
 4884              		.loc 1 4293 0
 4885 0070 040000EA 		b	.L437
 4886              	.LVL539:
 4887              	.L440:
4295:../src/FreeRTOS/tasks.c **** 										break;
 4888              		.loc 1 4295 0
 4889 0074 4460A0E3 		mov	r6, #68
4296:../src/FreeRTOS/tasks.c **** 
 4890              		.loc 1 4296 0
 4891 0078 020000EA 		b	.L437
 4892              	.LVL540:
 4893              	.L434:
4300:../src/FreeRTOS/tasks.c **** 										break;
 4894              		.loc 1 4300 0
 4895 007c 0060A0E3 		mov	r6, #0
4301:../src/FreeRTOS/tasks.c **** 				}
 4896              		.loc 1 4301 0
 4897 0080 000000EA 		b	.L437
 4898              	.LVL541:
 4899              	.L442:
4286:../src/FreeRTOS/tasks.c **** 										break;
 4900              		.loc 1 4286 0
 4901 0084 5260A0E3 		mov	r6, #82
 4902              	.L437:
 4903              	.LVL542:
4306:../src/FreeRTOS/tasks.c **** 
 4904              		.loc 1 4306 0 discriminator 2
 4905 0088 08309DE5 		ldr	r3, [sp, #8]
 4906 008c 833183E0 		add	r3, r3, r3, lsl #3
 4907 0090 0321A0E1 		lsl	r2, r3, #2
 4908 0094 022084E0 		add	r2, r4, r2
 4909 0098 041092E5 		ldr	r1, [r2, #4]
 4910 009c 0500A0E1 		mov	r0, r5
 4911 00a0 FEFFFFEB 		bl	prvWriteNameToBuffer
 4912              	.LVL543:
 4913 00a4 0050A0E1 		mov	r5, r0
 4914              	.LVL544:
4309:../src/FreeRTOS/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer );
 4915              		.loc 1 4309 0 discriminator 2
 4916 00a8 08309DE5 		ldr	r3, [sp, #8]
 4917 00ac 833183E0 		add	r3, r3, r3, lsl #3
 4918 00b0 0321A0E1 		lsl	r2, r3, #2
 4919 00b4 022084E0 		add	r2, r4, r2
 4920 00b8 103092E5 		ldr	r3, [r2, #16]
 4921 00bc 08209DE5 		ldr	r2, [sp, #8]
 4922 00c0 822182E0 		add	r2, r2, r2, lsl #3
 4923 00c4 0211A0E1 		lsl	r1, r2, #2
 4924 00c8 011084E0 		add	r1, r4, r1
 4925 00cc B0C2D1E1 		ldrh	ip, [r1, #32]
 4926 00d0 08209DE5 		ldr	r2, [sp, #8]
 4927 00d4 822182E0 		add	r2, r2, r2, lsl #3
 4928 00d8 0211A0E1 		lsl	r1, r2, #2
 4929 00dc 011084E0 		add	r1, r4, r1
 4930 00e0 082091E5 		ldr	r2, [r1, #8]
 4931 00e4 04208DE5 		str	r2, [sp, #4]
 4932 00e8 00C08DE5 		str	ip, [sp]
 4933 00ec 0620A0E1 		mov	r2, r6
 4934 00f0 001000E3 		movw	r1, #:lower16:.LC2
 4935 00f4 001040E3 		movt	r1, #:upper16:.LC2
 4936 00f8 FEFFFFEB 		bl	sprintf
 4937              	.LVL545:
4310:../src/FreeRTOS/tasks.c **** 			}
 4938              		.loc 1 4310 0 discriminator 2
 4939 00fc 0500A0E1 		mov	r0, r5
 4940 0100 FEFFFFEB 		bl	strlen
 4941              	.LVL546:
 4942 0104 005085E0 		add	r5, r5, r0
 4943              	.LVL547:
4279:../src/FreeRTOS/tasks.c **** 			{
 4944              		.loc 1 4279 0 discriminator 2
 4945 0108 08309DE5 		ldr	r3, [sp, #8]
 4946 010c 013083E2 		add	r3, r3, #1
 4947 0110 08308DE5 		str	r3, [sp, #8]
 4948              	.LVL548:
 4949              	.L433:
4279:../src/FreeRTOS/tasks.c **** 			{
 4950              		.loc 1 4279 0 is_stmt 0 discriminator 1
 4951 0114 08209DE5 		ldr	r2, [sp, #8]
 4952 0118 0C309DE5 		ldr	r3, [sp, #12]
 4953 011c 030052E1 		cmp	r2, r3
 4954 0120 0C00002A 		bcs	.L444
4281:../src/FreeRTOS/tasks.c **** 				{
 4955              		.loc 1 4281 0 is_stmt 1
 4956 0124 08309DE5 		ldr	r3, [sp, #8]
 4957 0128 833183E0 		add	r3, r3, r3, lsl #3
 4958 012c 0321A0E1 		lsl	r2, r3, #2
 4959 0130 022084E0 		add	r2, r4, r2
 4960 0134 0C30D2E5 		ldrb	r3, [r2, #12]	@ zero_extendqisi2
 4961 0138 040053E3 		cmp	r3, #4
 4962 013c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 4963 0140 CDFFFFEA 		b	.L434
 4964              	.L436:
 4965 0144 5C000000 		.word	.L435
 4966 0148 84000000 		.word	.L442
 4967 014c 64000000 		.word	.L438
 4968 0150 6C000000 		.word	.L439
 4969 0154 74000000 		.word	.L440
 4970              	.L444:
4315:../src/FreeRTOS/tasks.c **** 		}
 4971              		.loc 1 4315 0
 4972 0158 0400A0E1 		mov	r0, r4
 4973 015c FEFFFFEB 		bl	vPortFree
 4974              	.LVL549:
 4975              	.L431:
4321:../src/FreeRTOS/tasks.c **** 
 4976              		.loc 1 4321 0
 4977 0160 10D08DE2 		add	sp, sp, #16
 4978              		.cfi_def_cfa_offset 16
 4979              		@ sp needed
 4980 0164 7080BDE8 		pop	{r4, r5, r6, pc}
 4981              		.cfi_endproc
 4982              	.LFE57:
 4984              		.global	__aeabi_uidiv
 4985              		.section	.text.vTaskGetRunTimeStats,"ax",%progbits
 4986              		.align	2
 4987              		.global	vTaskGetRunTimeStats
 4988              		.syntax unified
 4989              		.arm
 4990              		.fpu neon
 4992              	vTaskGetRunTimeStats:
 4993              	.LFB58:
4329:../src/FreeRTOS/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
 4994              		.loc 1 4329 0
 4995              		.cfi_startproc
 4996              		@ args = 0, pretend = 0, frame = 16
 4997              		@ frame_needed = 0, uses_anonymous_args = 0
 4998              	.LVL550:
 4999 0000 70402DE9 		push	{r4, r5, r6, lr}
 5000              		.cfi_def_cfa_offset 16
 5001              		.cfi_offset 4, -16
 5002              		.cfi_offset 5, -12
 5003              		.cfi_offset 6, -8
 5004              		.cfi_offset 14, -4
 5005 0004 10D04DE2 		sub	sp, sp, #16
 5006              		.cfi_def_cfa_offset 32
 5007 0008 0040A0E1 		mov	r4, r0
4366:../src/FreeRTOS/tasks.c **** 
 5008              		.loc 1 4366 0
 5009 000c 0030A0E3 		mov	r3, #0
 5010 0010 0030C0E5 		strb	r3, [r0]
4370:../src/FreeRTOS/tasks.c **** 
 5011              		.loc 1 4370 0
 5012 0014 003000E3 		movw	r3, #:lower16:.LANCHOR9
 5013 0018 003040E3 		movt	r3, #:upper16:.LANCHOR9
 5014 001c 002093E5 		ldr	r2, [r3]
 5015 0020 0C208DE5 		str	r2, [sp, #12]
4375:../src/FreeRTOS/tasks.c **** 
 5016              		.loc 1 4375 0
 5017 0024 003093E5 		ldr	r3, [r3]
 5018 0028 833183E0 		add	r3, r3, r3, lsl #3
 5019 002c 0301A0E1 		lsl	r0, r3, #2
 5020              	.LVL551:
 5021 0030 FEFFFFEB 		bl	pvPortMalloc
 5022              	.LVL552:
4377:../src/FreeRTOS/tasks.c **** 		{
 5023              		.loc 1 4377 0
 5024 0034 005050E2 		subs	r5, r0, #0
 5025 0038 3F00000A 		beq	.L445
4380:../src/FreeRTOS/tasks.c **** 
 5026              		.loc 1 4380 0
 5027 003c 0C109DE5 		ldr	r1, [sp, #12]
 5028 0040 04208DE2 		add	r2, sp, #4
 5029 0044 0500A0E1 		mov	r0, r5
 5030 0048 FEFFFFEB 		bl	uxTaskGetSystemState
 5031              	.LVL553:
 5032 004c 0C008DE5 		str	r0, [sp, #12]
4383:../src/FreeRTOS/tasks.c **** 
 5033              		.loc 1 4383 0
 5034 0050 1F3508E3 		movw	r3, #34079
 5035 0054 EB3145E3 		movt	r3, 20971
 5036 0058 04209DE5 		ldr	r2, [sp, #4]
 5037 005c 922383E0 		umull	r2, r3, r2, r3
 5038 0060 A332A0E1 		lsr	r3, r3, #5
 5039 0064 04308DE5 		str	r3, [sp, #4]
4386:../src/FreeRTOS/tasks.c **** 			{
 5040              		.loc 1 4386 0
 5041 0068 000053E3 		cmp	r3, #0
 5042 006c 3000000A 		beq	.L447
4389:../src/FreeRTOS/tasks.c **** 				{
 5043              		.loc 1 4389 0
 5044 0070 0030A0E3 		mov	r3, #0
 5045 0074 08308DE5 		str	r3, [sp, #8]
 5046 0078 0D0000EA 		b	.L448
 5047              	.LVL554:
 5048              	.L449:
4427:../src/FreeRTOS/tasks.c **** 						}
 5049              		.loc 1 4427 0
 5050 007c 08309DE5 		ldr	r3, [sp, #8]
 5051 0080 833183E0 		add	r3, r3, r3, lsl #3
 5052 0084 0321A0E1 		lsl	r2, r3, #2
 5053 0088 022085E0 		add	r2, r5, r2
 5054 008c 182092E5 		ldr	r2, [r2, #24]
 5055 0090 001000E3 		movw	r1, #:lower16:.LC4
 5056 0094 001040E3 		movt	r1, #:upper16:.LC4
 5057 0098 FEFFFFEB 		bl	sprintf
 5058              	.LVL555:
 5059              	.L450:
4432:../src/FreeRTOS/tasks.c **** 				}
 5060              		.loc 1 4432 0 discriminator 2
 5061 009c 0400A0E1 		mov	r0, r4
 5062 00a0 FEFFFFEB 		bl	strlen
 5063              	.LVL556:
 5064 00a4 004084E0 		add	r4, r4, r0
 5065              	.LVL557:
4389:../src/FreeRTOS/tasks.c **** 				{
 5066              		.loc 1 4389 0 discriminator 2
 5067 00a8 08309DE5 		ldr	r3, [sp, #8]
 5068 00ac 013083E2 		add	r3, r3, #1
 5069 00b0 08308DE5 		str	r3, [sp, #8]
 5070              	.LVL558:
 5071              	.L448:
4389:../src/FreeRTOS/tasks.c **** 				{
 5072              		.loc 1 4389 0 is_stmt 0 discriminator 1
 5073 00b4 08209DE5 		ldr	r2, [sp, #8]
 5074 00b8 0C309DE5 		ldr	r3, [sp, #12]
 5075 00bc 030052E1 		cmp	r2, r3
 5076 00c0 1B00002A 		bcs	.L447
4394:../src/FreeRTOS/tasks.c **** 
 5077              		.loc 1 4394 0 is_stmt 1
 5078 00c4 08309DE5 		ldr	r3, [sp, #8]
 5079 00c8 833183E0 		add	r3, r3, r3, lsl #3
 5080 00cc 0321A0E1 		lsl	r2, r3, #2
 5081 00d0 022085E0 		add	r2, r5, r2
 5082 00d4 04109DE5 		ldr	r1, [sp, #4]
 5083 00d8 180092E5 		ldr	r0, [r2, #24]
 5084 00dc FEFFFFEB 		bl	__aeabi_uidiv
 5085              	.LVL559:
 5086 00e0 0060A0E1 		mov	r6, r0
 5087              	.LVL560:
4399:../src/FreeRTOS/tasks.c **** 
 5088              		.loc 1 4399 0
 5089 00e4 08309DE5 		ldr	r3, [sp, #8]
 5090 00e8 833183E0 		add	r3, r3, r3, lsl #3
 5091 00ec 0321A0E1 		lsl	r2, r3, #2
 5092 00f0 022085E0 		add	r2, r5, r2
 5093 00f4 041092E5 		ldr	r1, [r2, #4]
 5094 00f8 0400A0E1 		mov	r0, r4
 5095              	.LVL561:
 5096 00fc FEFFFFEB 		bl	prvWriteNameToBuffer
 5097              	.LVL562:
 5098 0100 0040A0E1 		mov	r4, r0
 5099              	.LVL563:
4401:../src/FreeRTOS/tasks.c **** 					{
 5100              		.loc 1 4401 0
 5101 0104 000056E3 		cmp	r6, #0
 5102 0108 DBFFFF0A 		beq	.L449
4411:../src/FreeRTOS/tasks.c **** 						}
 5103              		.loc 1 4411 0
 5104 010c 08309DE5 		ldr	r3, [sp, #8]
 5105 0110 833183E0 		add	r3, r3, r3, lsl #3
 5106 0114 0321A0E1 		lsl	r2, r3, #2
 5107 0118 022085E0 		add	r2, r5, r2
 5108 011c 0630A0E1 		mov	r3, r6
 5109 0120 182092E5 		ldr	r2, [r2, #24]
 5110 0124 001000E3 		movw	r1, #:lower16:.LC3
 5111 0128 001040E3 		movt	r1, #:upper16:.LC3
 5112 012c FEFFFFEB 		bl	sprintf
 5113              	.LVL564:
 5114 0130 D9FFFFEA 		b	.L450
 5115              	.LVL565:
 5116              	.L447:
4442:../src/FreeRTOS/tasks.c **** 		}
 5117              		.loc 1 4442 0
 5118 0134 0500A0E1 		mov	r0, r5
 5119 0138 FEFFFFEB 		bl	vPortFree
 5120              	.LVL566:
 5121              	.L445:
4448:../src/FreeRTOS/tasks.c **** 
 5122              		.loc 1 4448 0
 5123 013c 10D08DE2 		add	sp, sp, #16
 5124              		.cfi_def_cfa_offset 16
 5125              		@ sp needed
 5126 0140 7080BDE8 		pop	{r4, r5, r6, pc}
 5127              		.cfi_endproc
 5128              	.LFE58:
 5130              		.section	.text.uxTaskResetEventItemValue,"ax",%progbits
 5131              		.align	2
 5132              		.global	uxTaskResetEventItemValue
 5133              		.syntax unified
 5134              		.arm
 5135              		.fpu neon
 5137              	uxTaskResetEventItemValue:
 5138              	.LFB59:
4454:../src/FreeRTOS/tasks.c **** TickType_t uxReturn;
 5139              		.loc 1 4454 0
 5140              		.cfi_startproc
 5141              		@ args = 0, pretend = 0, frame = 0
 5142              		@ frame_needed = 0, uses_anonymous_args = 0
 5143              		@ link register save eliminated.
4457:../src/FreeRTOS/tasks.c **** 
 5144              		.loc 1 4457 0
 5145 0000 003000E3 		movw	r3, #:lower16:.LANCHOR10
 5146 0004 003040E3 		movt	r3, #:upper16:.LANCHOR10
 5147 0008 002093E5 		ldr	r2, [r3]
 5148 000c 180092E5 		ldr	r0, [r2, #24]
 5149              	.LVL567:
4461:../src/FreeRTOS/tasks.c **** 
 5150              		.loc 1 4461 0
 5151 0010 002093E5 		ldr	r2, [r3]
 5152 0014 003093E5 		ldr	r3, [r3]
 5153 0018 2C3093E5 		ldr	r3, [r3, #44]
 5154 001c 143063E2 		rsb	r3, r3, #20
 5155 0020 183082E5 		str	r3, [r2, #24]
4464:../src/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 5156              		.loc 1 4464 0
 5157 0024 1EFF2FE1 		bx	lr
 5158              		.cfi_endproc
 5159              	.LFE59:
 5161              		.section	.text.pvTaskIncrementMutexHeldCount,"ax",%progbits
 5162              		.align	2
 5163              		.global	pvTaskIncrementMutexHeldCount
 5164              		.syntax unified
 5165              		.arm
 5166              		.fpu neon
 5168              	pvTaskIncrementMutexHeldCount:
 5169              	.LFB60:
4470:../src/FreeRTOS/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
 5170              		.loc 1 4470 0
 5171              		.cfi_startproc
 5172              		@ args = 0, pretend = 0, frame = 0
 5173              		@ frame_needed = 0, uses_anonymous_args = 0
 5174              		@ link register save eliminated.
4473:../src/FreeRTOS/tasks.c **** 		{
 5175              		.loc 1 4473 0
 5176 0000 003000E3 		movw	r3, #:lower16:.LANCHOR10
 5177 0004 003040E3 		movt	r3, #:upper16:.LANCHOR10
 5178 0008 003093E5 		ldr	r3, [r3]
 5179 000c 000053E3 		cmp	r3, #0
 5180 0010 0500000A 		beq	.L455
4475:../src/FreeRTOS/tasks.c **** 		}
 5181              		.loc 1 4475 0
 5182 0014 003000E3 		movw	r3, #:lower16:.LANCHOR10
 5183 0018 003040E3 		movt	r3, #:upper16:.LANCHOR10
 5184 001c 002093E5 		ldr	r2, [r3]
 5185 0020 5C3092E5 		ldr	r3, [r2, #92]
 5186 0024 013083E2 		add	r3, r3, #1
 5187 0028 5C3082E5 		str	r3, [r2, #92]
 5188              	.L455:
4478:../src/FreeRTOS/tasks.c **** 	}
 5189              		.loc 1 4478 0
 5190 002c 003000E3 		movw	r3, #:lower16:.LANCHOR10
 5191 0030 003040E3 		movt	r3, #:upper16:.LANCHOR10
 5192 0034 000093E5 		ldr	r0, [r3]
4479:../src/FreeRTOS/tasks.c **** 
 5193              		.loc 1 4479 0
 5194 0038 1EFF2FE1 		bx	lr
 5195              		.cfi_endproc
 5196              	.LFE60:
 5198              		.section	.text.ulTaskNotifyTake,"ax",%progbits
 5199              		.align	2
 5200              		.global	ulTaskNotifyTake
 5201              		.syntax unified
 5202              		.arm
 5203              		.fpu neon
 5205              	ulTaskNotifyTake:
 5206              	.LFB61:
4487:../src/FreeRTOS/tasks.c **** 	uint32_t ulReturn;
 5207              		.loc 1 4487 0
 5208              		.cfi_startproc
 5209              		@ args = 0, pretend = 0, frame = 0
 5210              		@ frame_needed = 0, uses_anonymous_args = 0
 5211              	.LVL568:
 5212 0000 70402DE9 		push	{r4, r5, r6, lr}
 5213              		.cfi_def_cfa_offset 16
 5214              		.cfi_offset 4, -16
 5215              		.cfi_offset 5, -12
 5216              		.cfi_offset 6, -8
 5217              		.cfi_offset 14, -4
 5218 0004 0050A0E1 		mov	r5, r0
 5219 0008 0140A0E1 		mov	r4, r1
4490:../src/FreeRTOS/tasks.c **** 		{
 5220              		.loc 1 4490 0
 5221 000c FEFFFFEB 		bl	vPortEnterCritical
 5222              	.LVL569:
4493:../src/FreeRTOS/tasks.c **** 			{
 5223              		.loc 1 4493 0
 5224 0010 003000E3 		movw	r3, #:lower16:.LANCHOR10
 5225 0014 003040E3 		movt	r3, #:upper16:.LANCHOR10
 5226 0018 003093E5 		ldr	r3, [r3]
 5227 001c 703093E5 		ldr	r3, [r3, #112]
 5228 0020 000053E3 		cmp	r3, #0
 5229 0024 0600001A 		bne	.L457
4496:../src/FreeRTOS/tasks.c **** 
 5230              		.loc 1 4496 0
 5231 0028 003000E3 		movw	r3, #:lower16:.LANCHOR10
 5232 002c 003040E3 		movt	r3, #:upper16:.LANCHOR10
 5233 0030 003093E5 		ldr	r3, [r3]
 5234 0034 0120A0E3 		mov	r2, #1
 5235 0038 7420C3E5 		strb	r2, [r3, #116]
4498:../src/FreeRTOS/tasks.c **** 				{
 5236              		.loc 1 4498 0
 5237 003c 000054E3 		cmp	r4, #0
 5238 0040 1600001A 		bne	.L461
 5239              	.L457:
4519:../src/FreeRTOS/tasks.c **** 
 5240              		.loc 1 4519 0
 5241 0044 FEFFFFEB 		bl	vPortExitCritical
 5242              	.LVL570:
4521:../src/FreeRTOS/tasks.c **** 		{
 5243              		.loc 1 4521 0
 5244 0048 FEFFFFEB 		bl	vPortEnterCritical
 5245              	.LVL571:
4524:../src/FreeRTOS/tasks.c **** 
 5246              		.loc 1 4524 0
 5247 004c 003000E3 		movw	r3, #:lower16:.LANCHOR10
 5248 0050 003040E3 		movt	r3, #:upper16:.LANCHOR10
 5249 0054 003093E5 		ldr	r3, [r3]
 5250 0058 704093E5 		ldr	r4, [r3, #112]
 5251              	.LVL572:
4526:../src/FreeRTOS/tasks.c **** 			{
 5252              		.loc 1 4526 0
 5253 005c 000054E3 		cmp	r4, #0
 5254 0060 0600000A 		beq	.L458
4528:../src/FreeRTOS/tasks.c **** 				{
 5255              		.loc 1 4528 0
 5256 0064 000055E3 		cmp	r5, #0
 5257 0068 1100001A 		bne	.L462
4534:../src/FreeRTOS/tasks.c **** 				}
 5258              		.loc 1 4534 0
 5259 006c 003000E3 		movw	r3, #:lower16:.LANCHOR10
 5260 0070 003040E3 		movt	r3, #:upper16:.LANCHOR10
 5261 0074 003093E5 		ldr	r3, [r3]
 5262 0078 012044E2 		sub	r2, r4, #1
 5263 007c 702083E5 		str	r2, [r3, #112]
 5264              	.L458:
4542:../src/FreeRTOS/tasks.c **** 		}
 5265              		.loc 1 4542 0
 5266 0080 003000E3 		movw	r3, #:lower16:.LANCHOR10
 5267 0084 003040E3 		movt	r3, #:upper16:.LANCHOR10
 5268 0088 003093E5 		ldr	r3, [r3]
 5269 008c 0020A0E3 		mov	r2, #0
 5270 0090 7420C3E5 		strb	r2, [r3, #116]
4544:../src/FreeRTOS/tasks.c **** 
 5271              		.loc 1 4544 0
 5272 0094 FEFFFFEB 		bl	vPortExitCritical
 5273              	.LVL573:
4547:../src/FreeRTOS/tasks.c **** 
 5274              		.loc 1 4547 0
 5275 0098 0400A0E1 		mov	r0, r4
 5276 009c 7080BDE8 		pop	{r4, r5, r6, pc}
 5277              	.LVL574:
 5278              	.L461:
4500:../src/FreeRTOS/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
 5279              		.loc 1 4500 0
 5280 00a0 0210A0E1 		mov	r1, r2
 5281 00a4 0400A0E1 		mov	r0, r4
 5282 00a8 FEFFFFEB 		bl	prvAddCurrentTaskToDelayedList
 5283              	.LVL575:
4507:../src/FreeRTOS/tasks.c **** 				}
 5284              		.loc 1 4507 0
 5285              		.syntax divided
 5286              	@ 4507 "../src/FreeRTOS/tasks.c" 1
 5287 00ac 000000EF 		SWI 0
 5288              	@ 0 "" 2
 5289              		.arm
 5290              		.syntax unified
 5291 00b0 E3FFFFEA 		b	.L457
 5292              	.LVL576:
 5293              	.L462:
4530:../src/FreeRTOS/tasks.c **** 				}
 5294              		.loc 1 4530 0
 5295 00b4 003000E3 		movw	r3, #:lower16:.LANCHOR10
 5296 00b8 003040E3 		movt	r3, #:upper16:.LANCHOR10
 5297 00bc 003093E5 		ldr	r3, [r3]
 5298 00c0 0020A0E3 		mov	r2, #0
 5299 00c4 702083E5 		str	r2, [r3, #112]
 5300 00c8 ECFFFFEA 		b	.L458
 5301              		.cfi_endproc
 5302              	.LFE61:
 5304              		.section	.text.xTaskNotifyWait,"ax",%progbits
 5305              		.align	2
 5306              		.global	xTaskNotifyWait
 5307              		.syntax unified
 5308              		.arm
 5309              		.fpu neon
 5311              	xTaskNotifyWait:
 5312              	.LFB62:
4555:../src/FreeRTOS/tasks.c **** 	BaseType_t xReturn;
 5313              		.loc 1 4555 0
 5314              		.cfi_startproc
 5315              		@ args = 0, pretend = 0, frame = 0
 5316              		@ frame_needed = 0, uses_anonymous_args = 0
 5317              	.LVL577:
 5318 0000 F0412DE9 		push	{r4, r5, r6, r7, r8, lr}
 5319              		.cfi_def_cfa_offset 24
 5320              		.cfi_offset 4, -24
 5321              		.cfi_offset 5, -20
 5322              		.cfi_offset 6, -16
 5323              		.cfi_offset 7, -12
 5324              		.cfi_offset 8, -8
 5325              		.cfi_offset 14, -4
 5326 0004 0070A0E1 		mov	r7, r0
 5327 0008 0140A0E1 		mov	r4, r1
 5328 000c 0250A0E1 		mov	r5, r2
 5329 0010 0360A0E1 		mov	r6, r3
4558:../src/FreeRTOS/tasks.c **** 		{
 5330              		.loc 1 4558 0
 5331 0014 FEFFFFEB 		bl	vPortEnterCritical
 5332              	.LVL578:
4561:../src/FreeRTOS/tasks.c **** 			{
 5333              		.loc 1 4561 0
 5334 0018 003000E3 		movw	r3, #:lower16:.LANCHOR10
 5335 001c 003040E3 		movt	r3, #:upper16:.LANCHOR10
 5336 0020 003093E5 		ldr	r3, [r3]
 5337 0024 7430D3E5 		ldrb	r3, [r3, #116]	@ zero_extendqisi2
 5338 0028 7330EFE6 		uxtb	r3, r3
 5339 002c 020053E3 		cmp	r3, #2
 5340 0030 0A00000A 		beq	.L464
4566:../src/FreeRTOS/tasks.c **** 
 5341              		.loc 1 4566 0
 5342 0034 003000E3 		movw	r3, #:lower16:.LANCHOR10
 5343 0038 003040E3 		movt	r3, #:upper16:.LANCHOR10
 5344 003c 002093E5 		ldr	r2, [r3]
 5345 0040 700092E5 		ldr	r0, [r2, #112]
 5346 0044 0700C0E1 		bic	r0, r0, r7
 5347 0048 700082E5 		str	r0, [r2, #112]
4569:../src/FreeRTOS/tasks.c **** 
 5348              		.loc 1 4569 0
 5349 004c 003093E5 		ldr	r3, [r3]
 5350 0050 0120A0E3 		mov	r2, #1
 5351 0054 7420C3E5 		strb	r2, [r3, #116]
4571:../src/FreeRTOS/tasks.c **** 				{
 5352              		.loc 1 4571 0
 5353 0058 000056E3 		cmp	r6, #0
 5354 005c 1800001A 		bne	.L469
 5355              	.L464:
4592:../src/FreeRTOS/tasks.c **** 
 5356              		.loc 1 4592 0
 5357 0060 FEFFFFEB 		bl	vPortExitCritical
 5358              	.LVL579:
4594:../src/FreeRTOS/tasks.c **** 		{
 5359              		.loc 1 4594 0
 5360 0064 FEFFFFEB 		bl	vPortEnterCritical
 5361              	.LVL580:
4598:../src/FreeRTOS/tasks.c **** 			{
 5362              		.loc 1 4598 0
 5363 0068 000055E3 		cmp	r5, #0
 5364 006c 0400000A 		beq	.L465
4602:../src/FreeRTOS/tasks.c **** 			}
 5365              		.loc 1 4602 0
 5366 0070 003000E3 		movw	r3, #:lower16:.LANCHOR10
 5367 0074 003040E3 		movt	r3, #:upper16:.LANCHOR10
 5368 0078 003093E5 		ldr	r3, [r3]
 5369 007c 703093E5 		ldr	r3, [r3, #112]
 5370 0080 003085E5 		str	r3, [r5]
 5371              	.L465:
4609:../src/FreeRTOS/tasks.c **** 			{
 5372              		.loc 1 4609 0
 5373 0084 003000E3 		movw	r3, #:lower16:.LANCHOR10
 5374 0088 003040E3 		movt	r3, #:upper16:.LANCHOR10
 5375 008c 003093E5 		ldr	r3, [r3]
 5376 0090 7430D3E5 		ldrb	r3, [r3, #116]	@ zero_extendqisi2
 5377 0094 7330EFE6 		uxtb	r3, r3
 5378 0098 020053E3 		cmp	r3, #2
 5379 009c 0D00000A 		beq	.L470
4612:../src/FreeRTOS/tasks.c **** 			}
 5380              		.loc 1 4612 0
 5381 00a0 0040A0E3 		mov	r4, #0
 5382              	.LVL581:
 5383              	.L466:
4622:../src/FreeRTOS/tasks.c **** 		}
 5384              		.loc 1 4622 0
 5385 00a4 003000E3 		movw	r3, #:lower16:.LANCHOR10
 5386 00a8 003040E3 		movt	r3, #:upper16:.LANCHOR10
 5387 00ac 003093E5 		ldr	r3, [r3]
 5388 00b0 0020A0E3 		mov	r2, #0
 5389 00b4 7420C3E5 		strb	r2, [r3, #116]
4624:../src/FreeRTOS/tasks.c **** 
 5390              		.loc 1 4624 0
 5391 00b8 FEFFFFEB 		bl	vPortExitCritical
 5392              	.LVL582:
4627:../src/FreeRTOS/tasks.c **** 
 5393              		.loc 1 4627 0
 5394 00bc 0400A0E1 		mov	r0, r4
 5395 00c0 F081BDE8 		pop	{r4, r5, r6, r7, r8, pc}
 5396              	.LVL583:
 5397              	.L469:
4573:../src/FreeRTOS/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
 5398              		.loc 1 4573 0
 5399 00c4 0210A0E1 		mov	r1, r2
 5400 00c8 0600A0E1 		mov	r0, r6
 5401 00cc FEFFFFEB 		bl	prvAddCurrentTaskToDelayedList
 5402              	.LVL584:
4580:../src/FreeRTOS/tasks.c **** 				}
 5403              		.loc 1 4580 0
 5404              		.syntax divided
 5405              	@ 4580 "../src/FreeRTOS/tasks.c" 1
 5406 00d0 000000EF 		SWI 0
 5407              	@ 0 "" 2
 5408              		.arm
 5409              		.syntax unified
 5410 00d4 E1FFFFEA 		b	.L464
 5411              	.L470:
4618:../src/FreeRTOS/tasks.c **** 				xReturn = pdTRUE;
 5412              		.loc 1 4618 0
 5413 00d8 003000E3 		movw	r3, #:lower16:.LANCHOR10
 5414 00dc 003040E3 		movt	r3, #:upper16:.LANCHOR10
 5415 00e0 002093E5 		ldr	r2, [r3]
 5416 00e4 703092E5 		ldr	r3, [r2, #112]
 5417 00e8 0440C3E1 		bic	r4, r3, r4
 5418              	.LVL585:
 5419 00ec 704082E5 		str	r4, [r2, #112]
 5420              	.LVL586:
4619:../src/FreeRTOS/tasks.c **** 			}
 5421              		.loc 1 4619 0
 5422 00f0 0140A0E3 		mov	r4, #1
 5423 00f4 EAFFFFEA 		b	.L466
 5424              		.cfi_endproc
 5425              	.LFE62:
 5427              		.section	.text.xTaskGenericNotify,"ax",%progbits
 5428              		.align	2
 5429              		.global	xTaskGenericNotify
 5430              		.syntax unified
 5431              		.arm
 5432              		.fpu neon
 5434              	xTaskGenericNotify:
 5435              	.LFB63:
4635:../src/FreeRTOS/tasks.c **** 	TCB_t * pxTCB;
 5436              		.loc 1 4635 0
 5437              		.cfi_startproc
 5438              		@ args = 0, pretend = 0, frame = 0
 5439              		@ frame_needed = 0, uses_anonymous_args = 0
 5440              	.LVL587:
 5441 0000 F0412DE9 		push	{r4, r5, r6, r7, r8, lr}
 5442              		.cfi_def_cfa_offset 24
 5443              		.cfi_offset 4, -24
 5444              		.cfi_offset 5, -20
 5445              		.cfi_offset 6, -16
 5446              		.cfi_offset 7, -12
 5447              		.cfi_offset 8, -8
 5448              		.cfi_offset 14, -4
 5449 0004 0170A0E1 		mov	r7, r1
 5450 0008 0250A0E1 		mov	r5, r2
 5451 000c 0360A0E1 		mov	r6, r3
 5452              	.LVL588:
4640:../src/FreeRTOS/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
 5453              		.loc 1 4640 0
 5454 0010 004050E2 		subs	r4, r0, #0
 5455 0014 0F00000A 		beq	.L486
 5456              	.LVL589:
 5457              	.L472:
4643:../src/FreeRTOS/tasks.c **** 		{
 5458              		.loc 1 4643 0
 5459 0018 FEFFFFEB 		bl	vPortEnterCritical
 5460              	.LVL590:
4645:../src/FreeRTOS/tasks.c **** 			{
 5461              		.loc 1 4645 0
 5462 001c 000056E3 		cmp	r6, #0
4647:../src/FreeRTOS/tasks.c **** 			}
 5463              		.loc 1 4647 0
 5464 0020 70309415 		ldrne	r3, [r4, #112]
 5465 0024 00308615 		strne	r3, [r6]
 5466              	.L473:
4650:../src/FreeRTOS/tasks.c **** 
 5467              		.loc 1 4650 0
 5468 0028 7430D4E5 		ldrb	r3, [r4, #116]	@ zero_extendqisi2
 5469 002c 7330EFE6 		uxtb	r3, r3
 5470              	.LVL591:
4652:../src/FreeRTOS/tasks.c **** 
 5471              		.loc 1 4652 0
 5472 0030 0220A0E3 		mov	r2, #2
 5473 0034 7420C4E5 		strb	r2, [r4, #116]
4654:../src/FreeRTOS/tasks.c **** 			{
 5474              		.loc 1 4654 0
 5475 0038 012045E2 		sub	r2, r5, #1
 5476 003c 030052E3 		cmp	r2, #3
 5477 0040 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 5478 0044 1E0000EA 		b	.L483
 5479              	.L476:
 5480 0048 6C000000 		.word	.L475
 5481 004c 90000000 		.word	.L477
 5482 0050 A4000000 		.word	.L478
 5483 0054 B0000000 		.word	.L479
 5484              	.LVL592:
 5485              	.L486:
4640:../src/FreeRTOS/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
 5486              		.loc 1 4640 0 discriminator 1
 5487 0058 201201E3 		movw	r1, #4640
 5488              	.LVL593:
 5489 005c 000000E3 		movw	r0, #:lower16:.LC0
 5490              	.LVL594:
 5491 0060 000040E3 		movt	r0, #:upper16:.LC0
 5492 0064 FEFFFFEB 		bl	R_OS_AssertCalled
 5493              	.LVL595:
 5494 0068 EAFFFFEA 		b	.L472
 5495              	.LVL596:
 5496              	.L475:
4657:../src/FreeRTOS/tasks.c **** 					break;
 5497              		.loc 1 4657 0
 5498 006c 702094E5 		ldr	r2, [r4, #112]
 5499 0070 077082E1 		orr	r7, r2, r7
 5500              	.LVL597:
 5501 0074 707084E5 		str	r7, [r4, #112]
4637:../src/FreeRTOS/tasks.c **** 	uint8_t ucOriginalNotifyState;
 5502              		.loc 1 4637 0
 5503 0078 0150A0E3 		mov	r5, #1
 5504              	.L474:
 5505              	.LVL598:
4690:../src/FreeRTOS/tasks.c **** 			{
 5506              		.loc 1 4690 0
 5507 007c 010053E3 		cmp	r3, #1
 5508 0080 1300000A 		beq	.L487
 5509              	.LVL599:
 5510              	.L480:
4730:../src/FreeRTOS/tasks.c **** 
 5511              		.loc 1 4730 0
 5512 0084 FEFFFFEB 		bl	vPortExitCritical
 5513              	.LVL600:
4733:../src/FreeRTOS/tasks.c **** 
 5514              		.loc 1 4733 0
 5515 0088 0500A0E1 		mov	r0, r5
 5516 008c F081BDE8 		pop	{r4, r5, r6, r7, r8, pc}
 5517              	.LVL601:
 5518              	.L477:
4661:../src/FreeRTOS/tasks.c **** 					break;
 5519              		.loc 1 4661 0
 5520 0090 702094E5 		ldr	r2, [r4, #112]
 5521 0094 012082E2 		add	r2, r2, #1
 5522 0098 702084E5 		str	r2, [r4, #112]
4637:../src/FreeRTOS/tasks.c **** 	uint8_t ucOriginalNotifyState;
 5523              		.loc 1 4637 0
 5524 009c 0150A0E3 		mov	r5, #1
4662:../src/FreeRTOS/tasks.c **** 
 5525              		.loc 1 4662 0
 5526 00a0 F5FFFFEA 		b	.L474
 5527              	.L478:
4665:../src/FreeRTOS/tasks.c **** 					break;
 5528              		.loc 1 4665 0
 5529 00a4 707084E5 		str	r7, [r4, #112]
4637:../src/FreeRTOS/tasks.c **** 	uint8_t ucOriginalNotifyState;
 5530              		.loc 1 4637 0
 5531 00a8 0150A0E3 		mov	r5, #1
4666:../src/FreeRTOS/tasks.c **** 
 5532              		.loc 1 4666 0
 5533 00ac F2FFFFEA 		b	.L474
 5534              	.L479:
4669:../src/FreeRTOS/tasks.c **** 					{
 5535              		.loc 1 4669 0
 5536 00b0 020053E3 		cmp	r3, #2
 5537 00b4 0400000A 		beq	.L484
4671:../src/FreeRTOS/tasks.c **** 					}
 5538              		.loc 1 4671 0
 5539 00b8 707084E5 		str	r7, [r4, #112]
4637:../src/FreeRTOS/tasks.c **** 	uint8_t ucOriginalNotifyState;
 5540              		.loc 1 4637 0
 5541 00bc 0150A0E3 		mov	r5, #1
 5542 00c0 EDFFFFEA 		b	.L474
 5543              	.L483:
 5544 00c4 0150A0E3 		mov	r5, #1
 5545 00c8 EBFFFFEA 		b	.L474
 5546              	.L484:
4676:../src/FreeRTOS/tasks.c **** 					}
 5547              		.loc 1 4676 0
 5548 00cc 0050A0E3 		mov	r5, #0
 5549 00d0 E9FFFFEA 		b	.L474
 5550              	.LVL602:
 5551              	.L487:
4692:../src/FreeRTOS/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 5552              		.loc 1 4692 0
 5553 00d4 046084E2 		add	r6, r4, #4
 5554              	.LVL603:
 5555 00d8 0600A0E1 		mov	r0, r6
 5556 00dc FEFFFFEB 		bl	uxListRemove
 5557              	.LVL604:
4693:../src/FreeRTOS/tasks.c **** 
 5558              		.loc 1 4693 0
 5559 00e0 2C3094E5 		ldr	r3, [r4, #44]
 5560 00e4 002000E3 		movw	r2, #:lower16:.LANCHOR13
 5561 00e8 002040E3 		movt	r2, #:upper16:.LANCHOR13
 5562 00ec 002092E5 		ldr	r2, [r2]
 5563 00f0 020053E1 		cmp	r3, r2
4693:../src/FreeRTOS/tasks.c **** 
 5564              		.loc 1 4693 0 is_stmt 0 discriminator 1
 5565 00f4 00200083 		movwhi	r2, #:lower16:.LANCHOR13
 5566 00f8 00204083 		movthi	r2, #:upper16:.LANCHOR13
 5567 00fc 00308285 		strhi	r3, [r2]
 5568              	.L481:
4693:../src/FreeRTOS/tasks.c **** 
 5569              		.loc 1 4693 0 discriminator 3
 5570 0100 002000E3 		movw	r2, #:lower16:.LANCHOR4
 5571 0104 002040E3 		movt	r2, #:upper16:.LANCHOR4
 5572 0108 033183E0 		add	r3, r3, r3, lsl #2
 5573 010c 0301A0E1 		lsl	r0, r3, #2
 5574 0110 0610A0E1 		mov	r1, r6
 5575 0114 000082E0 		add	r0, r2, r0
 5576 0118 FEFFFFEB 		bl	vListInsertEnd
 5577              	.LVL605:
4696:../src/FreeRTOS/tasks.c **** 
 5578              		.loc 1 4696 0 is_stmt 1 discriminator 3
 5579 011c 283094E5 		ldr	r3, [r4, #40]
 5580 0120 000053E3 		cmp	r3, #0
 5581 0124 0300000A 		beq	.L482
4696:../src/FreeRTOS/tasks.c **** 
 5582              		.loc 1 4696 0 is_stmt 0 discriminator 1
 5583 0128 581201E3 		movw	r1, #4696
 5584 012c 000000E3 		movw	r0, #:lower16:.LC0
 5585 0130 000040E3 		movt	r0, #:upper16:.LC0
 5586 0134 FEFFFFEB 		bl	R_OS_AssertCalled
 5587              	.LVL606:
 5588              	.L482:
4714:../src/FreeRTOS/tasks.c **** 				{
 5589              		.loc 1 4714 0 is_stmt 1
 5590 0138 2C2094E5 		ldr	r2, [r4, #44]
 5591 013c 003000E3 		movw	r3, #:lower16:.LANCHOR10
 5592 0140 003040E3 		movt	r3, #:upper16:.LANCHOR10
 5593 0144 003093E5 		ldr	r3, [r3]
 5594 0148 2C3093E5 		ldr	r3, [r3, #44]
 5595 014c 030052E1 		cmp	r2, r3
 5596 0150 CBFFFF9A 		bls	.L480
4718:../src/FreeRTOS/tasks.c **** 				}
 5597              		.loc 1 4718 0
 5598              		.syntax divided
 5599              	@ 4718 "../src/FreeRTOS/tasks.c" 1
 5600 0154 000000EF 		SWI 0
 5601              	@ 0 "" 2
 5602              		.arm
 5603              		.syntax unified
 5604 0158 C9FFFFEA 		b	.L480
 5605              		.cfi_endproc
 5606              	.LFE63:
 5608              		.section	.text.xTaskGenericNotifyFromISR,"ax",%progbits
 5609              		.align	2
 5610              		.global	xTaskGenericNotifyFromISR
 5611              		.syntax unified
 5612              		.arm
 5613              		.fpu neon
 5615              	xTaskGenericNotifyFromISR:
 5616              	.LFB64:
4741:../src/FreeRTOS/tasks.c **** 	TCB_t * pxTCB;
 5617              		.loc 1 4741 0
 5618              		.cfi_startproc
 5619              		@ args = 4, pretend = 0, frame = 0
 5620              		@ frame_needed = 0, uses_anonymous_args = 0
 5621              	.LVL607:
 5622 0000 F0412DE9 		push	{r4, r5, r6, r7, r8, lr}
 5623              		.cfi_def_cfa_offset 24
 5624              		.cfi_offset 4, -24
 5625              		.cfi_offset 5, -20
 5626              		.cfi_offset 6, -16
 5627              		.cfi_offset 7, -12
 5628              		.cfi_offset 8, -8
 5629              		.cfi_offset 14, -4
 5630 0004 0180A0E1 		mov	r8, r1
 5631 0008 0250A0E1 		mov	r5, r2
 5632 000c 0360A0E1 		mov	r6, r3
 5633              	.LVL608:
4747:../src/FreeRTOS/tasks.c **** 
 5634              		.loc 1 4747 0
 5635 0010 004050E2 		subs	r4, r0, #0
 5636 0014 1100000A 		beq	.L506
 5637              	.LVL609:
 5638              	.L489:
4765:../src/FreeRTOS/tasks.c **** 
 5639              		.loc 1 4765 0
 5640 0018 FEFFFFEB 		bl	vPortValidateInterruptPriority
 5641              	.LVL610:
4769:../src/FreeRTOS/tasks.c **** 		{
 5642              		.loc 1 4769 0
 5643 001c FEFFFFEB 		bl	ulPortSetInterruptMask
 5644              	.LVL611:
 5645 0020 0070A0E1 		mov	r7, r0
 5646              	.LVL612:
4771:../src/FreeRTOS/tasks.c **** 			{
 5647              		.loc 1 4771 0
 5648 0024 000056E3 		cmp	r6, #0
4773:../src/FreeRTOS/tasks.c **** 			}
 5649              		.loc 1 4773 0
 5650 0028 70309415 		ldrne	r3, [r4, #112]
 5651 002c 00308615 		strne	r3, [r6]
 5652              	.L490:
4776:../src/FreeRTOS/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 5653              		.loc 1 4776 0
 5654 0030 7430D4E5 		ldrb	r3, [r4, #116]	@ zero_extendqisi2
 5655 0034 7330EFE6 		uxtb	r3, r3
 5656              	.LVL613:
4777:../src/FreeRTOS/tasks.c **** 
 5657              		.loc 1 4777 0
 5658 0038 0220A0E3 		mov	r2, #2
 5659 003c 7420C4E5 		strb	r2, [r4, #116]
4779:../src/FreeRTOS/tasks.c **** 			{
 5660              		.loc 1 4779 0
 5661 0040 012045E2 		sub	r2, r5, #1
 5662 0044 030052E3 		cmp	r2, #3
 5663 0048 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 5664 004c 1F0000EA 		b	.L503
 5665              	.L493:
 5666 0050 74000000 		.word	.L492
 5667 0054 9C000000 		.word	.L494
 5668 0058 B0000000 		.word	.L495
 5669 005c BC000000 		.word	.L496
 5670              	.LVL614:
 5671              	.L506:
4747:../src/FreeRTOS/tasks.c **** 
 5672              		.loc 1 4747 0 discriminator 1
 5673 0060 8B1201E3 		movw	r1, #4747
 5674              	.LVL615:
 5675 0064 000000E3 		movw	r0, #:lower16:.LC0
 5676              	.LVL616:
 5677 0068 000040E3 		movt	r0, #:upper16:.LC0
 5678 006c FEFFFFEB 		bl	R_OS_AssertCalled
 5679              	.LVL617:
 5680 0070 E8FFFFEA 		b	.L489
 5681              	.LVL618:
 5682              	.L492:
4782:../src/FreeRTOS/tasks.c **** 					break;
 5683              		.loc 1 4782 0
 5684 0074 702094E5 		ldr	r2, [r4, #112]
 5685 0078 088082E1 		orr	r8, r2, r8
 5686              	.LVL619:
 5687 007c 708084E5 		str	r8, [r4, #112]
4744:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
 5688              		.loc 1 4744 0
 5689 0080 0150A0E3 		mov	r5, #1
 5690              	.L491:
 5691              	.LVL620:
4815:../src/FreeRTOS/tasks.c **** 			{
 5692              		.loc 1 4815 0
 5693 0084 010053E3 		cmp	r3, #1
 5694 0088 1400000A 		beq	.L507
 5695              	.LVL621:
 5696              	.L497:
4854:../src/FreeRTOS/tasks.c **** 
 5697              		.loc 1 4854 0
 5698 008c 0700A0E1 		mov	r0, r7
 5699 0090 FEFFFFEB 		bl	vPortClearInterruptMask
 5700              	.LVL622:
4857:../src/FreeRTOS/tasks.c **** 
 5701              		.loc 1 4857 0
 5702 0094 0500A0E1 		mov	r0, r5
 5703 0098 F081BDE8 		pop	{r4, r5, r6, r7, r8, pc}
 5704              	.LVL623:
 5705              	.L494:
4786:../src/FreeRTOS/tasks.c **** 					break;
 5706              		.loc 1 4786 0
 5707 009c 702094E5 		ldr	r2, [r4, #112]
 5708 00a0 012082E2 		add	r2, r2, #1
 5709 00a4 702084E5 		str	r2, [r4, #112]
4744:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
 5710              		.loc 1 4744 0
 5711 00a8 0150A0E3 		mov	r5, #1
4787:../src/FreeRTOS/tasks.c **** 
 5712              		.loc 1 4787 0
 5713 00ac F4FFFFEA 		b	.L491
 5714              	.L495:
4790:../src/FreeRTOS/tasks.c **** 					break;
 5715              		.loc 1 4790 0
 5716 00b0 708084E5 		str	r8, [r4, #112]
4744:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
 5717              		.loc 1 4744 0
 5718 00b4 0150A0E3 		mov	r5, #1
4791:../src/FreeRTOS/tasks.c **** 
 5719              		.loc 1 4791 0
 5720 00b8 F1FFFFEA 		b	.L491
 5721              	.L496:
4794:../src/FreeRTOS/tasks.c **** 					{
 5722              		.loc 1 4794 0
 5723 00bc 020053E3 		cmp	r3, #2
 5724 00c0 0400000A 		beq	.L504
4796:../src/FreeRTOS/tasks.c **** 					}
 5725              		.loc 1 4796 0
 5726 00c4 708084E5 		str	r8, [r4, #112]
4744:../src/FreeRTOS/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
 5727              		.loc 1 4744 0
 5728 00c8 0150A0E3 		mov	r5, #1
 5729 00cc ECFFFFEA 		b	.L491
 5730              	.L503:
 5731 00d0 0150A0E3 		mov	r5, #1
 5732 00d4 EAFFFFEA 		b	.L491
 5733              	.L504:
4801:../src/FreeRTOS/tasks.c **** 					}
 5734              		.loc 1 4801 0
 5735 00d8 0050A0E3 		mov	r5, #0
 5736 00dc E8FFFFEA 		b	.L491
 5737              	.LVL624:
 5738              	.L507:
4818:../src/FreeRTOS/tasks.c **** 
 5739              		.loc 1 4818 0
 5740 00e0 283094E5 		ldr	r3, [r4, #40]
 5741              	.LVL625:
 5742 00e4 000053E3 		cmp	r3, #0
 5743 00e8 0300000A 		beq	.L498
4818:../src/FreeRTOS/tasks.c **** 
 5744              		.loc 1 4818 0 is_stmt 0 discriminator 1
 5745 00ec D21201E3 		movw	r1, #4818
 5746 00f0 000000E3 		movw	r0, #:lower16:.LC0
 5747              	.LVL626:
 5748 00f4 000040E3 		movt	r0, #:upper16:.LC0
 5749 00f8 FEFFFFEB 		bl	R_OS_AssertCalled
 5750              	.LVL627:
 5751              	.L498:
4820:../src/FreeRTOS/tasks.c **** 				{
 5752              		.loc 1 4820 0 is_stmt 1
 5753 00fc 003000E3 		movw	r3, #:lower16:.LANCHOR16
 5754 0100 003040E3 		movt	r3, #:upper16:.LANCHOR16
 5755 0104 003093E5 		ldr	r3, [r3]
 5756 0108 000053E3 		cmp	r3, #0
 5757 010c 1F00001A 		bne	.L499
4822:../src/FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 5758              		.loc 1 4822 0
 5759 0110 046084E2 		add	r6, r4, #4
 5760              	.LVL628:
 5761 0114 0600A0E1 		mov	r0, r6
 5762 0118 FEFFFFEB 		bl	uxListRemove
 5763              	.LVL629:
4823:../src/FreeRTOS/tasks.c **** 				}
 5764              		.loc 1 4823 0
 5765 011c 2C3094E5 		ldr	r3, [r4, #44]
 5766 0120 002000E3 		movw	r2, #:lower16:.LANCHOR13
 5767 0124 002040E3 		movt	r2, #:upper16:.LANCHOR13
 5768 0128 002092E5 		ldr	r2, [r2]
 5769 012c 020053E1 		cmp	r3, r2
4823:../src/FreeRTOS/tasks.c **** 				}
 5770              		.loc 1 4823 0 is_stmt 0 discriminator 1
 5771 0130 00200083 		movwhi	r2, #:lower16:.LANCHOR13
 5772 0134 00204083 		movthi	r2, #:upper16:.LANCHOR13
 5773 0138 00308285 		strhi	r3, [r2]
 5774              	.L500:
4823:../src/FreeRTOS/tasks.c **** 				}
 5775              		.loc 1 4823 0 discriminator 3
 5776 013c 002000E3 		movw	r2, #:lower16:.LANCHOR4
 5777 0140 002040E3 		movt	r2, #:upper16:.LANCHOR4
 5778 0144 033183E0 		add	r3, r3, r3, lsl #2
 5779 0148 0301A0E1 		lsl	r0, r3, #2
 5780 014c 0610A0E1 		mov	r1, r6
 5781 0150 000082E0 		add	r0, r2, r0
 5782 0154 FEFFFFEB 		bl	vListInsertEnd
 5783              	.LVL630:
 5784              	.L501:
4832:../src/FreeRTOS/tasks.c **** 				{
 5785              		.loc 1 4832 0 is_stmt 1
 5786 0158 2C2094E5 		ldr	r2, [r4, #44]
 5787 015c 003000E3 		movw	r3, #:lower16:.LANCHOR10
 5788 0160 003040E3 		movt	r3, #:upper16:.LANCHOR10
 5789 0164 003093E5 		ldr	r3, [r3]
 5790 0168 2C3093E5 		ldr	r3, [r3, #44]
 5791 016c 030052E1 		cmp	r2, r3
 5792 0170 C5FFFF9A 		bls	.L497
4836:../src/FreeRTOS/tasks.c **** 					{
 5793              		.loc 1 4836 0
 5794 0174 18309DE5 		ldr	r3, [sp, #24]
 5795 0178 000053E3 		cmp	r3, #0
 5796 017c 0800000A 		beq	.L502
4838:../src/FreeRTOS/tasks.c **** 					}
 5797              		.loc 1 4838 0
 5798 0180 0130A0E3 		mov	r3, #1
 5799 0184 18209DE5 		ldr	r2, [sp, #24]
 5800 0188 003082E5 		str	r3, [r2]
 5801 018c BEFFFFEA 		b	.L497
 5802              	.LVL631:
 5803              	.L499:
4829:../src/FreeRTOS/tasks.c **** 				}
 5804              		.loc 1 4829 0
 5805 0190 181084E2 		add	r1, r4, #24
 5806 0194 000000E3 		movw	r0, #:lower16:.LANCHOR3
 5807 0198 000040E3 		movt	r0, #:upper16:.LANCHOR3
 5808 019c FEFFFFEB 		bl	vListInsertEnd
 5809              	.LVL632:
 5810 01a0 ECFFFFEA 		b	.L501
 5811              	.LVL633:
 5812              	.L502:
4845:../src/FreeRTOS/tasks.c **** 					}
 5813              		.loc 1 4845 0
 5814 01a4 003000E3 		movw	r3, #:lower16:.LANCHOR21
 5815 01a8 003040E3 		movt	r3, #:upper16:.LANCHOR21
 5816 01ac 0120A0E3 		mov	r2, #1
 5817 01b0 002083E5 		str	r2, [r3]
 5818 01b4 B4FFFFEA 		b	.L497
 5819              		.cfi_endproc
 5820              	.LFE64:
 5822              		.section	.text.vTaskNotifyGiveFromISR,"ax",%progbits
 5823              		.align	2
 5824              		.global	vTaskNotifyGiveFromISR
 5825              		.syntax unified
 5826              		.arm
 5827              		.fpu neon
 5829              	vTaskNotifyGiveFromISR:
 5830              	.LFB65:
4865:../src/FreeRTOS/tasks.c **** 	TCB_t * pxTCB;
 5831              		.loc 1 4865 0
 5832              		.cfi_startproc
 5833              		@ args = 0, pretend = 0, frame = 0
 5834              		@ frame_needed = 0, uses_anonymous_args = 0
 5835              	.LVL634:
 5836 0000 F0412DE9 		push	{r4, r5, r6, r7, r8, lr}
 5837              		.cfi_def_cfa_offset 24
 5838              		.cfi_offset 4, -24
 5839              		.cfi_offset 5, -20
 5840              		.cfi_offset 6, -16
 5841              		.cfi_offset 7, -12
 5842              		.cfi_offset 8, -8
 5843              		.cfi_offset 14, -4
 5844 0004 0160A0E1 		mov	r6, r1
4870:../src/FreeRTOS/tasks.c **** 
 5845              		.loc 1 4870 0
 5846 0008 004050E2 		subs	r4, r0, #0
 5847 000c 0E00000A 		beq	.L517
 5848              	.LVL635:
 5849              	.L509:
4888:../src/FreeRTOS/tasks.c **** 
 5850              		.loc 1 4888 0
 5851 0010 FEFFFFEB 		bl	vPortValidateInterruptPriority
 5852              	.LVL636:
4892:../src/FreeRTOS/tasks.c **** 		{
 5853              		.loc 1 4892 0
 5854 0014 FEFFFFEB 		bl	ulPortSetInterruptMask
 5855              	.LVL637:
 5856 0018 0050A0E1 		mov	r5, r0
 5857              	.LVL638:
4894:../src/FreeRTOS/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 5858              		.loc 1 4894 0
 5859 001c 7430D4E5 		ldrb	r3, [r4, #116]	@ zero_extendqisi2
 5860 0020 7330EFE6 		uxtb	r3, r3
 5861              	.LVL639:
4895:../src/FreeRTOS/tasks.c **** 
 5862              		.loc 1 4895 0
 5863 0024 0220A0E3 		mov	r2, #2
 5864 0028 7420C4E5 		strb	r2, [r4, #116]
4899:../src/FreeRTOS/tasks.c **** 
 5865              		.loc 1 4899 0
 5866 002c 702094E5 		ldr	r2, [r4, #112]
 5867 0030 012082E2 		add	r2, r2, #1
 5868 0034 702084E5 		str	r2, [r4, #112]
4905:../src/FreeRTOS/tasks.c **** 			{
 5869              		.loc 1 4905 0
 5870 0038 010053E3 		cmp	r3, #1
 5871 003c 0700000A 		beq	.L518
 5872              	.LVL640:
 5873              	.L510:
4944:../src/FreeRTOS/tasks.c **** 	}
 5874              		.loc 1 4944 0
 5875 0040 0500A0E1 		mov	r0, r5
 5876 0044 FEFFFFEB 		bl	vPortClearInterruptMask
 5877              	.LVL641:
 5878 0048 F081BDE8 		pop	{r4, r5, r6, r7, r8, pc}
 5879              	.LVL642:
 5880              	.L517:
4870:../src/FreeRTOS/tasks.c **** 
 5881              		.loc 1 4870 0 discriminator 1
 5882 004c 061301E3 		movw	r1, #4870
 5883              	.LVL643:
 5884 0050 000000E3 		movw	r0, #:lower16:.LC0
 5885              	.LVL644:
 5886 0054 000040E3 		movt	r0, #:upper16:.LC0
 5887 0058 FEFFFFEB 		bl	R_OS_AssertCalled
 5888              	.LVL645:
 5889 005c EBFFFFEA 		b	.L509
 5890              	.LVL646:
 5891              	.L518:
4908:../src/FreeRTOS/tasks.c **** 
 5892              		.loc 1 4908 0
 5893 0060 283094E5 		ldr	r3, [r4, #40]
 5894              	.LVL647:
 5895 0064 000053E3 		cmp	r3, #0
 5896 0068 0300000A 		beq	.L511
4908:../src/FreeRTOS/tasks.c **** 
 5897              		.loc 1 4908 0 is_stmt 0 discriminator 1
 5898 006c 2C1301E3 		movw	r1, #4908
 5899 0070 000000E3 		movw	r0, #:lower16:.LC0
 5900              	.LVL648:
 5901 0074 000040E3 		movt	r0, #:upper16:.LC0
 5902 0078 FEFFFFEB 		bl	R_OS_AssertCalled
 5903              	.LVL649:
 5904              	.L511:
4910:../src/FreeRTOS/tasks.c **** 				{
 5905              		.loc 1 4910 0 is_stmt 1
 5906 007c 003000E3 		movw	r3, #:lower16:.LANCHOR16
 5907 0080 003040E3 		movt	r3, #:upper16:.LANCHOR16
 5908 0084 003093E5 		ldr	r3, [r3]
 5909 0088 000053E3 		cmp	r3, #0
 5910 008c 1D00001A 		bne	.L512
4912:../src/FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 5911              		.loc 1 4912 0
 5912 0090 047084E2 		add	r7, r4, #4
 5913 0094 0700A0E1 		mov	r0, r7
 5914 0098 FEFFFFEB 		bl	uxListRemove
 5915              	.LVL650:
4913:../src/FreeRTOS/tasks.c **** 				}
 5916              		.loc 1 4913 0
 5917 009c 2C3094E5 		ldr	r3, [r4, #44]
 5918 00a0 002000E3 		movw	r2, #:lower16:.LANCHOR13
 5919 00a4 002040E3 		movt	r2, #:upper16:.LANCHOR13
 5920 00a8 002092E5 		ldr	r2, [r2]
 5921 00ac 020053E1 		cmp	r3, r2
4913:../src/FreeRTOS/tasks.c **** 				}
 5922              		.loc 1 4913 0 is_stmt 0 discriminator 1
 5923 00b0 00200083 		movwhi	r2, #:lower16:.LANCHOR13
 5924 00b4 00204083 		movthi	r2, #:upper16:.LANCHOR13
 5925 00b8 00308285 		strhi	r3, [r2]
 5926              	.L513:
4913:../src/FreeRTOS/tasks.c **** 				}
 5927              		.loc 1 4913 0 discriminator 3
 5928 00bc 002000E3 		movw	r2, #:lower16:.LANCHOR4
 5929 00c0 002040E3 		movt	r2, #:upper16:.LANCHOR4
 5930 00c4 033183E0 		add	r3, r3, r3, lsl #2
 5931 00c8 0301A0E1 		lsl	r0, r3, #2
 5932 00cc 0710A0E1 		mov	r1, r7
 5933 00d0 000082E0 		add	r0, r2, r0
 5934 00d4 FEFFFFEB 		bl	vListInsertEnd
 5935              	.LVL651:
 5936              	.L514:
4922:../src/FreeRTOS/tasks.c **** 				{
 5937              		.loc 1 4922 0 is_stmt 1
 5938 00d8 2C2094E5 		ldr	r2, [r4, #44]
 5939 00dc 003000E3 		movw	r3, #:lower16:.LANCHOR10
 5940 00e0 003040E3 		movt	r3, #:upper16:.LANCHOR10
 5941 00e4 003093E5 		ldr	r3, [r3]
 5942 00e8 2C3093E5 		ldr	r3, [r3, #44]
 5943 00ec 030052E1 		cmp	r2, r3
 5944 00f0 D2FFFF9A 		bls	.L510
4926:../src/FreeRTOS/tasks.c **** 					{
 5945              		.loc 1 4926 0
 5946 00f4 000056E3 		cmp	r6, #0
 5947 00f8 0700000A 		beq	.L515
4928:../src/FreeRTOS/tasks.c **** 					}
 5948              		.loc 1 4928 0
 5949 00fc 0130A0E3 		mov	r3, #1
 5950 0100 003086E5 		str	r3, [r6]
 5951 0104 CDFFFFEA 		b	.L510
 5952              	.L512:
4919:../src/FreeRTOS/tasks.c **** 				}
 5953              		.loc 1 4919 0
 5954 0108 181084E2 		add	r1, r4, #24
 5955 010c 000000E3 		movw	r0, #:lower16:.LANCHOR3
 5956 0110 000040E3 		movt	r0, #:upper16:.LANCHOR3
 5957 0114 FEFFFFEB 		bl	vListInsertEnd
 5958              	.LVL652:
 5959 0118 EEFFFFEA 		b	.L514
 5960              	.L515:
4935:../src/FreeRTOS/tasks.c **** 					}
 5961              		.loc 1 4935 0
 5962 011c 003000E3 		movw	r3, #:lower16:.LANCHOR21
 5963 0120 003040E3 		movt	r3, #:upper16:.LANCHOR21
 5964 0124 0120A0E3 		mov	r2, #1
 5965 0128 002083E5 		str	r2, [r3]
 5966 012c C3FFFFEA 		b	.L510
 5967              		.cfi_endproc
 5968              	.LFE65:
 5970              		.section	.text.xTaskNotifyStateClear,"ax",%progbits
 5971              		.align	2
 5972              		.global	xTaskNotifyStateClear
 5973              		.syntax unified
 5974              		.arm
 5975              		.fpu neon
 5977              	xTaskNotifyStateClear:
 5978              	.LFB66:
4954:../src/FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
 5979              		.loc 1 4954 0
 5980              		.cfi_startproc
 5981              		@ args = 0, pretend = 0, frame = 0
 5982              		@ frame_needed = 0, uses_anonymous_args = 0
 5983              	.LVL653:
 5984 0000 10402DE9 		push	{r4, lr}
 5985              		.cfi_def_cfa_offset 8
 5986              		.cfi_offset 4, -8
 5987              		.cfi_offset 14, -4
4960:../src/FreeRTOS/tasks.c **** 
 5988              		.loc 1 4960 0
 5989 0004 004050E2 		subs	r4, r0, #0
 5990 0008 0800000A 		beq	.L525
 5991              	.L520:
 5992              	.LVL654:
4962:../src/FreeRTOS/tasks.c **** 		{
 5993              		.loc 1 4962 0 discriminator 4
 5994 000c FEFFFFEB 		bl	vPortEnterCritical
 5995              	.LVL655:
4964:../src/FreeRTOS/tasks.c **** 			{
 5996              		.loc 1 4964 0 discriminator 4
 5997 0010 7430D4E5 		ldrb	r3, [r4, #116]	@ zero_extendqisi2
 5998 0014 7330EFE6 		uxtb	r3, r3
 5999 0018 020053E3 		cmp	r3, #2
 6000 001c 0700000A 		beq	.L526
4971:../src/FreeRTOS/tasks.c **** 			}
 6001              		.loc 1 4971 0
 6002 0020 0040A0E3 		mov	r4, #0
 6003              	.LVL656:
 6004              	.L521:
4974:../src/FreeRTOS/tasks.c **** 
 6005              		.loc 1 4974 0
 6006 0024 FEFFFFEB 		bl	vPortExitCritical
 6007              	.LVL657:
4977:../src/FreeRTOS/tasks.c **** 
 6008              		.loc 1 4977 0
 6009 0028 0400A0E1 		mov	r0, r4
 6010 002c 1080BDE8 		pop	{r4, pc}
 6011              	.LVL658:
 6012              	.L525:
4960:../src/FreeRTOS/tasks.c **** 
 6013              		.loc 1 4960 0 discriminator 1
 6014 0030 003000E3 		movw	r3, #:lower16:.LANCHOR10
 6015 0034 003040E3 		movt	r3, #:upper16:.LANCHOR10
 6016 0038 004093E5 		ldr	r4, [r3]
 6017 003c F2FFFFEA 		b	.L520
 6018              	.LVL659:
 6019              	.L526:
4966:../src/FreeRTOS/tasks.c **** 				xReturn = pdPASS;
 6020              		.loc 1 4966 0
 6021 0040 0030A0E3 		mov	r3, #0
 6022 0044 7430C4E5 		strb	r3, [r4, #116]
 6023              	.LVL660:
4967:../src/FreeRTOS/tasks.c **** 			}
 6024              		.loc 1 4967 0
 6025 0048 0140A0E3 		mov	r4, #1
 6026              	.LVL661:
 6027 004c F4FFFFEA 		b	.L521
 6028              		.cfi_endproc
 6029              	.LFE66:
 6031              		.global	pxCurrentTCB
 6032              		.section	.bss.pxCurrentTCB,"aw",%nobits
 6033              		.align	2
 6034              		.set	.LANCHOR10,. + 0
 6037              	pxCurrentTCB:
 6038 0000 00000000 		.space	4
 6039              		.section	.bss.pxDelayedTaskList,"aw",%nobits
 6040              		.align	2
 6041              		.set	.LANCHOR0,. + 0
 6044              	pxDelayedTaskList:
 6045 0000 00000000 		.space	4
 6046              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
 6047              		.align	2
 6048              		.set	.LANCHOR8,. + 0
 6051              	pxOverflowDelayedTaskList:
 6052 0000 00000000 		.space	4
 6053              		.section	.bss.pxReadyTasksLists,"aw",%nobits
 6054              		.align	2
 6055              		.set	.LANCHOR4,. + 0
 6058              	pxReadyTasksLists:
 6059 0000 00000000 		.space	400
 6059      00000000 
 6059      00000000 
 6059      00000000 
 6059      00000000 
 6060              		.section	.bss.ulTaskSwitchedInTime,"aw",%nobits
 6061              		.align	2
 6062              		.set	.LANCHOR22,. + 0
 6065              	ulTaskSwitchedInTime:
 6066 0000 00000000 		.space	4
 6067              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
 6068              		.align	2
 6069              		.set	.LANCHOR9,. + 0
 6072              	uxCurrentNumberOfTasks:
 6073 0000 00000000 		.space	4
 6074              		.section	.bss.uxDeletedTasksWaitingCleanUp,"aw",%nobits
 6075              		.align	2
 6076              		.set	.LANCHOR14,. + 0
 6079              	uxDeletedTasksWaitingCleanUp:
 6080 0000 00000000 		.space	4
 6081              		.section	.bss.uxPendedTicks,"aw",%nobits
 6082              		.align	2
 6083              		.set	.LANCHOR20,. + 0
 6086              	uxPendedTicks:
 6087 0000 00000000 		.space	4
 6088              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 6089              		.align	2
 6090              		.set	.LANCHOR16,. + 0
 6093              	uxSchedulerSuspended:
 6094 0000 00000000 		.space	4
 6095              		.section	.bss.uxTaskNumber,"aw",%nobits
 6096              		.align	2
 6097              		.set	.LANCHOR12,. + 0
 6100              	uxTaskNumber:
 6101 0000 00000000 		.space	4
 6102              		.section	.bss.uxTopReadyPriority,"aw",%nobits
 6103              		.align	2
 6104              		.set	.LANCHOR13,. + 0
 6107              	uxTopReadyPriority:
 6108 0000 00000000 		.space	4
 6109              		.section	.bss.xDelayedTaskList1,"aw",%nobits
 6110              		.align	2
 6111              		.set	.LANCHOR5,. + 0
 6114              	xDelayedTaskList1:
 6115 0000 00000000 		.space	20
 6115      00000000 
 6115      00000000 
 6115      00000000 
 6115      00000000 
 6116              		.section	.bss.xDelayedTaskList2,"aw",%nobits
 6117              		.align	2
 6118              		.set	.LANCHOR6,. + 0
 6121              	xDelayedTaskList2:
 6122 0000 00000000 		.space	20
 6122      00000000 
 6122      00000000 
 6122      00000000 
 6122      00000000 
 6123              		.section	.bss.xIdleTaskHandle,"aw",%nobits
 6124              		.align	2
 6125              		.set	.LANCHOR17,. + 0
 6128              	xIdleTaskHandle:
 6129 0000 00000000 		.space	4
 6130              		.section	.bss.xIdleTickCount,"aw",%nobits
 6131              		.align	2
 6132              		.set	.LANCHOR18,. + 0
 6135              	xIdleTickCount:
 6136 0000 00000000 		.space	4
 6137              		.section	.bss.xNextTaskUnblockTime,"aw",%nobits
 6138              		.align	2
 6139              		.set	.LANCHOR1,. + 0
 6142              	xNextTaskUnblockTime:
 6143 0000 00000000 		.space	4
 6144              		.section	.bss.xNumOfOverflows,"aw",%nobits
 6145              		.align	2
 6146              		.set	.LANCHOR19,. + 0
 6149              	xNumOfOverflows:
 6150 0000 00000000 		.space	4
 6151              		.section	.bss.xPendingReadyList,"aw",%nobits
 6152              		.align	2
 6153              		.set	.LANCHOR3,. + 0
 6156              	xPendingReadyList:
 6157 0000 00000000 		.space	20
 6157      00000000 
 6157      00000000 
 6157      00000000 
 6157      00000000 
 6158              		.section	.bss.xSchedulerRunning,"aw",%nobits
 6159              		.align	2
 6160              		.set	.LANCHOR11,. + 0
 6163              	xSchedulerRunning:
 6164 0000 00000000 		.space	4
 6165              		.section	.bss.xSuspendedTaskList,"aw",%nobits
 6166              		.align	2
 6167              		.set	.LANCHOR2,. + 0
 6170              	xSuspendedTaskList:
 6171 0000 00000000 		.space	20
 6171      00000000 
 6171      00000000 
 6171      00000000 
 6171      00000000 
 6172              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
 6173              		.align	2
 6174              		.set	.LANCHOR7,. + 0
 6177              	xTasksWaitingTermination:
 6178 0000 00000000 		.space	20
 6178      00000000 
 6178      00000000 
 6178      00000000 
 6178      00000000 
 6179              		.section	.bss.xTickCount,"aw",%nobits
 6180              		.align	2
 6181              		.set	.LANCHOR15,. + 0
 6184              	xTickCount:
 6185 0000 00000000 		.space	4
 6186              		.section	.bss.xYieldPending,"aw",%nobits
 6187              		.align	2
 6188              		.set	.LANCHOR21,. + 0
 6191              	xYieldPending:
 6192 0000 00000000 		.space	4
 6193              		.section	.rodata.prvTaskIsTaskSuspended.str1.4,"aMS",%progbits,1
 6194              		.align	2
 6195              	.LC0:
 6196 0000 2E2E2F73 		.ascii	"../src/FreeRTOS/tasks.c\000"
 6196      72632F46 
 6196      72656552 
 6196      544F532F 
 6196      7461736B 
 6197              		.section	.rodata.vTaskGetRunTimeStats.str1.4,"aMS",%progbits,1
 6198              		.align	2
 6199              	.LC3:
 6200 0000 09257509 		.ascii	"\011%u\011\011%u%%\015\012\000"
 6200      09257525 
 6200      250D0A00 
 6201              	.LC4:
 6202 000c 09257509 		.ascii	"\011%u\011\011<1%%\015\012\000"
 6202      093C3125 
 6202      250D0A00 
 6203              		.section	.rodata.vTaskList.str1.4,"aMS",%progbits,1
 6204              		.align	2
 6205              	.LC2:
 6206 0000 09256309 		.ascii	"\011%c\011%u\011%u\011%u\015\012\000"
 6206      25750925 
 6206      75092575 
 6206      0D0A00
 6207              		.section	.rodata.vTaskStartScheduler.str1.4,"aMS",%progbits,1
 6208              		.align	2
 6209              	.LC1:
 6210 0000 49444C45 		.ascii	"IDLE\000"
 6210      00
 6211              		.text
 6212              	.Letext0:
 6213              		.file 2 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\lib\\gcc\\arm-none-eab
 6214              		.file 3 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\include
 6215              		.file 4 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\include
 6216              		.file 5 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\include
 6217              		.file 6 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\include
 6218              		.file 7 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\include
 6219              		.file 8 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\include
 6220              		.file 9 "C:/Renesas/e2studio_2021_01_workspace_RZA2M_ANPR/ANPR_RZA2M_EBK/src/FreeRTOS/include/priv
 6221              		.file 10 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\includ
 6222              		.file 11 "C:/Renesas/e2studio_2021_01_workspace_RZA2M_ANPR/ANPR_RZA2M_EBK/src/FreeRTOS/portable/GC
 6223              		.file 12 "C:/Renesas/e2studio_2021_01_workspace_RZA2M_ANPR/ANPR_RZA2M_EBK/src/FreeRTOS/include/pri
 6224              		.file 13 "C:/Renesas/e2studio_2021_01_workspace_RZA2M_ANPR/ANPR_RZA2M_EBK/src/FreeRTOS/include/tas
 6225              		.file 14 "C:/Renesas/e2studio_2021_01_workspace_RZA2M_ANPR/ANPR_RZA2M_EBK/src/config_files/FreeRTO
 6226              		.file 15 "C:/Renesas/e2studio_2021_01_workspace_RZA2M_ANPR/ANPR_RZA2M_EBK/src/FreeRTOS/include/pri
 6227              		.file 16 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\includ
 6228              		.file 17 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\includ
 6229              		.file 18 "C:/Renesas/e2studio_2021_01_workspace_RZA2M_ANPR/ANPR_RZA2M_EBK/src/FreeRTOS/include/tim
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:17     .text.prvTaskCheckFreeStackSpace:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:22     .text.prvTaskCheckFreeStackSpace:00000000 prvTaskCheckFreeStackSpace
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:57     .text.prvResetNextTaskUnblockTime:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:62     .text.prvResetNextTaskUnblockTime:00000000 prvResetNextTaskUnblockTime
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6041   .bss.pxDelayedTaskList:00000000 .LANCHOR0
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6139   .bss.xNextTaskUnblockTime:00000000 .LANCHOR1
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:110    .text.prvDeleteTCB:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:115    .text.prvDeleteTCB:00000000 prvDeleteTCB
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:141    .text.prvTaskIsTaskSuspended:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:146    .text.prvTaskIsTaskSuspended:00000000 prvTaskIsTaskSuspended
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6167   .bss.xSuspendedTaskList:00000000 .LANCHOR2
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6153   .bss.xPendingReadyList:00000000 .LANCHOR3
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6195   .rodata.prvTaskIsTaskSuspended.str1.4:00000000 .LC0
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:220    .text.prvInitialiseNewTask:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:225    .text.prvInitialiseNewTask:00000000 prvInitialiseNewTask
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:368    .text.prvInitialiseTaskLists:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:373    .text.prvInitialiseTaskLists:00000000 prvInitialiseTaskLists
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6055   .bss.pxReadyTasksLists:00000000 .LANCHOR4
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6111   .bss.xDelayedTaskList1:00000000 .LANCHOR5
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6118   .bss.xDelayedTaskList2:00000000 .LANCHOR6
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6174   .bss.xTasksWaitingTermination:00000000 .LANCHOR7
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6048   .bss.pxOverflowDelayedTaskList:00000000 .LANCHOR8
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:447    .text.prvAddNewTaskToReadyList:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:452    .text.prvAddNewTaskToReadyList:00000000 prvAddNewTaskToReadyList
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6069   .bss.uxCurrentNumberOfTasks:00000000 .LANCHOR9
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6034   .bss.pxCurrentTCB:00000000 .LANCHOR10
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6160   .bss.xSchedulerRunning:00000000 .LANCHOR11
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6097   .bss.uxTaskNumber:00000000 .LANCHOR12
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6104   .bss.uxTopReadyPriority:00000000 .LANCHOR13
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:569    .text.prvCheckTasksWaitingTermination:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:574    .text.prvCheckTasksWaitingTermination:00000000 prvCheckTasksWaitingTermination
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6076   .bss.uxDeletedTasksWaitingCleanUp:00000000 .LANCHOR14
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:634    .text.prvIdleTask:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:639    .text.prvIdleTask:00000000 prvIdleTask
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:674    .text.prvAddCurrentTaskToDelayedList:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:679    .text.prvAddCurrentTaskToDelayedList:00000000 prvAddCurrentTaskToDelayedList
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6181   .bss.xTickCount:00000000 .LANCHOR15
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:780    .text.prvWriteNameToBuffer:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:785    .text.prvWriteNameToBuffer:00000000 prvWriteNameToBuffer
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:827    .text.xTaskCreate:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:833    .text.xTaskCreate:00000000 xTaskCreate
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:935    .text.vTaskDelete:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:941    .text.vTaskDelete:00000000 vTaskDelete
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6090   .bss.uxSchedulerSuspended:00000000 .LANCHOR16
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1068   .text.eTaskGetState:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1074   .text.eTaskGetState:00000000 eTaskGetState
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1186   .text.uxTaskPriorityGet:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1192   .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1233   .text.uxTaskPriorityGetFromISR:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1239   .text.uxTaskPriorityGetFromISR:00000000 uxTaskPriorityGetFromISR
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1283   .text.vTaskPrioritySet:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1289   .text.vTaskPrioritySet:00000000 vTaskPrioritySet
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1483   .text.vTaskResume:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1489   .text.vTaskResume:00000000 vTaskResume
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1587   .text.xTaskResumeFromISR:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1593   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1712   .text.vTaskStartScheduler:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1718   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6125   .bss.xIdleTaskHandle:00000000 .LANCHOR17
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6209   .rodata.vTaskStartScheduler.str1.4:00000000 .LC1
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1808   .text.vTaskEndScheduler:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1814   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1840   .text.vTaskSuspendAll:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1846   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1864   .text.xTaskGetTickCount:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1870   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1888   .text.xTaskGetIdleTickCount:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1894   .text.xTaskGetIdleTickCount:00000000 xTaskGetIdleTickCount
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6132   .bss.xIdleTickCount:00000000 .LANCHOR18
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1912   .text.xTaskGetTickCountFromISR:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1918   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1942   .text.xTaskGetIdleTickCountFromISR:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1948   .text.xTaskGetIdleTickCountFromISR:00000000 xTaskGetIdleTickCountFromISR
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1972   .text.uxTaskGetNumberOfTasks:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1978   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:1995   .text.pcTaskGetName:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:2001   .text.pcTaskGetName:00000000 pcTaskGetName
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:2046   .text.xTaskIncrementTick:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:2052   .text.xTaskIncrementTick:00000000 xTaskIncrementTick
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6146   .bss.xNumOfOverflows:00000000 .LANCHOR19
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6083   .bss.uxPendedTicks:00000000 .LANCHOR20
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6188   .bss.xYieldPending:00000000 .LANCHOR21
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:2279   .text.xTaskResumeAll:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:2285   .text.xTaskResumeAll:00000000 xTaskResumeAll
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:2480   .text.vTaskDelayUntil:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:2486   .text.vTaskDelayUntil:00000000 vTaskDelayUntil
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:2637   .text.vTaskDelay:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:2643   .text.vTaskDelay:00000000 vTaskDelay
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:2709   .text.xTaskAbortDelay:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:2715   .text.xTaskAbortDelay:00000000 xTaskAbortDelay
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:2833   .text.vTaskSwitchContext:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:2839   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6062   .bss.ulTaskSwitchedInTime:00000000 .LANCHOR22
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3022   .text.vTaskSuspend:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3028   .text.vTaskSuspend:00000000 vTaskSuspend
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3171   .text.vTaskPlaceOnEventList:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3177   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3225   .text.vTaskPlaceOnUnorderedEventList:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3231   .text.vTaskPlaceOnUnorderedEventList:00000000 vTaskPlaceOnUnorderedEventList
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3300   .text.vTaskPlaceOnEventListRestricted:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3306   .text.vTaskPlaceOnEventListRestricted:00000000 vTaskPlaceOnEventListRestricted
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3361   .text.xTaskRemoveFromEventList:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3367   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3469   .text.vTaskRemoveFromUnorderedEventList:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3475   .text.vTaskRemoveFromUnorderedEventList:00000000 vTaskRemoveFromUnorderedEventList
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3576   .text.vTaskSetTimeOutState:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3582   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3629   .text.vTaskInternalSetTimeOutState:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3635   .text.vTaskInternalSetTimeOutState:00000000 vTaskInternalSetTimeOutState
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3658   .text.xTaskCheckForTimeOut:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3664   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3805   .text.vTaskMissedYield:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3811   .text.vTaskMissedYield:00000000 vTaskMissedYield
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3828   .text.uxTaskGetTaskNumber:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3834   .text.uxTaskGetTaskNumber:00000000 uxTaskGetTaskNumber
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3861   .text.vTaskSetTaskNumber:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3867   .text.vTaskSetTaskNumber:00000000 vTaskSetTaskNumber
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3885   .text.vTaskSetThreadLocalStoragePointer:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3891   .text.vTaskSetThreadLocalStoragePointer:00000000 vTaskSetThreadLocalStoragePointer
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3924   .text.pvTaskGetThreadLocalStoragePointer:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3930   .text.pvTaskGetThreadLocalStoragePointer:00000000 pvTaskGetThreadLocalStoragePointer
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3971   .text.vTaskGetInfo:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:3977   .text.vTaskGetInfo:00000000 vTaskGetInfo
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4091   .text.prvListTasksWithinSingleList:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4096   .text.prvListTasksWithinSingleList:00000000 prvListTasksWithinSingleList
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4196   .text.uxTaskGetSystemState:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4202   .text.uxTaskGetSystemState:00000000 uxTaskGetSystemState
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4326   .text.uxTaskGetStackHighWaterMark:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4332   .text.uxTaskGetStackHighWaterMark:00000000 uxTaskGetStackHighWaterMark
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4367   .text.xTaskGetCurrentTaskHandle:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4373   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4391   .text.xTaskGetSchedulerState:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4397   .text.xTaskGetSchedulerState:00000000 xTaskGetSchedulerState
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4433   .text.xTaskPriorityInherit:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4439   .text.xTaskPriorityInherit:00000000 xTaskPriorityInherit
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4570   .text.xTaskPriorityDisinherit:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4576   .text.xTaskPriorityDisinherit:00000000 xTaskPriorityDisinherit
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4683   .text.vTaskPriorityDisinheritAfterTimeout:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4689   .text.vTaskPriorityDisinheritAfterTimeout:00000000 vTaskPriorityDisinheritAfterTimeout
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4819   .text.vTaskList:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4825   .text.vTaskList:00000000 vTaskList
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6205   .rodata.vTaskList.str1.4:00000000 .LC2
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4965   .text.vTaskList:00000144 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4972   .text.vTaskList:00000158 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4986   .text.vTaskGetRunTimeStats:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:4992   .text.vTaskGetRunTimeStats:00000000 vTaskGetRunTimeStats
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6201   .rodata.vTaskGetRunTimeStats.str1.4:0000000c .LC4
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6199   .rodata.vTaskGetRunTimeStats.str1.4:00000000 .LC3
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5131   .text.uxTaskResetEventItemValue:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5137   .text.uxTaskResetEventItemValue:00000000 uxTaskResetEventItemValue
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5162   .text.pvTaskIncrementMutexHeldCount:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5168   .text.pvTaskIncrementMutexHeldCount:00000000 pvTaskIncrementMutexHeldCount
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5199   .text.ulTaskNotifyTake:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5205   .text.ulTaskNotifyTake:00000000 ulTaskNotifyTake
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5305   .text.xTaskNotifyWait:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5311   .text.xTaskNotifyWait:00000000 xTaskNotifyWait
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5428   .text.xTaskGenericNotify:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5434   .text.xTaskGenericNotify:00000000 xTaskGenericNotify
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5480   .text.xTaskGenericNotify:00000048 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5487   .text.xTaskGenericNotify:00000058 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5609   .text.xTaskGenericNotifyFromISR:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5615   .text.xTaskGenericNotifyFromISR:00000000 xTaskGenericNotifyFromISR
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5666   .text.xTaskGenericNotifyFromISR:00000050 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5673   .text.xTaskGenericNotifyFromISR:00000060 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5823   .text.vTaskNotifyGiveFromISR:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5829   .text.vTaskNotifyGiveFromISR:00000000 vTaskNotifyGiveFromISR
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5971   .text.xTaskNotifyStateClear:00000000 $a
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:5977   .text.xTaskNotifyStateClear:00000000 xTaskNotifyStateClear
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6037   .bss.pxCurrentTCB:00000000 pxCurrentTCB
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6033   .bss.pxCurrentTCB:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6040   .bss.pxDelayedTaskList:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6044   .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6047   .bss.pxOverflowDelayedTaskList:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6051   .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6054   .bss.pxReadyTasksLists:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6058   .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6061   .bss.ulTaskSwitchedInTime:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6065   .bss.ulTaskSwitchedInTime:00000000 ulTaskSwitchedInTime
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6068   .bss.uxCurrentNumberOfTasks:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6072   .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6075   .bss.uxDeletedTasksWaitingCleanUp:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6079   .bss.uxDeletedTasksWaitingCleanUp:00000000 uxDeletedTasksWaitingCleanUp
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6082   .bss.uxPendedTicks:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6086   .bss.uxPendedTicks:00000000 uxPendedTicks
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6089   .bss.uxSchedulerSuspended:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6093   .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6096   .bss.uxTaskNumber:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6100   .bss.uxTaskNumber:00000000 uxTaskNumber
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6103   .bss.uxTopReadyPriority:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6107   .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6110   .bss.xDelayedTaskList1:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6114   .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6117   .bss.xDelayedTaskList2:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6121   .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6124   .bss.xIdleTaskHandle:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6128   .bss.xIdleTaskHandle:00000000 xIdleTaskHandle
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6131   .bss.xIdleTickCount:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6135   .bss.xIdleTickCount:00000000 xIdleTickCount
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6138   .bss.xNextTaskUnblockTime:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6142   .bss.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6145   .bss.xNumOfOverflows:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6149   .bss.xNumOfOverflows:00000000 xNumOfOverflows
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6152   .bss.xPendingReadyList:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6156   .bss.xPendingReadyList:00000000 xPendingReadyList
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6159   .bss.xSchedulerRunning:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6163   .bss.xSchedulerRunning:00000000 xSchedulerRunning
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6166   .bss.xSuspendedTaskList:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6170   .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6173   .bss.xTasksWaitingTermination:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6177   .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6180   .bss.xTickCount:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6184   .bss.xTickCount:00000000 xTickCount
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6187   .bss.xYieldPending:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6191   .bss.xYieldPending:00000000 xYieldPending
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6194   .rodata.prvTaskIsTaskSuspended.str1.4:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6198   .rodata.vTaskGetRunTimeStats.str1.4:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6204   .rodata.vTaskList.str1.4:00000000 $d
C:\Users\a5050395\AppData\Local\Temp\cc4rXhn5.s:6208   .rodata.vTaskStartScheduler.str1.4:00000000 $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.14fc17be114e5a2cba0959c511ea2aaf
                           .group:00000000 wm4._newlib_version.h.4.3572908597b70d672d181fc7fc501c19
                           .group:00000000 wm4.newlib.h.21.59901f4bf241ab46c63694665baa7297
                           .group:00000000 wm4.features.h.22.5cdadbb3efe495d1c9e38350b8c376c7
                           .group:00000000 wm4.config.h.219.65a553ab5bef5482f0d7880b0d33015e
                           .group:00000000 wm4._ansi.h.23.9f8fcfa20193763fcf364fb91705c94b
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.stddef.h.187.e1c83cba2098ce92b68f6311de19e6b1
                           .group:00000000 wm4.stddef.h.39.57db33e786ccd422e31be63a26e19309
                           .group:00000000 wm4._default_types.h.6.959254cf5f09734ea7516c89e8bb21bd
                           .group:00000000 wm4.lock.h.2.1461d1fff82dffe8bfddc23307f6484f
                           .group:00000000 wm4._types.h.125.5cf8a495f1f7ef36777ad868a1e32068
                           .group:00000000 wm4.stddef.h.161.5349cb105733e8777bfb0cf53c4e3f34
                           .group:00000000 wm4._types.h.183.c226d164ceca1f2ecb9ae9360c54a098
                           .group:00000000 wm4.reent.h.17.23b059516345f8f5abfa01ddc379570f
                           .group:00000000 wm4.cdefs.h.47.e658329a094974ebad41b40c60502de7
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.56.d4493cd3736e51e9d56335045f26df45
                           .group:00000000 wm4.string.h.8.c4b8571ce60dff2817f43fec8b86aecd
                           .group:00000000 wm4.stddef.h.161.19e15733342b50ead2919490b095303e
                           .group:00000000 wm4._intsup.h.10.cce27fed8484c08a33f522034c30d2b5
                           .group:00000000 wm4._stdint.h.10.c24fa3af3bc1706662bb5593a907e841
                           .group:00000000 wm4.stdint.h.23.d53047a68f4a85177f80b422d52785ed
                           .group:00000000 wm4.r_task_priority.h.26.416bb98a222bf391200df359bd0318d1
                           .group:00000000 wm4.FreeRTOSConfig.h.79.fd739ecab5eecc474fbd4cdebb362b54
                           .group:00000000 wm4.projdefs.h.29.3472c8470d131a5f474bc7437ea94609
                           .group:00000000 wm4.math.h.13.adb102f7bd7860b1f241e149d6914a1e
                           .group:00000000 wm4.r_typedefs.h.38.e90d9de5300d9ae020e5db8c5af88b3e
                           .group:00000000 wm4.portmacro.h.32.440d21c040186908c7273660706c6bca
                           .group:00000000 wm4.portable.h.64.00b423ba030e23bed354b037664af7a6
                           .group:00000000 wm4.mpu_wrappers.h.29.89d425470b0b1ff39fbd61026b3dc073
                           .group:00000000 wm4.FreeRTOS.h.66.bad6b88d088f10e2b23c3b49ecb7db7d
                           .group:00000000 wm4.list.h.61.bafeaa82806d71ae8917c6d7827fc3d2
                           .group:00000000 wm4.task.h.46.d14b2b6bfa640e74f781e050155168fa
                           .group:00000000 wm4.timers.h.54.b1628205d6a51adaf32536954da510c0
                           .group:00000000 wm4.stack_macros.h.29.2fd3b6d43f2a943c04e7ecc661c93ca1
                           .group:00000000 wm4.stdio.h.27.3fc80220048df77954e38daec3bb9670
                           .group:00000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:00000000 wm4.types.h.40.e8c16e7ec36ba55f133d0616070e25fc
                           .group:00000000 wm4._endian.h.31.65a10590763c3dde1ac4a7f66d7d4891
                           .group:00000000 wm4.endian.h.9.49f3a4695c1b61e8a0808de3c4a106cb
                           .group:00000000 wm4._timeval.h.30.0e8bfd94e85db17dda3286ee81496fe6
                           .group:00000000 wm4.timespec.h.41.d855182eb0e690443ab8651bcedca6e1
                           .group:00000000 wm4.select.h.30.bbece7fa40993a78092dcc5805132560
                           .group:00000000 wm4.types.h.69.ed3eae3cf73030a737515151ebcab7a1
                           .group:00000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:00000000 wm4.stdio.h.81.8188691c2279eac7a223caa50f6694b9

UNDEFINED SYMBOLS
vPortFree
R_OS_AssertCalled
memset
vListInitialiseItem
pxPortInitialiseStack
vListInitialise
vPortEnterCritical
vListInsertEnd
vPortExitCritical
uxListRemove
vListInsert
strcpy
strlen
pvPortMalloc
vPortValidateInterruptPriority
ulPortSetInterruptMask
vPortClearInterruptMask
xTimerCreateTimerTask
vInitialiseRunTimeStats
xPortStartScheduler
vPortEndScheduler
ulGetRunTimeCounterValue
vApplicationStackOverflowHook
sprintf
__aeabi_uidiv
